#![feature(prelude_import)]
//! A Minecraft beta 1.7.3 server backend in Rust.
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
pub mod io {
    //! This module provides read and write extension traits for Java types.
    use byteorder::{ReadBytesExt, WriteBytesExt, BE};
    use std::io::{self, Read, Write};
    /// Extension trait with Minecraft-specific packet read methods.
    pub trait ReadJavaExt: Read {
        #[inline]
        fn read_java_byte(&mut self) -> io::Result<i8> {
            ReadBytesExt::read_i8(self)
        }
        #[inline]
        fn read_java_short(&mut self) -> io::Result<i16> {
            ReadBytesExt::read_i16::<BE>(self)
        }
        #[inline]
        fn read_java_int(&mut self) -> io::Result<i32> {
            ReadBytesExt::read_i32::<BE>(self)
        }
        #[inline]
        fn read_java_long(&mut self) -> io::Result<i64> {
            ReadBytesExt::read_i64::<BE>(self)
        }
        #[inline]
        fn read_java_float(&mut self) -> io::Result<f32> {
            ReadBytesExt::read_f32::<BE>(self)
        }
        #[inline]
        fn read_java_double(&mut self) -> io::Result<f64> {
            ReadBytesExt::read_f64::<BE>(self)
        }
        #[inline]
        fn read_java_boolean(&mut self) -> io::Result<bool> {
            Ok(self.read_java_byte()? != 0)
        }
        fn read_java_string16(&mut self, max_len: usize) -> io::Result<String> {
            let len = self.read_java_short()?;
            if len < 0 {
                return Err(new_invalid_data_err("negative length string"));
            }
            if len as usize > max_len {
                return Err(new_invalid_data_err("exceeded max string length"));
            }
            let mut raw = Vec::with_capacity(len as usize);
            for _ in 0..len {
                raw.push(ReadBytesExt::read_u16::<BE>(self)?);
            }
            let ret = char::decode_utf16(raw)
                .map(|res| res.unwrap_or(char::REPLACEMENT_CHARACTER))
                .collect::<String>();
            Ok(ret)
        }
        fn read_java_string8(&mut self) -> io::Result<String> {
            let len = self.read_u16::<BE>()?;
            let mut buf = ::alloc::vec::from_elem(0u8, len as usize);
            self.read_exact(&mut buf)?;
            String::from_utf8(buf)
                .map_err(|_| new_invalid_data_err("invalid utf-8 string"))
        }
    }
    /// Extension trait with Minecraft-specific packet write methods.
    pub trait WriteJavaExt: Write {
        #[inline]
        fn write_java_byte(&mut self, b: i8) -> io::Result<()> {
            WriteBytesExt::write_i8(self, b)
        }
        #[inline]
        fn write_java_short(&mut self, s: i16) -> io::Result<()> {
            WriteBytesExt::write_i16::<BE>(self, s)
        }
        #[inline]
        fn write_java_int(&mut self, i: i32) -> io::Result<()> {
            WriteBytesExt::write_i32::<BE>(self, i)
        }
        #[inline]
        fn write_java_long(&mut self, l: i64) -> io::Result<()> {
            WriteBytesExt::write_i64::<BE>(self, l)
        }
        #[inline]
        fn write_java_float(&mut self, f: f32) -> io::Result<()> {
            WriteBytesExt::write_f32::<BE>(self, f)
        }
        #[inline]
        fn write_java_double(&mut self, d: f64) -> io::Result<()> {
            WriteBytesExt::write_f64::<BE>(self, d)
        }
        #[inline]
        fn write_java_boolean(&mut self, b: bool) -> io::Result<()> {
            self.write_java_byte(b as i8)
        }
        fn write_java_string16(&mut self, s: &str) -> io::Result<()> {
            let len = s.chars().map(|c| c.len_utf16()).sum::<usize>();
            if len > i16::MAX as usize {
                return Err(new_invalid_data_err("string too big"));
            }
            self.write_java_short(len as i16)?;
            for code in s.encode_utf16() {
                WriteBytesExt::write_u16::<BE>(self, code)?;
            }
            Ok(())
        }
        fn write_java_string8(&mut self, s: &str) -> io::Result<()> {
            if s.len() > u16::MAX as usize {
                return Err(new_invalid_data_err("string too big"));
            }
            self.write_u16::<BE>(s.len() as u16)?;
            self.write_all(s.as_bytes())
        }
    }
    impl<R: Read> ReadJavaExt for R {}
    impl<W: Write> WriteJavaExt for W {}
    /// Return an invalid data io error with specific message.
    fn new_invalid_data_err(message: &'static str) -> io::Error {
        io::Error::new(io::ErrorKind::InvalidData, message)
    }
}
pub mod util {
    //! Various uncategorized utilities.
    /// A function to better inline the default function call.
    #[inline(always)]
    pub(crate) fn default<T: Default>() -> T {
        T::default()
    }
    /// A fading average
    pub struct FadingAverage {
        value: f32,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FadingAverage {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "FadingAverage",
                "value",
                &&self.value,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FadingAverage {
        #[inline]
        fn clone(&self) -> FadingAverage {
            FadingAverage {
                value: ::core::clone::Clone::clone(&self.value),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for FadingAverage {
        #[inline]
        fn default() -> FadingAverage {
            FadingAverage {
                value: ::core::default::Default::default(),
            }
        }
    }
    impl FadingAverage {
        #[inline]
        pub fn push(&mut self, value: f32, factor: f32) {
            self.value = (self.value * (1.0 - factor)) + value * factor;
        }
        #[inline]
        pub fn get(&self) -> f32 {
            self.value
        }
    }
}
pub mod geom {
    //! Various geometry utilities that completes the [`glam`] math crate.
    use std::ops::{Add, AddAssign, Sub, SubAssign, BitOr, BitOrAssign};
    use std::fmt;
    use glam::{DVec3, IVec3};
    /// An axis-aligned bounding box.
    pub struct BoundingBox {
        pub min: DVec3,
        pub max: DVec3,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for BoundingBox {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "BoundingBox",
                "min",
                &self.min,
                "max",
                &&self.max,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BoundingBox {
        #[inline]
        fn clone(&self) -> BoundingBox {
            let _: ::core::clone::AssertParamIsClone<DVec3>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for BoundingBox {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for BoundingBox {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for BoundingBox {
        #[inline]
        fn eq(&self, other: &BoundingBox) -> bool {
            self.min == other.min && self.max == other.max
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for BoundingBox {
        #[inline]
        fn default() -> BoundingBox {
            BoundingBox {
                min: ::core::default::Default::default(),
                max: ::core::default::Default::default(),
            }
        }
    }
    impl BoundingBox {
        pub const CUBE: Self = Self {
            min: DVec3::ZERO,
            max: DVec3::ONE,
        };
        /// Construct a new bounding box from the minimum and maximum points.
        pub const fn new(
            min_x: f64,
            min_y: f64,
            min_z: f64,
            max_x: f64,
            max_y: f64,
            max_z: f64,
        ) -> Self {
            Self {
                min: DVec3::new(min_x, min_y, min_z),
                max: DVec3::new(max_x, max_y, max_z),
            }
        }
        /// Calculate the size of this bounding box.
        pub fn size(self) -> DVec3 {
            self.max - self.min
        }
        pub fn size_x(self) -> f64 {
            self.max.x - self.min.x
        }
        pub fn size_y(self) -> f64 {
            self.max.y - self.min.y
        }
        pub fn size_z(self) -> f64 {
            self.max.z - self.min.z
        }
        /// Calculate the center of the bounding box.
        pub fn center(self) -> DVec3 {
            (self.min + self.max) / 2.0
        }
        /// Calculate the X center of the bounding box.
        pub fn center_x(self) -> f64 {
            (self.min.x + self.max.x) / 2.0
        }
        /// Calculate the Y center of the bounding box.
        pub fn center_y(self) -> f64 {
            (self.min.y + self.max.y) / 2.0
        }
        /// Calculate the Z center of the bounding box.
        pub fn center_z(self) -> f64 {
            (self.min.z + self.max.z) / 2.0
        }
        /// Expand this bounding box in all direction by the given delta.
        pub fn inflate(self, delta: DVec3) -> Self {
            Self {
                min: self.min - delta,
                max: self.max + delta,
            }
        }
        /// Offset this bounding box' coordinates by the given delta.
        pub fn offset(self, delta: DVec3) -> Self {
            Self {
                min: self.min + delta,
                max: self.max + delta,
            }
        }
        /// Expand this bounding box by the given delta, only in the delta's direction.
        pub fn expand(mut self, delta: DVec3) -> Self {
            if delta.x < 0.0 {
                self.min.x += delta.x;
            } else if delta.x > 0.0 {
                self.max.x += delta.x;
            }
            if delta.y < 0.0 {
                self.min.y += delta.y;
            } else if delta.y > 0.0 {
                self.max.y += delta.y;
            }
            if delta.z < 0.0 {
                self.min.z += delta.z;
            } else if delta.z > 0.0 {
                self.max.z += delta.z;
            }
            self
        }
        /// Return true if this bounding box intersects with the given one.
        pub fn intersects(self, other: Self) -> bool {
            other.max.x > self.min.x && other.min.x < self.max.x
                && other.max.y > self.min.y && other.min.y < self.max.y
                && other.max.z > self.min.z && other.min.z < self.max.z
        }
        /// Return true if this bounding box intersects with the given one on the X axis.
        pub fn intersects_x(self, other: Self) -> bool {
            other.max.x > self.min.x && other.min.x < self.max.x
        }
        /// Return true if this bounding box intersects with the given one on the Y axis.
        pub fn intersects_y(self, other: Self) -> bool {
            other.max.y > self.min.y && other.min.y < self.max.y
        }
        /// Return true if this bounding box intersects with the given one on the Z axis.
        pub fn intersects_z(self, other: Self) -> bool {
            other.max.z > self.min.z && other.min.z < self.max.z
        }
        /// Return true if this bounding box contains the given point.
        pub fn contains(self, point: DVec3) -> bool {
            point.x > self.min.x && point.x < self.max.x && point.y > self.min.y
                && point.y < self.max.y && point.z > self.min.z && point.z < self.max.z
        }
        /// Return true if the point is contained in this bounding box on Y/Z axis only.
        pub fn contains_yz(self, point: DVec3) -> bool {
            point.y >= self.min.y && point.y <= self.max.y && point.z >= self.min.z
                && point.z <= self.max.z
        }
        /// Return true if the point is contained in this bounding box on X/Z axis only.
        pub fn contains_xz(self, point: DVec3) -> bool {
            point.x >= self.min.x && point.x <= self.max.x && point.z >= self.min.z
                && point.z <= self.max.z
        }
        /// Return true if the point is contained in this bounding box on X/Y axis only.
        pub fn contains_xy(self, point: DVec3) -> bool {
            point.x >= self.min.x && point.x <= self.max.x && point.y >= self.min.y
                && point.y <= self.max.y
        }
        /// Simulate an offset of the given bounding box by the given delta, but with this
        /// bounding box potentially colliding with it in the way, this function will return
        /// the new delta that avoid this collision.
        pub fn calc_x_delta(self, other: Self, mut dx: f64) -> f64 {
            if other.max.y > self.min.y && other.min.y < self.max.y {
                if other.max.z > self.min.z && other.min.z < self.max.z {
                    if dx > 0.0 && other.max.x <= self.min.x {
                        dx = dx.min(self.min.x - other.max.x);
                    } else if dx < 0.0 && other.min.x >= self.max.x {
                        dx = dx.max(self.max.x - other.min.x);
                    }
                }
            }
            dx
        }
        /// Simulate an offset of the given bounding box by the given delta, but with this
        /// bounding box potentially colliding with it in the way, this function will return
        /// the new delta that avoid this collision.
        pub fn calc_y_delta(self, other: Self, mut dy: f64) -> f64 {
            if other.max.x > self.min.x && other.min.x < self.max.x {
                if other.max.z > self.min.z && other.min.z < self.max.z {
                    if dy > 0.0 && other.max.y <= self.min.y {
                        dy = dy.min(self.min.y - other.max.y);
                    } else if dy < 0.0 && other.min.y >= self.max.y {
                        dy = dy.max(self.max.y - other.min.y);
                    }
                }
            }
            dy
        }
        /// Simulate an offset of the given bounding box by the given delta, but with this
        /// bounding box potentially colliding with it in the way, this function will return
        /// the new delta that avoid this collision.
        pub fn calc_z_delta(self, other: Self, mut dz: f64) -> f64 {
            if other.max.x > self.min.x && other.min.x < self.max.x {
                if other.max.y > self.min.y && other.min.y < self.max.y {
                    if dz > 0.0 && other.max.z <= self.min.z {
                        dz = dz.min(self.min.z - other.max.z);
                    } else if dz < 0.0 && other.min.z >= self.max.z {
                        dz = dz.max(self.max.z - other.min.z);
                    }
                }
            }
            dz
        }
        /// Compute an intersection of a ray into this bounding box. If this ray intersects
        /// this box, the new vector that hit the first face is returned.
        pub fn calc_ray_trace(self, origin: DVec3, ray: DVec3) -> Option<(DVec3, Face)> {
            if ray.x * ray.x >= 1e-7 {
                let (factor, face) = if ray.x > 0.0 {
                    ((self.min.x - origin.x) / ray.x, Face::NegX)
                } else {
                    ((self.max.x - origin.x) / ray.x, Face::PosX)
                };
                let point = origin + ray * factor;
                if self.contains_yz(point) {
                    return Some((point - origin, face));
                }
            }
            if ray.y * ray.y >= 1e-7 {
                let (factor, face) = if ray.y > 0.0 {
                    ((self.min.y - origin.y) / ray.y, Face::NegY)
                } else {
                    ((self.max.y - origin.y) / ray.y, Face::PosY)
                };
                let point = origin + ray * factor;
                if self.contains_xz(point) {
                    return Some((point - origin, face));
                }
            }
            if ray.z * ray.z >= 1e-7 {
                let (factor, face) = if ray.z > 0.0 {
                    ((self.min.z - origin.z) / ray.z, Face::NegZ)
                } else {
                    ((self.max.z - origin.z) / ray.z, Face::PosZ)
                };
                let point = origin + ray * factor;
                if self.contains_xy(point) {
                    return Some((point - origin, face));
                }
            }
            None
        }
    }
    impl Add<DVec3> for BoundingBox {
        type Output = BoundingBox;
        #[inline]
        fn add(self, rhs: DVec3) -> Self::Output {
            self.offset(rhs)
        }
    }
    impl AddAssign<DVec3> for BoundingBox {
        #[inline]
        fn add_assign(&mut self, rhs: DVec3) {
            *self = self.offset(rhs);
        }
    }
    impl Sub<DVec3> for BoundingBox {
        type Output = BoundingBox;
        #[inline]
        fn sub(self, rhs: DVec3) -> Self::Output {
            self.offset(-rhs)
        }
    }
    impl SubAssign<DVec3> for BoundingBox {
        #[inline]
        fn sub_assign(&mut self, rhs: DVec3) {
            *self = self.offset(-rhs);
        }
    }
    impl BitOr<BoundingBox> for BoundingBox {
        type Output = BoundingBox;
        #[inline]
        fn bitor(self, rhs: BoundingBox) -> Self::Output {
            BoundingBox {
                min: self.min.min(rhs.min),
                max: self.max.max(rhs.max),
            }
        }
    }
    impl BitOrAssign for BoundingBox {
        #[inline]
        fn bitor_assign(&mut self, rhs: Self) {
            *self = *self | rhs;
        }
    }
    impl fmt::Display for BoundingBox {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_fmt(format_args!("[{0}, {1}]", self.min, self.max))
        }
    }
    /// Represent a facing in the world.
    #[repr(u8)]
    pub enum Face {
        NegY = 0,
        PosY = 1,
        NegZ = 2,
        PosZ = 3,
        NegX = 4,
        PosX = 5,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Face {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Face::NegY => "NegY",
                    Face::PosY => "PosY",
                    Face::NegZ => "NegZ",
                    Face::PosZ => "PosZ",
                    Face::NegX => "NegX",
                    Face::PosX => "PosX",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Face {
        #[inline]
        fn clone(&self) -> Face {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Face {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Face {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Face {
        #[inline]
        fn eq(&self, other: &Face) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Face {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Face {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    impl Face {
        /// Array containing all 6 faces.
        pub const ALL: [Self; 6] = [
            Self::NegY,
            Self::PosY,
            Self::NegZ,
            Self::PosZ,
            Self::NegX,
            Self::PosX,
        ];
        /// Array containing all 4 horizontal faces.
        pub const HORIZONTAL: [Self; 4] = [
            Self::NegZ,
            Self::PosZ,
            Self::NegX,
            Self::PosX,
        ];
        /// Get a face from the yaw component of a look only.
        #[inline]
        pub fn from_yaw(yaw: f32) -> Self {
            match ((yaw * 4.0 / std::f32::consts::TAU + 0.5).floor() as i32) & 3 {
                0 => Self::PosZ,
                1 => Self::NegX,
                2 => Self::NegZ,
                3 => Self::PosX,
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
        /// Get a face from the yaw and pitch components of a look.
        #[inline]
        pub fn from_look(yaw: f32, pitch: f32) -> Self {
            if pitch < -std::f32::consts::FRAC_PI_4 {
                Self::PosY
            } else if pitch > std::f32::consts::FRAC_PI_4 {
                Self::NegY
            } else {
                Self::from_yaw(yaw)
            }
        }
        #[inline]
        pub fn is_pos(self) -> bool {
            match self {
                Face::PosX | Face::PosY | Face::PosZ => true,
                _ => false,
            }
        }
        #[inline]
        pub fn is_neg(self) -> bool {
            match self {
                Face::NegX | Face::NegY | Face::NegZ => true,
                _ => false,
            }
        }
        #[inline]
        pub fn is_y(self) -> bool {
            match self {
                Face::NegY | Face::PosY => true,
                _ => false,
            }
        }
        #[inline]
        pub fn is_x(self) -> bool {
            match self {
                Face::NegX | Face::PosX => true,
                _ => false,
            }
        }
        #[inline]
        pub fn is_z(self) -> bool {
            match self {
                Face::NegZ | Face::PosZ => true,
                _ => false,
            }
        }
        /// Get the axis (X, Y, Z) index for that face when using `glam` vectors.
        #[inline]
        pub fn axis_index(self) -> usize {
            match self {
                Face::NegY | Face::PosY => 1,
                Face::NegZ | Face::PosZ => 2,
                Face::NegX | Face::PosX => 0,
            }
        }
        /// Get the opposite face.
        #[inline]
        pub fn opposite(self) -> Self {
            match self {
                Face::NegY => Face::PosY,
                Face::PosY => Face::NegY,
                Face::NegZ => Face::PosZ,
                Face::PosZ => Face::NegZ,
                Face::NegX => Face::PosX,
                Face::PosX => Face::NegX,
            }
        }
        /// Rotate this face horizontally to right, Y faces don't change.
        #[inline]
        pub fn rotate_right(self) -> Self {
            match self {
                Face::NegZ => Face::PosX,
                Face::PosX => Face::PosZ,
                Face::PosZ => Face::NegX,
                Face::NegX => Face::NegZ,
                _ => self,
            }
        }
        /// Rotate this face horizontally to left, Y faces don't change.
        #[inline]
        pub fn rotate_left(self) -> Self {
            match self {
                Face::NegZ => Face::NegX,
                Face::NegX => Face::PosZ,
                Face::PosZ => Face::PosX,
                Face::PosX => Face::NegZ,
                _ => self,
            }
        }
        /// Get the delta vector for this face.
        #[inline]
        pub fn delta(self) -> IVec3 {
            match self {
                Face::NegY => IVec3::NEG_Y,
                Face::PosY => IVec3::Y,
                Face::NegZ => IVec3::NEG_Z,
                Face::PosZ => IVec3::Z,
                Face::NegX => IVec3::NEG_X,
                Face::PosX => IVec3::X,
            }
        }
        /// Extrude a face and form a bounding box. The face is extruded toward the opposite
        /// face. The given inset allows shrinking the face toward the center axis.
        #[inline]
        pub fn extrude(self, inset: f64, depth: f64) -> BoundingBox {
            let pos = inset;
            let neg = 1.0 - inset;
            match self {
                Face::NegY => BoundingBox::new(pos, 0.0, pos, neg, depth, neg),
                Face::PosY => BoundingBox::new(pos, 1.0 - depth, pos, neg, 1.0, neg),
                Face::NegZ => BoundingBox::new(pos, pos, 0.0, neg, neg, depth),
                Face::PosZ => BoundingBox::new(pos, pos, 1.0 - depth, neg, neg, 1.0),
                Face::NegX => BoundingBox::new(0.0, pos, pos, depth, neg, neg),
                Face::PosX => BoundingBox::new(1.0 - depth, pos, pos, 1.0, neg, neg),
            }
        }
    }
    /// A set of unique faces.
    pub struct FaceSet {
        /// Presence of face are encoded bit by bit, the index of each face is the value of
        /// their enumeration discriminant.
        inner: u8,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FaceSet {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "FaceSet",
                "inner",
                &&self.inner,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FaceSet {
        #[inline]
        fn clone(&self) -> FaceSet {
            let _: ::core::clone::AssertParamIsClone<u8>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for FaceSet {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FaceSet {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FaceSet {
        #[inline]
        fn eq(&self, other: &FaceSet) -> bool {
            self.inner == other.inner
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for FaceSet {}
    #[automatically_derived]
    impl ::core::cmp::Eq for FaceSet {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u8>;
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for FaceSet {
        #[inline]
        fn default() -> FaceSet {
            FaceSet {
                inner: ::core::default::Default::default(),
            }
        }
    }
    impl FaceSet {
        /// Create a new empty set.
        #[inline]
        pub const fn new() -> Self {
            Self { inner: 0 }
        }
        #[inline]
        pub fn is_empty(&self) -> bool {
            self.inner == 0
        }
        #[inline]
        pub fn clear(&mut self) {
            self.inner = 0;
        }
        #[inline]
        pub fn insert(&mut self, face: Face) -> bool {
            let prev = self.inner;
            self.inner |= 1 << face as u8;
            self.inner != prev
        }
        #[inline]
        pub fn remove(&mut self, face: Face) -> bool {
            let prev = self.inner;
            self.inner &= !(1 << face as u8);
            self.inner != prev
        }
        #[inline]
        pub fn contains(&self, face: Face) -> bool {
            self.inner & (1 << face as u8) != 0
        }
        #[inline]
        pub fn contains_x(&self) -> bool {
            const MASK: u8 = (1 << Face::NegX as u8) | (1 << Face::PosX as u8);
            self.inner & MASK != 0
        }
        #[inline]
        pub fn contains_y(&self) -> bool {
            const MASK: u8 = (1 << Face::NegY as u8) | (1 << Face::PosY as u8);
            self.inner & MASK != 0
        }
        #[inline]
        pub fn contains_z(&self) -> bool {
            const MASK: u8 = (1 << Face::NegZ as u8) | (1 << Face::PosZ as u8);
            self.inner & MASK != 0
        }
    }
    impl FromIterator<Face> for FaceSet {
        #[inline]
        fn from_iter<T: IntoIterator<Item = Face>>(iter: T) -> Self {
            let mut set = FaceSet::new();
            for face in iter {
                set.insert(face);
            }
            set
        }
    }
}
pub mod rand {
    //! Different kind of pseudo-random number generator.
    use std::sync::atomic::{AtomicI64, Ordering};
    use std::time::{UNIX_EPOCH, SystemTime};
    use std::num::Wrapping;
    use glam::{Vec3, DVec3};
    const MULTIPLIER: Wrapping<i64> = Wrapping(0x5DEECE66D);
    const ADDEND: Wrapping<i64> = Wrapping(0xB);
    const MASK: Wrapping<i64> = Wrapping((1 << 48) - 1);
    const FLOAT_DIV: f32 = (1u32 << 24) as f32;
    const DOUBLE_DIV: f64 = (1u64 << 53) as f64;
    #[inline]
    fn initial_scramble(seed: i64) -> Wrapping<i64> {
        (Wrapping(seed) ^ MULTIPLIER) & MASK
    }
    /// Generate a new seed in the same way as `java.f.Random` (same constants).
    fn gen_seed() -> i64 {
        static SEED: AtomicI64 = AtomicI64::new(8682522807148012);
        let mut current = SEED.load(Ordering::Relaxed);
        loop {
            let next = current.wrapping_mul(181783497276652981);
            match SEED
                .compare_exchange_weak(
                    current,
                    next,
                    Ordering::Relaxed,
                    Ordering::Relaxed,
                )
            {
                Ok(_) => {
                    return match SystemTime::now().duration_since(UNIX_EPOCH) {
                        Ok(d) => next ^ (d.as_nanos() as i64),
                        Err(_) => next,
                    };
                }
                Err(old) => current = old,
            }
        }
    }
    /// A pseudo-random number generator ported from the Java standard *RNG* with additional
    /// utility methods better suited for rust.
    pub struct JavaRandom {
        seed: Wrapping<i64>,
        next_gaussian: Option<f64>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for JavaRandom {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "JavaRandom",
                "seed",
                &self.seed,
                "next_gaussian",
                &&self.next_gaussian,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for JavaRandom {
        #[inline]
        fn clone(&self) -> JavaRandom {
            JavaRandom {
                seed: ::core::clone::Clone::clone(&self.seed),
                next_gaussian: ::core::clone::Clone::clone(&self.next_gaussian),
            }
        }
    }
    impl Default for JavaRandom {
        fn default() -> Self {
            Self::new_seeded()
        }
    }
    impl JavaRandom {
        #[inline]
        pub fn new(seed: i64) -> JavaRandom {
            JavaRandom {
                seed: initial_scramble(seed),
                next_gaussian: None,
            }
        }
        #[inline]
        pub fn new_seeded() -> JavaRandom {
            Self::new(gen_seed())
        }
        #[inline]
        pub fn new_blank() -> JavaRandom {
            JavaRandom {
                seed: Wrapping(0),
                next_gaussian: None,
            }
        }
        #[inline]
        pub fn set_seed(&mut self, seed: i64) {
            self.seed = initial_scramble(seed);
        }
        #[inline]
        pub fn get_seed(&self) -> i64 {
            self.seed.0
        }
        pub fn next_blank(&mut self) {
            self.seed = (self.seed * MULTIPLIER + ADDEND) & MASK;
        }
        #[inline]
        fn next(&mut self, bits: u8) -> i32 {
            self.next_blank();
            (self.seed.0 as u64 >> (48 - bits)) as i32
        }
        #[inline]
        pub fn next_int(&mut self) -> i32 {
            self.next(32)
        }
        pub fn next_int_bounded(&mut self, bound: i32) -> i32 {
            if true {
                if !(bound >= 0) {
                    {
                        ::core::panicking::panic_fmt(format_args!("bound is negative"));
                    }
                }
            }
            if (bound & -bound) == bound {
                (((bound as i64).wrapping_mul(self.next(31) as i64)) >> 31) as i32
            } else {
                let mut bits;
                let mut val;
                loop {
                    bits = self.next(31);
                    val = bits.rem_euclid(bound);
                    if bits.wrapping_sub(val).wrapping_add(bound - 1) >= 0 {
                        break;
                    }
                }
                val
            }
        }
        pub fn next_long(&mut self) -> i64 {
            ((self.next(32) as i64) << 32).wrapping_add(self.next(32) as i64)
        }
        /// Get the next pseudo-random single-precision float.
        pub fn next_float(&mut self) -> f32 {
            self.next(24) as f32 / FLOAT_DIV
        }
        /// Get the next pseudo-random double-precision float.
        pub fn next_double(&mut self) -> f64 {
            let high = (self.next(26) as i64) << 27;
            let low = self.next(27) as i64;
            (high.wrapping_add(low) as f64) / DOUBLE_DIV
        }
        /// Get the next pseudo-random double-precision Gaussian random number.
        pub fn next_gaussian(&mut self) -> f64 {
            if let Some(next_gaussian) = self.next_gaussian.take() {
                next_gaussian
            } else {
                loop {
                    let v1 = self.next_double() * 2.0 - 1.0;
                    let v2 = self.next_double() * 2.0 - 1.0;
                    let s = v1 * v1 + v2 * v2;
                    if s < 1.0 && s != 0.0 {
                        let multiplier = (-2.0 * s.ln() / s).sqrt();
                        self.next_gaussian = Some(v2 * multiplier);
                        break v1 * multiplier;
                    }
                }
            }
        }
        /// Get the next pseudo-random single-precision float vector, x, y and z.
        /// **This is not part of the standard Java class.**
        pub fn next_float_vec(&mut self) -> Vec3 {
            Vec3 {
                x: self.next_float(),
                y: self.next_float(),
                z: self.next_float(),
            }
        }
        /// Get the next pseudo-random double-precision float vector, x, y and z.
        /// **This is not part of the standard Java class.**
        pub fn next_double_vec(&mut self) -> DVec3 {
            DVec3 {
                x: self.next_double(),
                y: self.next_double(),
                z: self.next_double(),
            }
        }
        /// Get the next pseudo-random double-precision double vector, x, y and z,
        /// with Gaussian distribution.
        /// **This is not part of the standard Java class.**
        pub fn next_gaussian_vec(&mut self) -> DVec3 {
            DVec3 {
                x: self.next_gaussian(),
                y: self.next_gaussian(),
                z: self.next_gaussian(),
            }
        }
        /// Randomly pick an item in the given slice.
        /// **This is not part of the standard Java class.**
        #[inline]
        pub fn next_choice<T: Copy>(&mut self, items: &[T]) -> T {
            items[self.next_int_bounded(items.len() as i32) as usize]
        }
        /// Randomly pick an item in the given slice and return mutable reference to it.
        /// **This is not part of the standard Java class.**
        #[inline]
        pub fn next_choice_ref<'a, T>(&mut self, items: &'a [T]) -> &'a T {
            &items[self.next_int_bounded(items.len() as i32) as usize]
        }
        /// Randomly pick an item in the given slice and return mutable reference to it.
        /// **This is not part of the standard Java class.**
        #[inline]
        pub fn next_choice_mut<'a, T>(&mut self, items: &'a mut [T]) -> &'a mut T {
            &mut items[self.next_int_bounded(items.len() as i32) as usize]
        }
    }
}
pub mod block {
    //! Block enumeration and functions to query their metadata state.
    use crate::item::Item;
    pub mod material {
        //! This module provides various functions for getting the material properties of blocks.
        use crate::block;
        /// Get material of a block.
        pub fn get_material(block: u8) -> Material {
            match block {
                block::STONE
                | block::COBBLESTONE
                | block::BEDROCK
                | block::GOLD_ORE
                | block::IRON_ORE
                | block::COAL_ORE
                | block::LAPIS_ORE
                | block::LAPIS_BLOCK
                | block::DISPENSER
                | block::SANDSTONE
                | block::DOUBLE_SLAB
                | block::SLAB
                | block::BRICK
                | block::MOSSY_COBBLESTONE
                | block::OBSIDIAN
                | block::SPAWNER
                | block::DIAMOND_ORE
                | block::FURNACE
                | block::FURNACE_LIT
                | block::COBBLESTONE_STAIR
                | block::STONE_PRESSURE_PLATE
                | block::REDSTONE_ORE
                | block::REDSTONE_ORE_LIT
                | block::NETHERRACK
                | block::GLOWSTONE => Material::Rock,
                block::GRASS => Material::Grass,
                block::DIRT | block::FARMLAND => Material::Ground,
                block::WOOD
                | block::LOG
                | block::NOTE_BLOCK
                | block::BOOKSHELF
                | block::WOOD_STAIR
                | block::CHEST
                | block::CRAFTING_TABLE
                | block::SIGN
                | block::WOOD_DOOR
                | block::WALL_SIGN
                | block::WOOD_PRESSURE_PLATE
                | block::JUKEBOX
                | block::FENCE
                | block::LOCKED_CHEST
                | block::TRAPDOOR => Material::Wood,
                block::SAPLING
                | block::TALL_GRASS
                | block::DEAD_BUSH
                | block::DANDELION
                | block::POPPY
                | block::BROWN_MUSHROOM
                | block::RED_MUSHROOM
                | block::WHEAT
                | block::SUGAR_CANES => Material::Plant,
                block::WATER_MOVING | block::WATER_STILL => Material::Water,
                block::LAVA_MOVING | block::LAVA_STILL => Material::Lava,
                block::SAND | block::GRAVEL | block::SOULSAND => Material::Sand,
                block::LEAVES => Material::Leaves,
                block::SPONGE => Material::Sponge,
                block::GLASS => Material::Glass,
                block::BED | block::WOOL => Material::Cloth,
                block::POWERED_RAIL
                | block::DETECTOR_RAIL
                | block::TORCH
                | block::REDSTONE
                | block::LADDER
                | block::RAIL
                | block::LEVER
                | block::REDSTONE_TORCH
                | block::REDSTONE_TORCH_LIT
                | block::BUTTON
                | block::REPEATER
                | block::REPEATER_LIT => Material::Circuit,
                block::STICKY_PISTON
                | block::PISTON
                | block::PISTON_EXT
                | block::PISTON_MOVING => Material::Piston,
                block::COBWEB => Material::Cobweb,
                block::GOLD_BLOCK
                | block::IRON_BLOCK
                | block::DIAMOND_BLOCK
                | block::IRON_DOOR => Material::Iron,
                block::TNT => Material::Tnt,
                block::FIRE => Material::Fire,
                block::SNOW => Material::Snow,
                block::ICE => Material::Ice,
                block::SNOW_BLOCK => Material::SnowBlock,
                block::CACTUS => Material::Cactus,
                block::CLAY => Material::Clay,
                block::PUMPKIN | block::PUMPKIN_LIT => Material::Pumpkin,
                block::PORTAL => Material::Portal,
                block::CAKE => Material::Cake,
                _ => Material::Air,
            }
        }
        /// Return true if a block is a full cube.
        pub fn is_cube(block: u8) -> bool {
            match block {
                block::AIR
                | block::BED
                | block::PORTAL
                | block::BUTTON
                | block::CACTUS
                | block::CAKE
                | block::WOOD_DOOR
                | block::IRON_DOOR
                | block::FARMLAND
                | block::FENCE
                | block::FIRE
                | block::WHEAT
                | block::DEAD_BUSH
                | block::RED_MUSHROOM
                | block::BROWN_MUSHROOM
                | block::DANDELION
                | block::POPPY
                | block::SAPLING
                | block::TALL_GRASS
                | block::WATER_MOVING
                | block::WATER_STILL
                | block::LAVA_MOVING
                | block::LAVA_STILL
                | block::LADDER
                | block::LEVER
                | block::PISTON
                | block::PISTON_EXT
                | block::PISTON_MOVING
                | block::WOOD_PRESSURE_PLATE
                | block::STONE_PRESSURE_PLATE
                | block::RAIL
                | block::POWERED_RAIL
                | block::DETECTOR_RAIL
                | block::REPEATER
                | block::REPEATER_LIT
                | block::REDSTONE
                | block::SUGAR_CANES
                | block::SIGN
                | block::WALL_SIGN
                | block::SNOW
                | block::WOOD_STAIR
                | block::COBBLESTONE_STAIR
                | block::SLAB
                | block::TORCH
                | block::REDSTONE_TORCH
                | block::REDSTONE_TORCH_LIT
                | block::TRAPDOOR
                | block::COBWEB => false,
                _ => true,
            }
        }
        /// Return true if a block is a full opaque cube.
        pub fn is_opaque_cube(block: u8) -> bool {
            if is_cube(block) {
                match block {
                    block::LEAVES | block::GLASS | block::ICE => false,
                    _ => true,
                }
            } else {
                false
            }
        }
        /// Return true if the given block is a fluid.
        pub fn is_fluid(block: u8) -> bool {
            match block {
                block::WATER_MOVING
                | block::WATER_STILL
                | block::LAVA_MOVING
                | block::LAVA_STILL => true,
                _ => false,
            }
        }
        /// Return true if the given block can block fluid.
        pub fn is_fluid_proof(block: u8) -> bool {
            match block {
                block::AIR => false,
                block::WOOD_DOOR
                | block::IRON_DOOR
                | block::SIGN
                | block::LADDER
                | block::SUGAR_CANES => true,
                _ => get_material(block).is_solid(),
            }
        }
        /// Get the light opacity of a block given its id.
        pub fn get_light_opacity(id: u8) -> u8 {
            match id {
                block::AIR => 0,
                block::LEAVES | block::COBWEB => 1,
                block::WATER_MOVING | block::WATER_STILL | block::ICE => 3,
                _ => if is_opaque_cube(id) { 255 } else { 0 }
            }
        }
        /// Get the light emission of a block given its id. The resulting value is between
        /// 0 and 15 included, so it's basically a 4-bit unsigned integer.
        pub fn get_light_emission(id: u8) -> u8 {
            match id {
                block::BROWN_MUSHROOM => 1,
                block::REDSTONE_TORCH_LIT => 7,
                block::REDSTONE_ORE_LIT | block::REPEATER_LIT => 9,
                block::PORTAL => 11,
                block::FURNACE_LIT => 13,
                block::TORCH => 14,
                block::LAVA_MOVING
                | block::LAVA_STILL
                | block::FIRE
                | block::GLOWSTONE
                | block::PUMPKIN_LIT => 15,
                _ => 0,
            }
        }
        /// The block slipperiness for entities.
        pub fn get_slipperiness(id: u8) -> f32 {
            match id {
                block::ICE => 0.95,
                _ => 0.6,
            }
        }
        /// Get the break hardness of a block, the block hardness is a value that defines the
        /// time a player need to hit a block before breaking. When the player's tool is able
        /// to break the block, the hardness is multiplied by 30 ticks (1.5 seconds), but 100
        /// (5.0 seconds) when not able. Some blocks cannot be broken: +inf is returned.
        pub fn get_break_hardness(id: u8) -> f32 {
            match id {
                block::LEAVES | block::BED | block::SNOW_BLOCK => 0.2,
                block::GLASS | block::GLOWSTONE => 0.3,
                block::LADDER | block::CACTUS | block::NETHERRACK => 0.4,
                block::DIRT
                | block::SAND
                | block::STICKY_PISTON
                | block::PISTON
                | block::PISTON_EXT
                | block::LEVER
                | block::STONE_PRESSURE_PLATE
                | block::WOOD_PRESSURE_PLATE
                | block::BUTTON
                | block::ICE
                | block::SOULSAND
                | block::CAKE => 0.5,
                block::GRASS
                | block::GRAVEL
                | block::SPONGE
                | block::FARMLAND
                | block::CLAY => 0.6,
                block::POWERED_RAIL | block::DETECTOR_RAIL | block::RAIL => 0.7,
                block::SANDSTONE | block::NOTE_BLOCK | block::WOOL => 0.8,
                block::STONE | block::BOOKSHELF => 1.5,
                block::COBBLESTONE
                | block::WOOD
                | block::LOG
                | block::DOUBLE_SLAB
                | block::SLAB
                | block::BRICK
                | block::MOSSY_COBBLESTONE
                | block::WOOD_STAIR
                | block::COBBLESTONE_STAIR
                | block::JUKEBOX
                | block::FENCE => 2.0,
                block::CRAFTING_TABLE | block::CHEST => 2.5,
                block::GOLD_ORE
                | block::IRON_ORE
                | block::COAL_ORE
                | block::LAPIS_ORE
                | block::LAPIS_BLOCK
                | block::GOLD_BLOCK
                | block::DIAMOND_ORE
                | block::WOOD_DOOR
                | block::REDSTONE_ORE
                | block::REDSTONE_ORE_LIT
                | block::TRAPDOOR => 3.0,
                block::DISPENSER | block::FURNACE | block::FURNACE_LIT => 3.5,
                block::COBWEB => 4.0,
                block::IRON_BLOCK
                | block::DIAMOND_BLOCK
                | block::IRON_DOOR
                | block::SPAWNER => 5.0,
                block::OBSIDIAN => 10.0,
                block::BEDROCK
                | block::PISTON_MOVING
                | block::PORTAL
                | block::WATER_MOVING
                | block::WATER_STILL
                | block::LAVA_MOVING
                | block::LAVA_STILL => f32::INFINITY,
                _ => 0.0,
            }
        }
        /// The block resistance to explosions. When an explosion happens, each ray of the
        /// explosion starts with an intensity that equals the radius of the explosion multiplied
        /// by a uniform amount between 0.7 and 1.4... The resistance is the amount subtracted
        /// on each step of the ray.
        pub fn get_explosion_resistance(id: u8) -> f32 {
            match id {
                block::AIR => 0.0,
                block::WOOD
                | block::GOLD_ORE
                | block::IRON_ORE
                | block::COAL_ORE
                | block::LAPIS_ORE
                | block::LAPIS_BLOCK
                | block::WOOD_STAIR
                | block::DIAMOND_ORE
                | block::IRON_DOOR
                | block::REDSTONE_ORE
                | block::REDSTONE_ORE_LIT => 15.0 / 5.0,
                block::STONE
                | block::COBBLESTONE
                | block::GOLD_BLOCK
                | block::IRON_BLOCK
                | block::DOUBLE_SLAB
                | block::SLAB
                | block::BRICK
                | block::MOSSY_COBBLESTONE
                | block::DIAMOND_BLOCK
                | block::COBBLESTONE_STAIR
                | block::JUKEBOX => 30.0 / 5.0,
                block::OBSIDIAN => 6000.0 / 5.0,
                block::BEDROCK => 18000000.0 / 5.0,
                _ => get_break_hardness(id),
            }
        }
        pub fn get_fire_flammability(id: u8) -> u16 {
            match id {
                block::WOOD | block::FENCE | block::WOOD_STAIR | block::LOG => 5,
                block::TNT => 15,
                block::LEAVES | block::BOOKSHELF | block::WOOL => 30,
                block::TALL_GRASS => 60,
                _ => 0,
            }
        }
        /// Get the burn rate for the given block. The returned rate is used to randomly destroy
        /// a block that was on fire and replace it with fire. Blocks that are horizontal to the
        /// fire have n/300 chance of being destroyed and vertical blocks have n/250 every 40
        /// game ticks.
        pub fn get_fire_burn(id: u8) -> u16 {
            match id {
                block::WOOD | block::FENCE | block::WOOD_STAIR | block::BOOKSHELF => 20,
                block::LEAVES | block::WOOL => 60,
                block::TNT | block::TALL_GRASS => 100,
                _ => 0,
            }
        }
        /// Common block properties of blocks.
        pub enum Material {
            #[default]
            Air,
            Grass,
            Ground,
            Wood,
            Rock,
            Iron,
            Water,
            Lava,
            Leaves,
            Plant,
            Sponge,
            Cloth,
            Fire,
            Sand,
            Circuit,
            Glass,
            Tnt,
            Wug,
            Ice,
            Snow,
            SnowBlock,
            Cactus,
            Clay,
            Pumpkin,
            Portal,
            Cake,
            Cobweb,
            Piston,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Material {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        Material::Air => "Air",
                        Material::Grass => "Grass",
                        Material::Ground => "Ground",
                        Material::Wood => "Wood",
                        Material::Rock => "Rock",
                        Material::Iron => "Iron",
                        Material::Water => "Water",
                        Material::Lava => "Lava",
                        Material::Leaves => "Leaves",
                        Material::Plant => "Plant",
                        Material::Sponge => "Sponge",
                        Material::Cloth => "Cloth",
                        Material::Fire => "Fire",
                        Material::Sand => "Sand",
                        Material::Circuit => "Circuit",
                        Material::Glass => "Glass",
                        Material::Tnt => "Tnt",
                        Material::Wug => "Wug",
                        Material::Ice => "Ice",
                        Material::Snow => "Snow",
                        Material::SnowBlock => "SnowBlock",
                        Material::Cactus => "Cactus",
                        Material::Clay => "Clay",
                        Material::Pumpkin => "Pumpkin",
                        Material::Portal => "Portal",
                        Material::Cake => "Cake",
                        Material::Cobweb => "Cobweb",
                        Material::Piston => "Piston",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Material {
            #[inline]
            fn clone(&self) -> Material {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Material {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Material {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Material {
            #[inline]
            fn eq(&self, other: &Material) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for Material {}
        #[automatically_derived]
        impl ::core::cmp::Eq for Material {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Material {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state)
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Material {
            #[inline]
            fn default() -> Material {
                Self::Air
            }
        }
        impl Material {
            pub fn is_solid(self) -> bool {
                !match self {
                    Self::Air
                    | Self::Water
                    | Self::Lava
                    | Self::Plant
                    | Self::Snow
                    | Self::Circuit
                    | Self::Portal
                    | Self::Fire => true,
                    _ => false,
                }
            }
            pub fn is_fluid(self) -> bool {
                match self {
                    Self::Water | Self::Lava => true,
                    _ => false,
                }
            }
            pub fn is_translucent(self) -> bool {
                match self {
                    Self::Leaves
                    | Self::Glass
                    | Self::Tnt
                    | Self::Ice
                    | Self::Snow
                    | Self::Cactus => true,
                    _ => false,
                }
            }
            pub fn is_opaque(self) -> bool {
                !self.is_translucent() && self.is_solid()
            }
            pub fn is_replaceable(self) -> bool {
                match self {
                    Self::Air | Self::Water | Self::Lava | Self::Snow | Self::Fire => {
                        true
                    }
                    _ => false,
                }
            }
            pub fn is_breakable_by_default(self) -> bool {
                !match self {
                    Self::Rock
                    | Self::Iron
                    | Self::Snow
                    | Self::SnowBlock
                    | Self::Cobweb => true,
                    _ => false,
                }
            }
        }
    }
    pub mod dispenser {
        //! Common metadata functions.
        use crate::geom::Face;
        /// Get facing of the dispenser.
        pub fn get_face(metadata: u8) -> Option<Face> {
            Some(
                match metadata {
                    2 => Face::NegZ,
                    3 => Face::PosZ,
                    4 => Face::NegX,
                    5 => Face::PosX,
                    _ => return None,
                },
            )
        }
        /// Set facing of the dispenser.
        pub fn set_face(metadata: &mut u8, face: Face) {
            *metadata = match face {
                Face::NegY => 0,
                Face::PosY => 1,
                Face::NegZ => 2,
                Face::PosZ => 3,
                Face::NegX => 4,
                Face::PosX => 5,
            };
        }
    }
    pub mod trapdoor {
        //! LAdder special functions for metadata.
        use crate::geom::Face;
        /// The the face the button is connected to. In b1.7.3, buttons can only attach to X/Z
        /// faces, not neg/pos Y.
        #[inline]
        pub fn get_face(metadata: u8) -> Face {
            match metadata & 3 {
                0 => Face::PosZ,
                1 => Face::NegZ,
                2 => Face::PosX,
                3 => Face::NegX,
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
        #[inline]
        pub fn set_face(metadata: &mut u8, face: Face) {
            *metadata &= !3;
            *metadata
                |= match face {
                    Face::PosZ => 0,
                    Face::NegZ => 1,
                    Face::PosX => 2,
                    Face::NegX => 3,
                    _ => 0,
                };
        }
        /// Return true if the trapdoor is currently open.
        #[inline]
        pub fn is_open(metadata: u8) -> bool {
            metadata & 4 != 0
        }
        /// Set the trapdoor open or not.
        #[inline]
        pub fn set_open(metadata: &mut u8, active: bool) {
            *metadata &= !4;
            *metadata |= (active as u8) << 2;
        }
    }
    pub mod repeater {
        //! Redstone repeater metadata functions.
        use crate::geom::Face;
        /// Get the face where the repeater send power.
        #[inline]
        pub fn get_face(metadata: u8) -> Face {
            match metadata & 3 {
                0 => Face::NegZ,
                1 => Face::PosX,
                2 => Face::PosZ,
                3 => Face::NegX,
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
        /// Set the face where the repeater send power.
        #[inline]
        pub fn set_face(metadata: &mut u8, face: Face) {
            *metadata &= !3;
            *metadata
                |= match face {
                    Face::NegZ => 0,
                    Face::PosX => 1,
                    Face::PosZ => 2,
                    Face::NegX => 3,
                    _ => 0,
                };
        }
        /// Get the delay of the repeater.
        #[inline]
        pub fn get_delay(metadata: u8) -> u8 {
            (metadata & 0b1100) >> 2
        }
        /// Set the delay of the repeater.
        #[inline]
        pub fn set_delay(metadata: &mut u8, delay: u8) {
            *metadata &= !0b1100;
            *metadata |= (delay & 0b11) << 2;
        }
        /// Get the delay of the repeater in ticks.
        #[inline]
        pub fn get_delay_ticks(metadata: u8) -> u64 {
            (get_delay(metadata) as u64 + 1) * 2
        }
    }
    pub mod pumpkin {
        //! Pumpkin block metadata functions.
        use crate::geom::Face;
        /// Get the face where the pumpkin is carved.
        #[inline]
        pub fn get_face(metadata: u8) -> Face {
            match metadata & 3 {
                0 => Face::PosZ,
                1 => Face::NegX,
                2 => Face::NegZ,
                3 => Face::PosX,
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
        /// Set the face where the pumpkin is carved.
        #[inline]
        pub fn set_face(metadata: &mut u8, face: Face) {
            *metadata &= !3;
            *metadata
                |= match face {
                    Face::PosZ => 0,
                    Face::NegX => 1,
                    Face::NegZ => 2,
                    Face::PosX => 3,
                    _ => 0,
                };
        }
    }
    pub mod sapling {
        //! Sapling block metadata functions.
        /// Kind of tree for sapling, logs and leaves.
        pub enum TreeKind {
            Oak,
            Birch,
            Spruce,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TreeKind {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        TreeKind::Oak => "Oak",
                        TreeKind::Birch => "Birch",
                        TreeKind::Spruce => "Spruce",
                    },
                )
            }
        }
        /// Get the kind of tree for this sapling.
        #[inline]
        pub fn get_kind(metadata: u8) -> TreeKind {
            match metadata & 3 {
                0 | 3 => TreeKind::Oak,
                1 => TreeKind::Spruce,
                2 => TreeKind::Birch,
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
        /// Set the face where the pumpkin is carved.
        #[inline]
        pub fn set_kind(metadata: &mut u8, kind: TreeKind) {
            *metadata &= !3;
            *metadata
                |= match kind {
                    TreeKind::Oak | TreeKind::Spruce => 1,
                    TreeKind::Birch => 2,
                };
        }
        /// Return true if the sapling is growing and will grow on the next random tick.
        #[inline]
        pub fn is_growing(metadata: u8) -> bool {
            metadata & 8 != 0
        }
        /// Set if a sapling is growing.
        #[inline]
        pub fn set_growing(metadata: &mut u8, growing: bool) {
            *metadata &= !8;
            *metadata |= (growing as u8) << 3;
        }
    }
    pub mod button {
        //! Button special functions for metadata.
        use crate::geom::Face;
        /// The the face the button is connected to. In b1.7.3, buttons can only attach to X/Z
        /// faces, not neg/pos Y.
        #[inline]
        pub fn get_face(metadata: u8) -> Option<Face> {
            Some(
                match metadata & 7 {
                    1 => Face::NegX,
                    2 => Face::PosX,
                    3 => Face::NegZ,
                    4 => Face::PosZ,
                    _ => return None,
                },
            )
        }
        #[inline]
        pub fn set_face(metadata: &mut u8, face: Face) {
            *metadata &= !7;
            *metadata
                |= match face {
                    Face::NegY => 0,
                    Face::PosY => 0,
                    Face::NegZ => 3,
                    Face::PosZ => 4,
                    Face::NegX => 1,
                    Face::PosX => 2,
                };
        }
        /// Return true if the button is currently active.
        #[inline]
        pub fn is_active(metadata: u8) -> bool {
            metadata & 8 != 0
        }
        /// Set the button active or not.
        #[inline]
        pub fn set_active(metadata: &mut u8, active: bool) {
            *metadata &= !8;
            *metadata |= (active as u8) << 3;
        }
    }
    pub mod ladder {
        //! LAdder special functions for metadata.
        use crate::geom::Face;
        /// The the face the button is connected to. In b1.7.3, buttons can only attach to X/Z
        /// faces, not neg/pos Y.
        #[inline]
        pub fn get_face(metadata: u8) -> Option<Face> {
            Some(
                match metadata {
                    2 => Face::PosZ,
                    3 => Face::NegZ,
                    4 => Face::PosX,
                    5 => Face::NegX,
                    _ => return None,
                },
            )
        }
        #[inline]
        pub fn set_face(metadata: &mut u8, face: Face) {
            *metadata = match face {
                Face::PosZ => 2,
                Face::NegZ => 3,
                Face::PosX => 4,
                Face::NegX => 5,
                _ => 0,
            };
        }
    }
    pub mod piston {
        //! Piston behaviors.
        use crate::geom::Face;
        /// Get the facing of the piston base or extension.
        #[inline]
        pub fn get_face(metadata: u8) -> Option<Face> {
            Some(
                match metadata & 7 {
                    0 => Face::NegY,
                    1 => Face::PosY,
                    2 => Face::NegZ,
                    3 => Face::PosZ,
                    4 => Face::NegX,
                    5 => Face::PosX,
                    _ => return None,
                },
            )
        }
        /// Set the facing of the piston base or extension.
        #[inline]
        pub fn set_face(metadata: &mut u8, face: Face) {
            *metadata &= !7;
            *metadata |= face as u8;
        }
        /// Get if a piston base has extended or not.
        #[inline]
        pub fn is_extended(metadata: u8) -> bool {
            metadata & 8 != 0
        }
        /// Set if a piston base has extended or not.
        #[inline]
        pub fn set_extended(metadata: &mut u8, extended: bool) {
            *metadata &= !8;
            *metadata |= (extended as u8) << 3;
        }
    }
    pub mod lever {
        //! Lever special functions for metadata.
        use crate::geom::Face;
        /// The the face the lever is connected to. In b1.7.3, levers can only attach to X/Z and
        /// bottom Y. This function also returns the secondary face where this lever's stick
        /// points to when not active.
        #[inline]
        pub fn get_face(metadata: u8) -> Option<(Face, Face)> {
            Some(
                match metadata & 7 {
                    1 => (Face::NegX, Face::PosY),
                    2 => (Face::PosX, Face::PosY),
                    3 => (Face::NegZ, Face::PosY),
                    4 => (Face::PosZ, Face::PosY),
                    5 => (Face::NegY, Face::PosZ),
                    6 => (Face::NegY, Face::PosX),
                    _ => return None,
                },
            )
        }
        /// Set the face the lever is connected to and the direction of the lever's stick when
        /// not active, not that X/Z faces forces the direction to positive Y. Only positive X/Z
        /// should be used when facing bottom, other values will be forced to positive Z.
        #[inline]
        pub fn set_face(metadata: &mut u8, face: Face, dir: Face) {
            *metadata &= !7;
            *metadata
                |= match (face, dir) {
                    (Face::NegY, Face::PosZ) => 5,
                    (Face::NegY, _) => 6,
                    (Face::PosY, _) => 0,
                    (Face::NegZ, _) => 3,
                    (Face::PosZ, _) => 4,
                    (Face::NegX, _) => 1,
                    (Face::PosX, _) => 2,
                };
        }
        /// Return true if the lever is currently active.
        #[inline]
        pub fn is_active(metadata: u8) -> bool {
            metadata & 8 != 0
        }
        /// Set the lever active or not.
        #[inline]
        pub fn set_active(metadata: &mut u8, active: bool) {
            *metadata &= !8;
            *metadata |= (active as u8) << 3;
        }
    }
    pub mod stair {
        //! Stair block metadata functions.
        use crate::geom::Face;
        /// Get the face where the stair leads to.
        #[inline]
        pub fn get_face(metadata: u8) -> Face {
            match metadata & 3 {
                0 => Face::PosX,
                1 => Face::NegX,
                2 => Face::PosZ,
                3 => Face::NegZ,
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
        #[inline]
        pub fn set_face(metadata: &mut u8, face: Face) {
            *metadata &= !3;
            *metadata = match face {
                Face::PosX => 0,
                Face::NegX => 1,
                Face::PosZ => 2,
                Face::NegZ => 3,
                _ => 0,
            };
        }
    }
    pub mod torch {
        //! Torch (including redstone torch) metadata functions.
        use crate::geom::Face;
        /// Get the face this torch is attached to.
        #[inline]
        pub fn get_face(metadata: u8) -> Option<Face> {
            Some(
                match metadata {
                    1 => Face::NegX,
                    2 => Face::PosX,
                    3 => Face::NegZ,
                    4 => Face::PosZ,
                    5 => Face::NegY,
                    _ => return None,
                },
            )
        }
        #[inline]
        pub fn set_face(metadata: &mut u8, face: Face) {
            *metadata = match face {
                Face::NegX => 1,
                Face::PosX => 2,
                Face::NegZ => 3,
                Face::PosZ => 4,
                Face::NegY => 5,
                _ => 5,
            };
        }
    }
    pub mod fluid {
        //! Fluid block special functions (mostly for water).
        /// Return true if this still/moving fluid block acts like a source.
        #[inline]
        pub fn is_source(metadata: u8) -> bool {
            metadata == 0
        }
        /// Force this metadata to be a source fluid block. This basically just overwrite metadata
        /// with a 0, which means that distance is 0 and fluid is not falling.
        #[inline]
        pub fn set_source(metadata: &mut u8) {
            *metadata = 0;
        }
        /// Get the distance to source of a fluid block. The distance can go up to 7, but does
        /// not account for the falling state.
        #[inline]
        pub fn get_distance(metadata: u8) -> u8 {
            metadata & 7
        }
        #[inline]
        pub fn set_distance(metadata: &mut u8, distance: u8) {
            if true {
                if !(distance <= 7) {
                    ::core::panicking::panic("assertion failed: distance <= 7")
                }
            }
            *metadata &= !7;
            *metadata |= distance;
        }
        /// Get if this fluid block is falling and therefore should not spread on sides.
        #[inline]
        pub fn is_falling(metadata: u8) -> bool {
            metadata & 8 != 0
        }
        #[inline]
        pub fn set_falling(metadata: &mut u8, falling: bool) {
            *metadata &= !8;
            *metadata |= (falling as u8) << 3;
        }
        /// This function get the actual distance to the source of a fluid block, this account
        /// both the distance stored in the lower 3 bits, but also for the falling state: if a
        /// fluid is falling, it acts like a source block for propagation.
        #[inline]
        pub fn get_actual_distance(metadata: u8) -> u8 {
            if is_falling(metadata) { 0 } else { get_distance(metadata) }
        }
        /// Calculate the actual height of a fluid block depending on its metadata.
        #[inline]
        pub fn get_actual_height(metadata: u8) -> f32 {
            1.0 - (get_actual_distance(metadata) + 1) as f32 / 9.0
        }
    }
    pub mod door {
        //! Door block specific logic.
        use crate::geom::Face;
        /// Get the face of this door.
        #[inline]
        pub fn get_face(metadata: u8) -> Face {
            match metadata & 3 {
                0 => Face::NegX,
                1 => Face::NegZ,
                2 => Face::PosX,
                3 => Face::PosZ,
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
        #[inline]
        pub fn set_face(metadata: &mut u8, face: Face) {
            *metadata &= !3;
            *metadata
                |= match face {
                    Face::NegY => 0,
                    Face::PosY => 0,
                    Face::NegX => 0,
                    Face::PosX => 2,
                    Face::NegZ => 1,
                    Face::PosZ => 3,
                };
        }
        /// If the block is a door (iron/wood), get if it's in open state.
        #[inline]
        pub fn is_open(metadata: u8) -> bool {
            metadata & 4 != 0
        }
        #[inline]
        pub fn set_open(metadata: &mut u8, open: bool) {
            *metadata &= !4;
            *metadata |= (open as u8) << 2;
        }
        /// Return true if this door block is the upper part.
        #[inline]
        pub fn is_upper(metadata: u8) -> bool {
            metadata & 8 != 0
        }
        #[inline]
        pub fn set_upper(metadata: &mut u8, upper: bool) {
            *metadata &= !8;
            *metadata |= (upper as u8) << 3;
        }
        /// Get the actual face of this door, depending on its face and open state.
        #[inline]
        pub fn get_actual_face(metadata: u8) -> Face {
            let face = get_face(metadata);
            if is_open(metadata) { face.rotate_right() } else { face }
        }
    }
    pub mod bed {
        //! Bed special functions for metadata.
        use crate::geom::Face;
        /// Get the facing of a bed.
        #[inline]
        pub fn get_face(metadata: u8) -> Face {
            match metadata & 3 {
                0 => Face::PosZ,
                1 => Face::NegX,
                2 => Face::NegZ,
                3 => Face::PosX,
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
        /// Set the facing of a bed.
        #[inline]
        pub fn set_face(metadata: &mut u8, face: Face) {
            *metadata &= !3;
            *metadata
                |= match face {
                    Face::PosZ => 0,
                    Face::NegX => 1,
                    Face::NegZ => 2,
                    Face::PosX => 3,
                    _ => 0,
                };
        }
        /// Return true if the bed is occupied.
        #[inline]
        pub fn is_occupied(metadata: u8) -> bool {
            metadata & 4 != 0
        }
        /// Set if the bed is occupied or not.
        #[inline]
        pub fn set_occupied(metadata: &mut u8, occupied: bool) {
            *metadata &= !4;
            *metadata |= (occupied as u8) << 2;
        }
        /// Return true if the bed block is the head piece.
        #[inline]
        pub fn is_head(metadata: u8) -> bool {
            metadata & 8 != 0
        }
        /// Set if the bed block is the head piece or not.
        #[inline]
        pub fn set_head(metadata: &mut u8, head: bool) {
            *metadata &= !8;
            *metadata |= (head as u8) << 3;
        }
    }
    static NAMES: [&'static str; 256] = {
        let mut arr = [""; 256];
        arr[0 as usize] = "air";
        arr[1 as usize] = "stone";
        arr[2 as usize] = "grass";
        arr[3 as usize] = "dirt";
        arr[4 as usize] = "cobblestone";
        arr[5 as usize] = "wood";
        arr[6 as usize] = "sapling";
        arr[7 as usize] = "bedrock";
        arr[8 as usize] = "water_moving";
        arr[9 as usize] = "water_still";
        arr[10 as usize] = "lava_moving";
        arr[11 as usize] = "lava_still";
        arr[12 as usize] = "sand";
        arr[13 as usize] = "gravel";
        arr[14 as usize] = "gold_ore";
        arr[15 as usize] = "iron_ore";
        arr[16 as usize] = "coal_ore";
        arr[17 as usize] = "log";
        arr[18 as usize] = "leaves";
        arr[19 as usize] = "sponge";
        arr[20 as usize] = "glass";
        arr[21 as usize] = "lapis_ore";
        arr[22 as usize] = "lapis_block";
        arr[23 as usize] = "dispenser";
        arr[24 as usize] = "sandstone";
        arr[25 as usize] = "note_block";
        arr[26 as usize] = "bed";
        arr[27 as usize] = "powered_rail";
        arr[28 as usize] = "detector_rail";
        arr[29 as usize] = "sticky_piston";
        arr[30 as usize] = "cobweb";
        arr[31 as usize] = "tall_grass";
        arr[32 as usize] = "dead_bush";
        arr[33 as usize] = "piston";
        arr[34 as usize] = "piston_ext";
        arr[35 as usize] = "wool";
        arr[36 as usize] = "piston_moving";
        arr[37 as usize] = "dandelion";
        arr[38 as usize] = "poppy";
        arr[39 as usize] = "brown_mushroom";
        arr[40 as usize] = "red_mushroom";
        arr[41 as usize] = "gold_block";
        arr[42 as usize] = "iron_block";
        arr[43 as usize] = "double_slab";
        arr[44 as usize] = "slab";
        arr[45 as usize] = "brick";
        arr[46 as usize] = "tnt";
        arr[47 as usize] = "bookshelf";
        arr[48 as usize] = "mossy_cobblestone";
        arr[49 as usize] = "obsidian";
        arr[50 as usize] = "torch";
        arr[51 as usize] = "fire";
        arr[52 as usize] = "spawner";
        arr[53 as usize] = "wood_stair";
        arr[54 as usize] = "chest";
        arr[55 as usize] = "redstone";
        arr[56 as usize] = "diamond_ore";
        arr[57 as usize] = "diamond_block";
        arr[58 as usize] = "crafting_table";
        arr[59 as usize] = "wheat";
        arr[60 as usize] = "farmland";
        arr[61 as usize] = "furnace";
        arr[62 as usize] = "furnace_lit";
        arr[63 as usize] = "sign";
        arr[64 as usize] = "wood_door";
        arr[65 as usize] = "ladder";
        arr[66 as usize] = "rail";
        arr[67 as usize] = "cobblestone_stair";
        arr[68 as usize] = "wall_sign";
        arr[69 as usize] = "lever";
        arr[70 as usize] = "stone_pressure_plate";
        arr[71 as usize] = "iron_door";
        arr[72 as usize] = "wood_pressure_plate";
        arr[73 as usize] = "redstone_ore";
        arr[74 as usize] = "redstone_ore_lit";
        arr[75 as usize] = "redstone_torch";
        arr[76 as usize] = "redstone_torch_lit";
        arr[77 as usize] = "button";
        arr[78 as usize] = "snow";
        arr[79 as usize] = "ice";
        arr[80 as usize] = "snow_block";
        arr[81 as usize] = "cactus";
        arr[82 as usize] = "clay";
        arr[83 as usize] = "sugar_canes";
        arr[84 as usize] = "jukebox";
        arr[85 as usize] = "fence";
        arr[86 as usize] = "pumpkin";
        arr[87 as usize] = "netherrack";
        arr[88 as usize] = "soulsand";
        arr[89 as usize] = "glowstone";
        arr[90 as usize] = "portal";
        arr[91 as usize] = "pumpkin_lit";
        arr[92 as usize] = "cake";
        arr[93 as usize] = "repeater";
        arr[94 as usize] = "repeater_lit";
        arr[95 as usize] = "locked_chest";
        arr[96 as usize] = "trapdoor";
        arr
    };
    const ITEMS: [Item; 256] = {
        let mut arr = [Item {
            name: "",
            block: true,
            max_stack_size: 64,
            max_damage: 0,
        }; 256];
        arr[0 as usize].name = "air";
        arr[1 as usize].name = "stone";
        arr[2 as usize].name = "grass";
        arr[3 as usize].name = "dirt";
        arr[4 as usize].name = "cobblestone";
        arr[5 as usize].name = "wood";
        arr[6 as usize].name = "sapling";
        arr[7 as usize].name = "bedrock";
        arr[8 as usize].name = "water_moving";
        arr[9 as usize].name = "water_still";
        arr[10 as usize].name = "lava_moving";
        arr[11 as usize].name = "lava_still";
        arr[12 as usize].name = "sand";
        arr[13 as usize].name = "gravel";
        arr[14 as usize].name = "gold_ore";
        arr[15 as usize].name = "iron_ore";
        arr[16 as usize].name = "coal_ore";
        arr[17 as usize].name = "log";
        arr[18 as usize].name = "leaves";
        arr[19 as usize].name = "sponge";
        arr[20 as usize].name = "glass";
        arr[21 as usize].name = "lapis_ore";
        arr[22 as usize].name = "lapis_block";
        arr[23 as usize].name = "dispenser";
        arr[24 as usize].name = "sandstone";
        arr[25 as usize].name = "note_block";
        arr[26 as usize].name = "bed";
        arr[27 as usize].name = "powered_rail";
        arr[28 as usize].name = "detector_rail";
        arr[29 as usize].name = "sticky_piston";
        arr[30 as usize].name = "cobweb";
        arr[31 as usize].name = "tall_grass";
        arr[32 as usize].name = "dead_bush";
        arr[33 as usize].name = "piston";
        arr[34 as usize].name = "piston_ext";
        arr[35 as usize].name = "wool";
        arr[36 as usize].name = "piston_moving";
        arr[37 as usize].name = "dandelion";
        arr[38 as usize].name = "poppy";
        arr[39 as usize].name = "brown_mushroom";
        arr[40 as usize].name = "red_mushroom";
        arr[41 as usize].name = "gold_block";
        arr[42 as usize].name = "iron_block";
        arr[43 as usize].name = "double_slab";
        arr[44 as usize].name = "slab";
        arr[45 as usize].name = "brick";
        arr[46 as usize].name = "tnt";
        arr[47 as usize].name = "bookshelf";
        arr[48 as usize].name = "mossy_cobblestone";
        arr[49 as usize].name = "obsidian";
        arr[50 as usize].name = "torch";
        arr[51 as usize].name = "fire";
        arr[52 as usize].name = "spawner";
        arr[53 as usize].name = "wood_stair";
        arr[54 as usize].name = "chest";
        arr[55 as usize].name = "redstone";
        arr[56 as usize].name = "diamond_ore";
        arr[57 as usize].name = "diamond_block";
        arr[58 as usize].name = "crafting_table";
        arr[59 as usize].name = "wheat";
        arr[60 as usize].name = "farmland";
        arr[61 as usize].name = "furnace";
        arr[62 as usize].name = "furnace_lit";
        arr[63 as usize].name = "sign";
        arr[64 as usize].name = "wood_door";
        arr[65 as usize].name = "ladder";
        arr[66 as usize].name = "rail";
        arr[67 as usize].name = "cobblestone_stair";
        arr[68 as usize].name = "wall_sign";
        arr[69 as usize].name = "lever";
        arr[70 as usize].name = "stone_pressure_plate";
        arr[71 as usize].name = "iron_door";
        arr[72 as usize].name = "wood_pressure_plate";
        arr[73 as usize].name = "redstone_ore";
        arr[74 as usize].name = "redstone_ore_lit";
        arr[75 as usize].name = "redstone_torch";
        arr[76 as usize].name = "redstone_torch_lit";
        arr[77 as usize].name = "button";
        arr[78 as usize].name = "snow";
        arr[79 as usize].name = "ice";
        arr[80 as usize].name = "snow_block";
        arr[81 as usize].name = "cactus";
        arr[82 as usize].name = "clay";
        arr[83 as usize].name = "sugar_canes";
        arr[84 as usize].name = "jukebox";
        arr[85 as usize].name = "fence";
        arr[86 as usize].name = "pumpkin";
        arr[87 as usize].name = "netherrack";
        arr[88 as usize].name = "soulsand";
        arr[89 as usize].name = "glowstone";
        arr[90 as usize].name = "portal";
        arr[91 as usize].name = "pumpkin_lit";
        arr[92 as usize].name = "cake";
        arr[93 as usize].name = "repeater";
        arr[94 as usize].name = "repeater_lit";
        arr[95 as usize].name = "locked_chest";
        arr[96 as usize].name = "trapdoor";
        arr
    };
    pub const AIR: u8 = 0;
    pub const STONE: u8 = 1;
    pub const GRASS: u8 = 2;
    pub const DIRT: u8 = 3;
    pub const COBBLESTONE: u8 = 4;
    pub const WOOD: u8 = 5;
    pub const SAPLING: u8 = 6;
    pub const BEDROCK: u8 = 7;
    pub const WATER_MOVING: u8 = 8;
    pub const WATER_STILL: u8 = 9;
    pub const LAVA_MOVING: u8 = 10;
    pub const LAVA_STILL: u8 = 11;
    pub const SAND: u8 = 12;
    pub const GRAVEL: u8 = 13;
    pub const GOLD_ORE: u8 = 14;
    pub const IRON_ORE: u8 = 15;
    pub const COAL_ORE: u8 = 16;
    pub const LOG: u8 = 17;
    pub const LEAVES: u8 = 18;
    pub const SPONGE: u8 = 19;
    pub const GLASS: u8 = 20;
    pub const LAPIS_ORE: u8 = 21;
    pub const LAPIS_BLOCK: u8 = 22;
    pub const DISPENSER: u8 = 23;
    pub const SANDSTONE: u8 = 24;
    pub const NOTE_BLOCK: u8 = 25;
    pub const BED: u8 = 26;
    pub const POWERED_RAIL: u8 = 27;
    pub const DETECTOR_RAIL: u8 = 28;
    pub const STICKY_PISTON: u8 = 29;
    pub const COBWEB: u8 = 30;
    pub const TALL_GRASS: u8 = 31;
    pub const DEAD_BUSH: u8 = 32;
    pub const PISTON: u8 = 33;
    pub const PISTON_EXT: u8 = 34;
    pub const WOOL: u8 = 35;
    pub const PISTON_MOVING: u8 = 36;
    pub const DANDELION: u8 = 37;
    pub const POPPY: u8 = 38;
    pub const BROWN_MUSHROOM: u8 = 39;
    pub const RED_MUSHROOM: u8 = 40;
    pub const GOLD_BLOCK: u8 = 41;
    pub const IRON_BLOCK: u8 = 42;
    pub const DOUBLE_SLAB: u8 = 43;
    pub const SLAB: u8 = 44;
    pub const BRICK: u8 = 45;
    pub const TNT: u8 = 46;
    pub const BOOKSHELF: u8 = 47;
    pub const MOSSY_COBBLESTONE: u8 = 48;
    pub const OBSIDIAN: u8 = 49;
    pub const TORCH: u8 = 50;
    pub const FIRE: u8 = 51;
    pub const SPAWNER: u8 = 52;
    pub const WOOD_STAIR: u8 = 53;
    pub const CHEST: u8 = 54;
    pub const REDSTONE: u8 = 55;
    pub const DIAMOND_ORE: u8 = 56;
    pub const DIAMOND_BLOCK: u8 = 57;
    pub const CRAFTING_TABLE: u8 = 58;
    pub const WHEAT: u8 = 59;
    pub const FARMLAND: u8 = 60;
    pub const FURNACE: u8 = 61;
    pub const FURNACE_LIT: u8 = 62;
    pub const SIGN: u8 = 63;
    pub const WOOD_DOOR: u8 = 64;
    pub const LADDER: u8 = 65;
    pub const RAIL: u8 = 66;
    pub const COBBLESTONE_STAIR: u8 = 67;
    pub const WALL_SIGN: u8 = 68;
    pub const LEVER: u8 = 69;
    pub const STONE_PRESSURE_PLATE: u8 = 70;
    pub const IRON_DOOR: u8 = 71;
    pub const WOOD_PRESSURE_PLATE: u8 = 72;
    pub const REDSTONE_ORE: u8 = 73;
    pub const REDSTONE_ORE_LIT: u8 = 74;
    pub const REDSTONE_TORCH: u8 = 75;
    pub const REDSTONE_TORCH_LIT: u8 = 76;
    pub const BUTTON: u8 = 77;
    pub const SNOW: u8 = 78;
    pub const ICE: u8 = 79;
    pub const SNOW_BLOCK: u8 = 80;
    pub const CACTUS: u8 = 81;
    pub const CLAY: u8 = 82;
    pub const SUGAR_CANES: u8 = 83;
    pub const JUKEBOX: u8 = 84;
    pub const FENCE: u8 = 85;
    pub const PUMPKIN: u8 = 86;
    pub const NETHERRACK: u8 = 87;
    pub const SOULSAND: u8 = 88;
    pub const GLOWSTONE: u8 = 89;
    pub const PORTAL: u8 = 90;
    pub const PUMPKIN_LIT: u8 = 91;
    pub const CAKE: u8 = 92;
    pub const REPEATER: u8 = 93;
    pub const REPEATER_LIT: u8 = 94;
    pub const LOCKED_CHEST: u8 = 95;
    pub const TRAPDOOR: u8 = 96;
    /// Find a block name from its id.
    #[inline]
    pub fn name(id: u8) -> &'static str {
        NAMES[id as usize]
    }
    /// Find a block id from its name.
    pub fn from_name(name: &str) -> Option<u8> {
        NAMES.iter().position(|&n| n == name).map(|n| n as u8)
    }
    /// Find the item associated to the given block id.
    /// TODO: This should be removed in the future when items module is reworked.
    #[inline]
    pub fn item(id: u8) -> &'static Item {
        &ITEMS[id as usize]
    }
}
pub mod item {
    //! Item enumeration and behaviors.
    use crate::block;
    pub mod attack {
        //! Module to query base attack damage of items.
        use crate::item;
        /// Get base attack damage of an item.
        pub fn get_base_damage(item: u16) -> u16 {
            const DIAMOND_DAMAGE: u16 = 3;
            const IRON_DAMAGE: u16 = 2;
            const STONE_DAMAGE: u16 = 1;
            const WOOD_DAMAGE: u16 = 0;
            const GOLD_DAMAGE: u16 = 0;
            match item {
                item::DIAMOND_SWORD => 4 + DIAMOND_DAMAGE * 2,
                item::IRON_SWORD => 4 + IRON_DAMAGE * 2,
                item::STONE_SWORD => 4 + STONE_DAMAGE * 2,
                item::WOOD_SWORD => 4 + WOOD_DAMAGE * 2,
                item::GOLD_SWORD => 4 + GOLD_DAMAGE * 2,
                item::DIAMOND_AXE => 3 + DIAMOND_DAMAGE,
                item::IRON_AXE => 3 + IRON_DAMAGE,
                item::STONE_AXE => 3 + STONE_DAMAGE,
                item::WOOD_AXE => 3 + WOOD_DAMAGE,
                item::GOLD_AXE => 3 + GOLD_DAMAGE,
                item::DIAMOND_PICKAXE => 2 + DIAMOND_DAMAGE,
                item::IRON_PICKAXE => 2 + IRON_DAMAGE,
                item::STONE_PICKAXE => 2 + STONE_DAMAGE,
                item::WOOD_PICKAXE => 2 + WOOD_DAMAGE,
                item::GOLD_PICKAXE => 2 + GOLD_DAMAGE,
                item::DIAMOND_SHOVEL => 1 + DIAMOND_DAMAGE,
                item::IRON_SHOVEL => 1 + IRON_DAMAGE,
                item::STONE_SHOVEL => 1 + STONE_DAMAGE,
                item::WOOD_SHOVEL => 1 + WOOD_DAMAGE,
                item::GOLD_SHOVEL => 1 + GOLD_DAMAGE,
                _ => 1,
            }
        }
    }
    const WOOD_MAX_USES: u16 = 59;
    const STONE_MAX_USES: u16 = 131;
    const IRON_MAX_USES: u16 = 250;
    const GOLD_MAX_USES: u16 = 32;
    const DIAMOND_MAX_USES: u16 = 1561;
    static ITEMS: [Item; 2002] = {
        let mut arr = [Item::new(""); 2002];
        arr[0 as usize] = Item::new("iron_shovel").set_tool(IRON_MAX_USES);
        arr[1 as usize] = Item::new("iron_pickaxe").set_tool(IRON_MAX_USES);
        arr[2 as usize] = Item::new("iron_axe").set_tool(IRON_MAX_USES);
        arr[3 as usize] = Item::new("flint_and_steel");
        arr[4 as usize] = Item::new("apple");
        arr[5 as usize] = Item::new("bow").set_max_stack_size(1);
        arr[6 as usize] = Item::new("arrow");
        arr[7 as usize] = Item::new("coal");
        arr[8 as usize] = Item::new("diamond");
        arr[9 as usize] = Item::new("iron_ingot");
        arr[10 as usize] = Item::new("gold_ingot");
        arr[11 as usize] = Item::new("iron_sword").set_tool(IRON_MAX_USES);
        arr[12 as usize] = Item::new("wood_sword").set_tool(WOOD_MAX_USES);
        arr[13 as usize] = Item::new("wood_shovel").set_tool(WOOD_MAX_USES);
        arr[14 as usize] = Item::new("wood_pickaxe").set_tool(WOOD_MAX_USES);
        arr[15 as usize] = Item::new("wood_axe").set_tool(WOOD_MAX_USES);
        arr[16 as usize] = Item::new("stone_sword").set_tool(STONE_MAX_USES);
        arr[17 as usize] = Item::new("stone_shovel").set_tool(STONE_MAX_USES);
        arr[18 as usize] = Item::new("stone_pickaxe").set_tool(STONE_MAX_USES);
        arr[19 as usize] = Item::new("stone_axe").set_tool(STONE_MAX_USES);
        arr[20 as usize] = Item::new("diamond_sword").set_tool(DIAMOND_MAX_USES);
        arr[21 as usize] = Item::new("diamond_shovel").set_tool(DIAMOND_MAX_USES);
        arr[22 as usize] = Item::new("diamond_pickaxe").set_tool(DIAMOND_MAX_USES);
        arr[23 as usize] = Item::new("diamond_axe").set_tool(DIAMOND_MAX_USES);
        arr[24 as usize] = Item::new("stick");
        arr[25 as usize] = Item::new("bowl");
        arr[26 as usize] = Item::new("mushroom_stew").set_food();
        arr[27 as usize] = Item::new("gold_sword").set_tool(GOLD_MAX_USES);
        arr[28 as usize] = Item::new("gold_shovel").set_tool(GOLD_MAX_USES);
        arr[29 as usize] = Item::new("gold_pickaxe").set_tool(GOLD_MAX_USES);
        arr[30 as usize] = Item::new("gold_axe").set_tool(GOLD_MAX_USES);
        arr[31 as usize] = Item::new("string");
        arr[32 as usize] = Item::new("feather");
        arr[33 as usize] = Item::new("gunpowder");
        arr[34 as usize] = Item::new("wood_hoe").set_tool(WOOD_MAX_USES);
        arr[35 as usize] = Item::new("stone_hoe").set_tool(STONE_MAX_USES);
        arr[36 as usize] = Item::new("iron_hoe").set_tool(IRON_MAX_USES);
        arr[37 as usize] = Item::new("diamond_hoe").set_tool(DIAMOND_MAX_USES);
        arr[38 as usize] = Item::new("gold_hoe").set_tool(GOLD_MAX_USES);
        arr[39 as usize] = Item::new("wheat_seeds");
        arr[40 as usize] = Item::new("wheat");
        arr[41 as usize] = Item::new("bread").set_food();
        arr[42 as usize] = Item::new("leather_helmet").set_tool(11 * 3);
        arr[43 as usize] = Item::new("leather_chestplate").set_tool(16 * 3);
        arr[44 as usize] = Item::new("leather_leggings").set_tool(15 * 3);
        arr[45 as usize] = Item::new("leather_boots").set_tool(13 * 3);
        arr[46 as usize] = Item::new("chain_helmet").set_tool(11 * 6);
        arr[47 as usize] = Item::new("chain_chestplate").set_tool(16 * 6);
        arr[48 as usize] = Item::new("chain_leggings").set_tool(15 * 6);
        arr[49 as usize] = Item::new("chain_boots").set_tool(13 * 6);
        arr[50 as usize] = Item::new("iron_helmet").set_tool(11 * 12);
        arr[51 as usize] = Item::new("iron_chestplate").set_tool(16 * 12);
        arr[52 as usize] = Item::new("iron_leggings").set_tool(15 * 12);
        arr[53 as usize] = Item::new("iron_boots").set_tool(13 * 12);
        arr[54 as usize] = Item::new("diamond_helmet").set_tool(11 * 24);
        arr[55 as usize] = Item::new("diamond_chestplate").set_tool(16 * 24);
        arr[56 as usize] = Item::new("diamond_leggings").set_tool(15 * 24);
        arr[57 as usize] = Item::new("diamond_boots").set_tool(13 * 24);
        arr[58 as usize] = Item::new("gold_helmet").set_tool(11 * 6);
        arr[59 as usize] = Item::new("gold_chestplate").set_tool(16 * 6);
        arr[60 as usize] = Item::new("gold_leggings").set_tool(15 * 6);
        arr[61 as usize] = Item::new("gold_boots").set_tool(13 * 6);
        arr[62 as usize] = Item::new("flint");
        arr[63 as usize] = Item::new("raw_porkchop").set_food();
        arr[64 as usize] = Item::new("cooked_porkchop").set_food();
        arr[65 as usize] = Item::new("painting");
        arr[66 as usize] = Item::new("gold_apple").set_food();
        arr[67 as usize] = Item::new("sign").set_max_stack_size(1);
        arr[68 as usize] = Item::new("wood_door").set_max_stack_size(1);
        arr[69 as usize] = Item::new("bucket").set_max_stack_size(1);
        arr[70 as usize] = Item::new("water_bucket").set_max_stack_size(1);
        arr[71 as usize] = Item::new("lava_bucket").set_max_stack_size(1);
        arr[72 as usize] = Item::new("minecart").set_max_stack_size(1);
        arr[73 as usize] = Item::new("saddle").set_max_stack_size(1);
        arr[74 as usize] = Item::new("iron_door").set_max_stack_size(1);
        arr[75 as usize] = Item::new("redstone");
        arr[76 as usize] = Item::new("snowball").set_max_stack_size(16);
        arr[77 as usize] = Item::new("boat").set_max_stack_size(1);
        arr[78 as usize] = Item::new("leather");
        arr[79 as usize] = Item::new("milk_bucket").set_food();
        arr[80 as usize] = Item::new("brick");
        arr[81 as usize] = Item::new("clay");
        arr[82 as usize] = Item::new("sugar_canes");
        arr[83 as usize] = Item::new("paper");
        arr[84 as usize] = Item::new("book");
        arr[85 as usize] = Item::new("slimeball");
        arr[86 as usize] = Item::new("chest_minecart").set_max_stack_size(1);
        arr[87 as usize] = Item::new("furnace_minecart").set_max_stack_size(1);
        arr[88 as usize] = Item::new("egg").set_max_stack_size(16);
        arr[89 as usize] = Item::new("compass").set_max_stack_size(1);
        arr[90 as usize] = Item::new("fishing_rod").set_tool(64);
        arr[91 as usize] = Item::new("clock").set_max_stack_size(1);
        arr[92 as usize] = Item::new("glowstone_dust");
        arr[93 as usize] = Item::new("raw_fish").set_food();
        arr[94 as usize] = Item::new("cooked_fish").set_food();
        arr[95 as usize] = Item::new("dye");
        arr[96 as usize] = Item::new("bone");
        arr[97 as usize] = Item::new("sugar");
        arr[98 as usize] = Item::new("cake").set_max_stack_size(1);
        arr[99 as usize] = Item::new("bed").set_max_stack_size(1);
        arr[100 as usize] = Item::new("repeater");
        arr[101 as usize] = Item::new("cookie").set_max_stack_size(8);
        arr[102 as usize] = Item::new("map").set_max_stack_size(1);
        arr[103 as usize] = Item::new("shears").set_tool(238);
        arr[2000 as usize] = Item::new("record_13").set_max_stack_size(1);
        arr[2001 as usize] = Item::new("record_cat").set_max_stack_size(1);
        arr
    };
    pub const IRON_SHOVEL: u16 = 0 + 256;
    pub const IRON_PICKAXE: u16 = 1 + 256;
    pub const IRON_AXE: u16 = 2 + 256;
    pub const FLINT_AND_STEEL: u16 = 3 + 256;
    pub const APPLE: u16 = 4 + 256;
    pub const BOW: u16 = 5 + 256;
    pub const ARROW: u16 = 6 + 256;
    pub const COAL: u16 = 7 + 256;
    pub const DIAMOND: u16 = 8 + 256;
    pub const IRON_INGOT: u16 = 9 + 256;
    pub const GOLD_INGOT: u16 = 10 + 256;
    pub const IRON_SWORD: u16 = 11 + 256;
    pub const WOOD_SWORD: u16 = 12 + 256;
    pub const WOOD_SHOVEL: u16 = 13 + 256;
    pub const WOOD_PICKAXE: u16 = 14 + 256;
    pub const WOOD_AXE: u16 = 15 + 256;
    pub const STONE_SWORD: u16 = 16 + 256;
    pub const STONE_SHOVEL: u16 = 17 + 256;
    pub const STONE_PICKAXE: u16 = 18 + 256;
    pub const STONE_AXE: u16 = 19 + 256;
    pub const DIAMOND_SWORD: u16 = 20 + 256;
    pub const DIAMOND_SHOVEL: u16 = 21 + 256;
    pub const DIAMOND_PICKAXE: u16 = 22 + 256;
    pub const DIAMOND_AXE: u16 = 23 + 256;
    pub const STICK: u16 = 24 + 256;
    pub const BOWL: u16 = 25 + 256;
    pub const MUSHROOM_STEW: u16 = 26 + 256;
    pub const GOLD_SWORD: u16 = 27 + 256;
    pub const GOLD_SHOVEL: u16 = 28 + 256;
    pub const GOLD_PICKAXE: u16 = 29 + 256;
    pub const GOLD_AXE: u16 = 30 + 256;
    pub const STRING: u16 = 31 + 256;
    pub const FEATHER: u16 = 32 + 256;
    pub const GUNPOWDER: u16 = 33 + 256;
    pub const WOOD_HOE: u16 = 34 + 256;
    pub const STONE_HOE: u16 = 35 + 256;
    pub const IRON_HOE: u16 = 36 + 256;
    pub const DIAMOND_HOE: u16 = 37 + 256;
    pub const GOLD_HOE: u16 = 38 + 256;
    pub const WHEAT_SEEDS: u16 = 39 + 256;
    pub const WHEAT: u16 = 40 + 256;
    pub const BREAD: u16 = 41 + 256;
    pub const LEATHER_HELMET: u16 = 42 + 256;
    pub const LEATHER_CHESTPLATE: u16 = 43 + 256;
    pub const LEATHER_LEGGINGS: u16 = 44 + 256;
    pub const LEATHER_BOOTS: u16 = 45 + 256;
    pub const CHAIN_HELMET: u16 = 46 + 256;
    pub const CHAIN_CHESTPLATE: u16 = 47 + 256;
    pub const CHAIN_LEGGINGS: u16 = 48 + 256;
    pub const CHAIN_BOOTS: u16 = 49 + 256;
    pub const IRON_HELMET: u16 = 50 + 256;
    pub const IRON_CHESTPLATE: u16 = 51 + 256;
    pub const IRON_LEGGINGS: u16 = 52 + 256;
    pub const IRON_BOOTS: u16 = 53 + 256;
    pub const DIAMOND_HELMET: u16 = 54 + 256;
    pub const DIAMOND_CHESTPLATE: u16 = 55 + 256;
    pub const DIAMOND_LEGGINGS: u16 = 56 + 256;
    pub const DIAMOND_BOOTS: u16 = 57 + 256;
    pub const GOLD_HELMET: u16 = 58 + 256;
    pub const GOLD_CHESTPLATE: u16 = 59 + 256;
    pub const GOLD_LEGGINGS: u16 = 60 + 256;
    pub const GOLD_BOOTS: u16 = 61 + 256;
    pub const FLINT: u16 = 62 + 256;
    pub const RAW_PORKCHOP: u16 = 63 + 256;
    pub const COOKED_PORKCHOP: u16 = 64 + 256;
    pub const PAINTING: u16 = 65 + 256;
    pub const GOLD_APPLE: u16 = 66 + 256;
    pub const SIGN: u16 = 67 + 256;
    pub const WOOD_DOOR: u16 = 68 + 256;
    pub const BUCKET: u16 = 69 + 256;
    pub const WATER_BUCKET: u16 = 70 + 256;
    pub const LAVA_BUCKET: u16 = 71 + 256;
    pub const MINECART: u16 = 72 + 256;
    pub const SADDLE: u16 = 73 + 256;
    pub const IRON_DOOR: u16 = 74 + 256;
    pub const REDSTONE: u16 = 75 + 256;
    pub const SNOWBALL: u16 = 76 + 256;
    pub const BOAT: u16 = 77 + 256;
    pub const LEATHER: u16 = 78 + 256;
    pub const MILK_BUCKET: u16 = 79 + 256;
    pub const BRICK: u16 = 80 + 256;
    pub const CLAY: u16 = 81 + 256;
    pub const SUGAR_CANES: u16 = 82 + 256;
    pub const PAPER: u16 = 83 + 256;
    pub const BOOK: u16 = 84 + 256;
    pub const SLIMEBALL: u16 = 85 + 256;
    pub const CHEST_MINECART: u16 = 86 + 256;
    pub const FURNACE_MINECART: u16 = 87 + 256;
    pub const EGG: u16 = 88 + 256;
    pub const COMPASS: u16 = 89 + 256;
    pub const FISHING_ROD: u16 = 90 + 256;
    pub const CLOCK: u16 = 91 + 256;
    pub const GLOWSTONE_DUST: u16 = 92 + 256;
    pub const RAW_FISH: u16 = 93 + 256;
    pub const COOKED_FISH: u16 = 94 + 256;
    pub const DYE: u16 = 95 + 256;
    pub const BONE: u16 = 96 + 256;
    pub const SUGAR: u16 = 97 + 256;
    pub const CAKE: u16 = 98 + 256;
    pub const BED: u16 = 99 + 256;
    pub const REPEATER: u16 = 100 + 256;
    pub const COOKIE: u16 = 101 + 256;
    pub const MAP: u16 = 102 + 256;
    pub const SHEARS: u16 = 103 + 256;
    pub const RECORD_13: u16 = 2000 + 256;
    pub const RECORD_CAT: u16 = 2001 + 256;
    /// Get an item from its numeric id.
    pub fn from_id(id: u16) -> &'static Item {
        if id < 256 { block::item(id as u8) } else { &ITEMS[(id - 256) as usize] }
    }
    /// Find an item id from its name. **Note that this will not find block items.
    pub fn from_name(name: &str) -> Option<u16> {
        ITEMS
            .iter()
            .enumerate()
            .find(|(_, item)| item.name == name)
            .map(|(i, _)| (i + 256) as u16)
    }
    /// This structure describe a block.
    pub struct Item {
        /// The name of the item, used for debug purpose.
        pub name: &'static str,
        /// Set to true if this item is derived from a block.
        pub block: bool,
        /// Maximum stack size for this item.
        pub max_stack_size: u16,
        /// Maximum possible damage for this item.
        pub max_damage: u16,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Item {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Item",
                "name",
                &self.name,
                "block",
                &self.block,
                "max_stack_size",
                &self.max_stack_size,
                "max_damage",
                &&self.max_damage,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Item {
        #[inline]
        fn clone(&self) -> Item {
            let _: ::core::clone::AssertParamIsClone<&'static str>;
            let _: ::core::clone::AssertParamIsClone<bool>;
            let _: ::core::clone::AssertParamIsClone<u16>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Item {}
    impl Item {
        pub const fn new(name: &'static str) -> Self {
            Self {
                name,
                block: false,
                max_stack_size: 64,
                max_damage: 0,
            }
        }
        const fn set_tool(self, max_damage: u16) -> Self {
            self.set_max_stack_size(1).set_max_damage(max_damage)
        }
        const fn set_food(self) -> Self {
            self.set_max_stack_size(1)
        }
        const fn set_max_stack_size(mut self, max_stack_size: u16) -> Self {
            self.max_stack_size = max_stack_size;
            self
        }
        const fn set_max_damage(mut self, max_damage: u16) -> Self {
            self.max_damage = max_damage;
            self
        }
    }
    /// An item stack defines the actual number of items and their damage value.
    pub struct ItemStack {
        /// The item id.
        pub id: u16,
        /// The stack size.
        pub size: u16,
        /// The damage value of the stack.
        pub damage: u16,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ItemStack {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ItemStack",
                "id",
                &self.id,
                "size",
                &self.size,
                "damage",
                &&self.damage,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ItemStack {
        #[inline]
        fn clone(&self) -> ItemStack {
            let _: ::core::clone::AssertParamIsClone<u16>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ItemStack {}
    #[automatically_derived]
    impl ::core::default::Default for ItemStack {
        #[inline]
        fn default() -> ItemStack {
            ItemStack {
                id: ::core::default::Default::default(),
                size: ::core::default::Default::default(),
                damage: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ItemStack {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ItemStack {
        #[inline]
        fn eq(&self, other: &ItemStack) -> bool {
            self.id == other.id && self.size == other.size && self.damage == other.damage
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ItemStack {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ItemStack {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u16>;
        }
    }
    impl ItemStack {
        pub const EMPTY: Self = Self {
            id: block::AIR as u16,
            size: 0,
            damage: 0,
        };
        /// Shortcut constructor for an item stack with single item.
        pub const fn new_single(id: u16, damage: u16) -> Self {
            Self { id, size: 1, damage }
        }
        pub const fn new_sized(id: u16, damage: u16, size: u16) -> Self {
            Self { id, size, damage }
        }
        /// Shortcut constructor for an item stack constructed from a block id and metadata.
        pub const fn new_block(id: u8, metadata: u8) -> Self {
            Self {
                id: id as u16,
                size: 1,
                damage: metadata as u16,
            }
        }
        pub const fn new_block_sized(id: u8, metadata: u8, size: u16) -> Self {
            Self {
                id: id as u16,
                size,
                damage: metadata as u16,
            }
        }
        pub const fn with_size(mut self, size: u16) -> ItemStack {
            self.size = size;
            self
        }
        pub const fn with_damage(mut self, damage: u16) -> ItemStack {
            self.damage = damage;
            self
        }
        /// Return true if this item stack is air, which is a special case where the item
        /// stack represent an empty slot.
        pub fn is_empty(self) -> bool {
            self.id == block::AIR as u16 || self.size == 0
        }
        /// Simplify this item stack by converting it into `None` if the item is just a air
        /// block, which is equivalent to no item for Minecraft, regardless of the damage
        /// value or stack size.
        pub fn to_non_empty(self) -> Option<ItemStack> {
            if self.is_empty() { None } else { Some(self) }
        }
        /// Modify this item stack and make it empty after returning the contained item stack,
        /// only if not already empty.
        pub fn take_non_empty(&mut self) -> Option<ItemStack> {
            let ret = self.to_non_empty();
            *self = Self::EMPTY;
            ret
        }
        /// Increment damage to this item, if max damage is reached for that item, the stack
        /// size will be decremented (saturating at 0).
        pub fn inc_damage(mut self, amount: u16) -> ItemStack {
            if amount != 0 {
                self.damage = self.damage.saturating_add(amount);
                if self.damage > from_id(self.id).max_damage {
                    self.size = self.size.saturating_sub(1);
                    self.damage = 0;
                }
            }
            self
        }
    }
}
pub mod entity {
    //! Entities structures and logic implementation.
    use glam::{DVec3, Vec2, IVec3};
    use crate::block::material::Material;
    use crate::util::default as def;
    use crate::geom::BoundingBox;
    use crate::rand::JavaRandom;
    use crate::item::ItemStack;
    use crate::world::World;
    use crate::block;
    pub mod common {
        //! Common functions to apply modifications to entities.
        use std::cell::RefCell;
        use std::ops::Sub;
        use glam::{DVec3, IVec3, Vec2, Vec3Swizzles};
        use crate::world::bound::RayTraceKind;
        use crate::block::material::Material;
        use crate::geom::{Face, BoundingBox};
        use crate::world::{World, Light};
        use crate::block;
        use super::{Entity, LivingKind, Base};
        pub(super) use let_expect as let_expect;
        /// Temporary entity id storage.
        pub(super) const ENTITY_ID: ::std::thread::LocalKey<RefCell<Vec<u32>>> = {
            #[inline]
            #[deny(unsafe_op_in_unsafe_fn)]
            unsafe fn __getit(
                _init: ::std::option::Option<
                    &mut ::std::option::Option<RefCell<Vec<u32>>>,
                >,
            ) -> ::std::option::Option<&'static RefCell<Vec<u32>>> {
                const INIT_EXPR: RefCell<Vec<u32>> = RefCell::new(Vec::new());
                #[thread_local]
                static mut VAL: RefCell<Vec<u32>> = INIT_EXPR;
                if !::std::mem::needs_drop::<RefCell<Vec<u32>>>() {
                    unsafe { return ::std::option::Option::Some(&VAL) }
                }
                #[thread_local]
                static STATE: ::std::cell::Cell<::std::primitive::u8> = ::std::cell::Cell::new(
                    0,
                );
                unsafe extern "C" fn destroy(ptr: *mut ::std::primitive::u8) {
                    ::std::thread::local_impl::abort_on_dtor_unwind(|| {
                        let old_state = STATE.replace(2);
                        if true {
                            match (&old_state, &1) {
                                (left_val, right_val) => {
                                    if !(*left_val == *right_val) {
                                        let kind = ::core::panicking::AssertKind::Eq;
                                        ::core::panicking::assert_failed(
                                            kind,
                                            &*left_val,
                                            &*right_val,
                                            ::core::option::Option::None,
                                        );
                                    }
                                }
                            };
                        }
                        unsafe {
                            ::std::ptr::drop_in_place(ptr.cast::<RefCell<Vec<u32>>>());
                        }
                    });
                }
                unsafe {
                    match STATE.get() {
                        0 => {
                            ::std::thread::local_impl::Key::<
                                RefCell<Vec<u32>>,
                            >::register_dtor(
                                &raw mut VAL as *mut ::std::primitive::u8,
                                destroy,
                            );
                            STATE.set(1);
                            ::std::option::Option::Some(&VAL)
                        }
                        1 => ::std::option::Option::Some(&VAL),
                        _ => ::std::option::Option::None,
                    }
                }
            }
            unsafe { ::std::thread::LocalKey::new(__getit) }
        };
        /// Temporary bounding boxes storage.
        pub(super) const BOUNDING_BOX: ::std::thread::LocalKey<
            RefCell<Vec<BoundingBox>>,
        > = {
            #[inline]
            #[deny(unsafe_op_in_unsafe_fn)]
            unsafe fn __getit(
                _init: ::std::option::Option<
                    &mut ::std::option::Option<RefCell<Vec<BoundingBox>>>,
                >,
            ) -> ::std::option::Option<&'static RefCell<Vec<BoundingBox>>> {
                const INIT_EXPR: RefCell<Vec<BoundingBox>> = RefCell::new(Vec::new());
                #[thread_local]
                static mut VAL: RefCell<Vec<BoundingBox>> = INIT_EXPR;
                if !::std::mem::needs_drop::<RefCell<Vec<BoundingBox>>>() {
                    unsafe { return ::std::option::Option::Some(&VAL) }
                }
                #[thread_local]
                static STATE: ::std::cell::Cell<::std::primitive::u8> = ::std::cell::Cell::new(
                    0,
                );
                unsafe extern "C" fn destroy(ptr: *mut ::std::primitive::u8) {
                    ::std::thread::local_impl::abort_on_dtor_unwind(|| {
                        let old_state = STATE.replace(2);
                        if true {
                            match (&old_state, &1) {
                                (left_val, right_val) => {
                                    if !(*left_val == *right_val) {
                                        let kind = ::core::panicking::AssertKind::Eq;
                                        ::core::panicking::assert_failed(
                                            kind,
                                            &*left_val,
                                            &*right_val,
                                            ::core::option::Option::None,
                                        );
                                    }
                                }
                            };
                        }
                        unsafe {
                            ::std::ptr::drop_in_place(
                                ptr.cast::<RefCell<Vec<BoundingBox>>>(),
                            );
                        }
                    });
                }
                unsafe {
                    match STATE.get() {
                        0 => {
                            ::std::thread::local_impl::Key::<
                                RefCell<Vec<BoundingBox>>,
                            >::register_dtor(
                                &raw mut VAL as *mut ::std::primitive::u8,
                                destroy,
                            );
                            STATE.set(1);
                            ::std::option::Option::Some(&VAL)
                        }
                        1 => ::std::option::Option::Some(&VAL),
                        _ => ::std::option::Option::None,
                    }
                }
            }
            unsafe { ::std::thread::LocalKey::new(__getit) }
        };
        /// Calculate the eye position of the given entity.
        pub fn calc_eye_pos(base: &Base) -> DVec3 {
            let mut pos = base.pos;
            pos.y += base.eye_height as f64;
            pos
        }
        /// Return true if the given bounding box is colliding with any fluid (given material).
        pub fn has_fluids_colliding(
            world: &World,
            bb: BoundingBox,
            material: Material,
        ) -> bool {
            if true {
                if !material.is_fluid() {
                    ::core::panicking::panic("assertion failed: material.is_fluid()")
                }
            }
            world
                .iter_blocks_in_box(bb)
                .filter(|&(_, block, _)| {
                    block::material::get_material(block) == material
                })
                .any(|(pos, _, metadata)| {
                    let dist = block::fluid::get_actual_distance(metadata);
                    let height = 1.0 - dist as f64 / 8.0;
                    pos.y as f64 + height >= bb.min.y
                })
        }
        /// Calculate the velocity of a fluid at given position, this depends on neighbor blocks.
        /// This calculation will only take the given material into account, this material should
        /// be a fluid material (water/lava), and the given metadata should be the one of the
        /// current block the the position.
        pub fn calc_fluid_vel(
            world: &World,
            pos: IVec3,
            material: Material,
            metadata: u8,
        ) -> DVec3 {
            if true {
                if !material.is_fluid() {
                    ::core::panicking::panic("assertion failed: material.is_fluid()")
                }
            }
            let distance = block::fluid::get_actual_distance(metadata);
            let mut vel = DVec3::ZERO;
            for face in Face::HORIZONTAL {
                let face_delta = face.delta();
                let face_pos = pos + face_delta;
                let (face_block, face_metadata) = world
                    .get_block(face_pos)
                    .unwrap_or_default();
                let face_material = block::material::get_material(face_block);
                if face_material == material {
                    let face_distance = block::fluid::get_actual_distance(face_metadata);
                    let delta = face_distance as i32 - distance as i32;
                    vel += (face_delta * delta).as_dvec3();
                } else if !face_material.is_solid() {
                    let below_pos = face_pos - IVec3::Y;
                    let (below_block, below_metadata) = world
                        .get_block(below_pos)
                        .unwrap_or_default();
                    let below_material = block::material::get_material(below_block);
                    if below_material == material {
                        let below_distance = block::fluid::get_actual_distance(
                            below_metadata,
                        );
                        let delta = below_distance as i32 - (distance as i32 - 8);
                        vel += (face_delta * delta).as_dvec3();
                    }
                }
            }
            vel.normalize()
        }
        /// Calculate the light levels for an entity given its base component.
        pub fn get_entity_light(world: &World, base: &Base) -> Light {
            let mut check_pos = base.pos;
            check_pos.y += (base.size.height * 0.66 - base.size.center) as f64;
            world.get_light(check_pos.floor().as_ivec3())
        }
        /// Find a the closest player entity (as defined in [`World`]) within the given radius.
        pub fn find_closest_player_entity(
            world: &World,
            center: DVec3,
            max_dist: f64,
        ) -> Option<(u32, &Entity, f64)> {
            let max_dist_sq = max_dist.powi(2);
            world
                .iter_player_entities()
                .map(|(entity_id, entity)| (
                    entity_id,
                    entity,
                    entity.0.pos.distance_squared(center),
                ))
                .filter(|&(_, _, dist_sq)| dist_sq <= max_dist_sq)
                .min_by(|(_, _, a), (_, _, b)| a.total_cmp(b))
                .map(|(entity_id, entity, dist_sq)| (entity_id, entity, dist_sq.sqrt()))
        }
        /// This function recompute the current bounding box from the position and the last
        /// size that was used to create it.
        pub fn update_bounding_box_from_pos(base: &mut Base) {
            let half_width = (base.size.width / 2.0) as f64;
            let height = base.size.height as f64;
            let center = base.size.center as f64;
            base
                .bb = BoundingBox {
                min: base.pos - DVec3::new(half_width, center, half_width),
                max: base.pos + DVec3::new(half_width, height - center, half_width),
            };
        }
        /// This position recompute the current position based on the bounding box' position
        /// the size that was used to create it.
        pub fn update_pos_from_bounding_box(base: &mut Base) {
            let center = base.size.center as f64;
            base
                .pos = DVec3 {
                x: (base.bb.min.x + base.bb.max.x) / 2.0,
                y: base.bb.min.y + center,
                z: (base.bb.min.z + base.bb.max.z) / 2.0,
            };
        }
        /// Modify the look angles of this entity, limited to the given step.
        /// We need to call this function many time to reach the desired look.
        pub fn update_look_by_step(base: &mut Base, look: Vec2, step: Vec2) {
            let look_norm = Vec2 {
                x: look.x.rem_euclid(std::f32::consts::TAU),
                y: look.y,
            };
            base.look += look_norm.sub(base.look).min(step);
        }
        /// Modify the look angles to point to a given target step by step. The eye height is
        /// included in the calculation in order to make the head looking at target.
        pub fn update_look_at_by_step(base: &mut Base, target: DVec3, step: Vec2) {
            let delta = target - calc_eye_pos(base);
            let yaw = f64::atan2(delta.z, delta.x) as f32 - std::f32::consts::FRAC_PI_2;
            let pitch = -f64::atan2(delta.y, delta.xz().length()) as f32;
            update_look_by_step(base, Vec2::new(yaw, pitch), step);
        }
        /// Almost the same as [`update_look_at_by_step`] but the target is another entity base,
        /// this function will make the entity look at the eyes of the target one.
        pub fn update_look_at_entity_by_step(
            base: &mut Base,
            target_base: &Base,
            step: Vec2,
        ) {
            update_look_at_by_step(base, calc_eye_pos(target_base), step);
        }
        /// Apply knock back to this entity's velocity.
        pub fn update_knock_back(base: &mut Base, dir: DVec3) {
            let mut accel = dir.normalize_or_zero();
            accel.y -= 1.0;
            base.vel /= 2.0;
            base.vel -= accel * 0.4;
            base.vel.y = base.vel.y.min(0.4);
        }
        /// Return true if the entity can eye track the target entity, this use ray tracing.
        pub fn can_eye_track(world: &World, base: &Base, target_base: &Base) -> bool {
            let origin = calc_eye_pos(base);
            let ray = calc_eye_pos(target_base) - origin;
            world.ray_trace_blocks(origin, ray, RayTraceKind::Overlay).is_none()
        }
        /// Get the path weight function for the given living entity kind.
        pub fn path_weight_func(living_kind: &LivingKind) -> fn(&World, IVec3) -> f32 {
            match living_kind {
                LivingKind::Pig(_)
                | LivingKind::Chicken(_)
                | LivingKind::Cow(_)
                | LivingKind::Sheep(_)
                | LivingKind::Wolf(_) => path_weight_animal,
                LivingKind::Creeper(_)
                | LivingKind::PigZombie(_)
                | LivingKind::Skeleton(_)
                | LivingKind::Spider(_)
                | LivingKind::Zombie(_) => path_weight_mob,
                LivingKind::Giant(_) => path_weight_giant,
                _ => path_weight_default,
            }
        }
        /// Path weight function for animals.
        fn path_weight_animal(world: &World, pos: IVec3) -> f32 {
            if world.is_block(pos - IVec3::Y, block::GRASS) {
                10.0
            } else {
                world.get_light(pos).brightness() - 0.5
            }
        }
        /// Path weight function for mobs.
        fn path_weight_mob(world: &World, pos: IVec3) -> f32 {
            0.5 - world.get_light(pos).brightness()
        }
        /// Path weight function for Giant.
        fn path_weight_giant(world: &World, pos: IVec3) -> f32 {
            world.get_light(pos).brightness() - 0.5
        }
        /// Path weight function by default.
        fn path_weight_default(_world: &World, _pos: IVec3) -> f32 {
            0.0
        }
    }
    mod tick {
        //! Base function for ticking entity.
        //!
        //! This module gives in documentation the reference to the Java methods, as known from
        //! the decompilation of Minecraft b1.7.3 by RetroMCP.
        //!
        //! This module architecture is quite complicated because we want to replicate almost the
        //! same logic path as the Notchian implementation, so we need to emulate method
        //! overriding and super class calls. To achieve that, we use base/living/projectile kind
        //! enumerations in order to route logic, each function that is created must exists
        use glam::{DVec3, IVec3, Vec2, Vec3Swizzles};
        use tracing::trace;
        use crate::block::material::Material;
        use crate::world::bound::RayTraceKind;
        use crate::world::{World, Event, EntityEvent};
        use crate::entity::Chicken;
        use crate::item::ItemStack;
        use crate::geom::{Face, BoundingBox};
        use crate::block;
        use super::{
            Entity, BaseKind, ProjectileKind, LivingKind, Base, Living, Hurt,
            ProjectileHit,
        };
        use super::common::{self, let_expect};
        use super::tick_state;
        use super::tick_ai;
        /// Entry point tick method for all entities.
        pub(super) fn tick(world: &mut World, id: u32, entity: &mut Entity) {
            let Entity(base, _) = entity;
            if base.pos.y < -64.0 {
                world.remove_entity(id, "void");
                return;
            }
            let prev_pos = base.pos;
            let prev_vel = base.vel;
            let prev_look = base.look;
            base.lifetime += 1;
            match entity {
                Entity(_, BaseKind::Item(_)) => tick_item(world, id, entity),
                Entity(_, BaseKind::Painting(_)) => tick_painting(world, id, entity),
                Entity(_, BaseKind::FallingBlock(_)) => {
                    tick_falling_block(world, id, entity)
                }
                Entity(_, BaseKind::Tnt(_)) => tick_tnt(world, id, entity),
                Entity(_, BaseKind::Living(_, _)) => tick_living(world, id, entity),
                Entity(_, BaseKind::Projectile(_, _)) => {
                    tick_projectile(world, id, entity)
                }
                Entity(_, _) => tick_base(world, id, entity),
            }
            let Entity(base, _) = entity;
            if prev_pos != base.pos {
                world
                    .push_event(Event::Entity {
                        id,
                        inner: EntityEvent::Position {
                            pos: base.pos,
                        },
                    });
            }
            if prev_vel != base.vel {
                world
                    .push_event(Event::Entity {
                        id,
                        inner: EntityEvent::Velocity {
                            vel: base.vel,
                        },
                    });
            }
            if prev_look != base.look {
                world
                    .push_event(Event::Entity {
                        id,
                        inner: EntityEvent::Look {
                            look: base.look,
                        },
                    });
            }
        }
        /// REF: Entity::onUpdate
        fn tick_base(world: &mut World, id: u32, entity: &mut Entity) {
            tick_state(world, id, entity);
        }
        /// REF: EntityItem::onUpdate
        fn tick_item(world: &mut World, id: u32, entity: &mut Entity) {
            tick_base(world, id, entity);
            #[allow(irrefutable_let_patterns)]
            let Entity(base, BaseKind::Item(item)) = entity else {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!("invalid argument for this function"),
                        ),
                    );
                };
            };
            if item.frozen_time > 0 {
                item.frozen_time -= 1;
            }
            base.vel.y -= 0.04;
            if base.in_lava {
                base.vel.y = 0.2;
                base
                    .vel
                    .x = ((base.rand.next_float() - base.rand.next_float()) * 0.2)
                    as f64;
                base
                    .vel
                    .z = ((base.rand.next_float() - base.rand.next_float()) * 0.2)
                    as f64;
            }
            let block_pos = base.pos.floor().as_ivec3();
            if world.is_block_opaque_cube(block_pos) {
                let delta = base.pos - block_pos.as_dvec3();
                let bump_face = Face::ALL
                    .into_iter()
                    .filter(|face| !world.is_block_opaque_cube(block_pos + face.delta()))
                    .map(|face| {
                        let mut delta = delta[face.axis_index()];
                        if face.is_pos() {
                            delta = 1.0 - delta;
                        }
                        (face, delta)
                    })
                    .min_by(|&(_, delta1), &(_, delta2)| delta1.total_cmp(&delta2))
                    .map(|(face, _)| face);
                if let Some(bump_face) = bump_face {
                    let accel = (base.rand.next_float() * 0.2 + 0.1) as f64;
                    if bump_face.is_neg() {
                        base.vel[bump_face.axis_index()] = -accel;
                    } else {
                        base.vel[bump_face.axis_index()] = accel;
                    }
                }
            }
            apply_base_vel(world, id, base, base.vel, 0.0);
            let mut slipperiness = 0.98;
            if base.on_ground {
                slipperiness = 0.1 * 0.1 * 58.8;
                let ground_pos = IVec3 {
                    x: base.pos.x.floor() as i32,
                    y: base.bb.min.y.floor() as i32 - 1,
                    z: base.pos.z.floor() as i32,
                };
                if let Some((ground_id, _)) = world.get_block(ground_pos) {
                    if ground_id != block::AIR {
                        slipperiness = block::material::get_slipperiness(ground_id);
                    }
                }
            }
            base.vel.x *= slipperiness as f64;
            base.vel.y *= 0.98;
            base.vel.z *= slipperiness as f64;
            if base.on_ground {
                base.vel.y *= -0.5;
            }
            if base.lifetime >= 6000 {
                world.remove_entity(id, "item too old");
            }
        }
        /// REF: EntityPainting::onUpdate
        fn tick_painting(_world: &mut World, _id: u32, entity: &mut Entity) {
            #[allow(irrefutable_let_patterns)]
            let Entity(_, BaseKind::Painting(painting)) = entity else {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!("invalid argument for this function"),
                        ),
                    );
                };
            };
            painting.check_valid_time += 1;
            if painting.check_valid_time >= 100 {
                painting.check_valid_time = 0;
            }
        }
        /// REF: EntityFallingSand::onUpdate
        fn tick_falling_block(world: &mut World, id: u32, entity: &mut Entity) {
            #[allow(irrefutable_let_patterns)]
            let Entity(base, BaseKind::FallingBlock(falling_block)) = entity else {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!("invalid argument for this function"),
                        ),
                    );
                };
            };
            if falling_block.block_id == 0 {
                world.remove_entity(id, "falling block has not block");
                return;
            }
            base.vel.y -= 0.04;
            apply_base_vel(world, id, base, base.vel, 0.0);
            if base.on_ground {
                base.vel *= DVec3::new(0.7, -0.5, 0.7);
                world.remove_entity(id, "falling block on ground");
                let block_pos = base.pos.floor().as_ivec3();
                if world.can_place_block(block_pos, Face::PosY, falling_block.block_id) {
                    world.set_block_notify(block_pos, falling_block.block_id, 0);
                } else {
                    world
                        .spawn_loot(
                            base.pos,
                            ItemStack::new_block(falling_block.block_id, 0),
                            0.0,
                        );
                }
            } else if base.lifetime > 100 {
                world.remove_entity(id, "falling block too old");
                world
                    .spawn_loot(
                        base.pos,
                        ItemStack::new_block(falling_block.block_id, 0),
                        0.0,
                    );
            }
        }
        /// REF: EntityTNTPrimed::onUpdate
        fn tick_tnt(world: &mut World, id: u32, entity: &mut Entity) {
            #[allow(irrefutable_let_patterns)]
            let Entity(base, BaseKind::Tnt(tnt)) = entity else {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!("invalid argument for this function"),
                        ),
                    );
                };
            };
            base.vel.y -= 0.04;
            apply_base_vel(world, id, base, base.vel, 0.0);
            base.vel.y *= 0.98;
            if base.on_ground {
                base.vel *= DVec3::new(0.7, -0.5, 0.7);
            }
            tnt.fuse_time = tnt.fuse_time.saturating_sub(1);
            if tnt.fuse_time == 0 {
                world.remove_entity(id, "tnt explode");
                world.explode(base.pos, 4.0, false, None);
            }
        }
        /// REF: EntityLiving::onUpdate
        fn tick_living(world: &mut World, id: u32, entity: &mut Entity) {
            tick_base(world, id, entity);
            tick_ai(world, id, entity);
            #[allow(irrefutable_let_patterns)]
            let Entity(base, BaseKind::Living(living, living_kind)) = entity else {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!("invalid argument for this function"),
                        ),
                    );
                };
            };
            if living.jumping {
                if base.in_water || base.in_lava {
                    base.vel.y += 0.04;
                } else if base.on_ground {
                    base.vel.y += 0.42 + 0.1;
                }
            }
            living.accel_strafing *= 0.98;
            living.accel_forward *= 0.98;
            living.yaw_velocity *= 0.9;
            tick_living_pos(world, id, base, living, living_kind);
            tick_living_push(world, id, base);
        }
        /// REF:
        /// - EntityArrow::onUpdate
        /// - EntitySnowball::onUpdate
        /// - EntityFireball::onUpdate
        /// - EntityEgg:onUpdate
        fn tick_projectile(world: &mut World, id: u32, entity: &mut Entity) {
            tick_base(world, id, entity);
            #[allow(irrefutable_let_patterns)]
            let Entity(base, BaseKind::Projectile(projectile, projectile_kind)) = entity
            else {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!("invalid argument for this function"),
                        ),
                    );
                };
            };
            projectile.shake = projectile.shake.saturating_sub(1);
            projectile.state_time = projectile.state_time.saturating_add(1);
            if let ProjectileKind::Bobber(bobber) = projectile_kind {
                let mut remove_bobber = true;
                if let Some(owner_id) = projectile.owner_id {
                    if let Some(Entity(owner_base, _)) = world.get_entity(owner_id) {
                        if owner_base.bobber_id == Some(id) {
                            remove_bobber = false;
                        }
                    }
                }
                if remove_bobber {
                    world.remove_entity(id, "bobber has no owner");
                    return;
                }
                if let Some(attached_id) = bobber.attached_id {
                    if let Some(Entity(attached_base, _)) = world.get_entity(attached_id)
                    {
                        base.pos.x = attached_base.pos.x;
                        base
                            .pos
                            .y = attached_base.bb.min.y
                            + attached_base.size.height as f64 * 0.8;
                        base.pos.z = attached_base.pos.z;
                        projectile.state = None;
                        common::update_bounding_box_from_pos(base);
                        return;
                    } else {
                        bobber.attached_id = None;
                    }
                }
            }
            if let Some(hit) = projectile.state {
                if (hit.block, hit.metadata) == world.get_block(hit.pos).unwrap() {
                    if projectile.state_time == 1200 {
                        world.remove_entity(id, "projectile in block for too long");
                    }
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event mc173\\src\\entity\\tick.rs:328",
                                    "mc173::entity::tick",
                                    ::tracing::Level::TRACE,
                                    ::core::option::Option::Some("mc173\\src\\entity\\tick.rs"),
                                    ::core::option::Option::Some(328u32),
                                    ::core::option::Option::Some("mc173::entity::tick"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("entity #{0}, no longer in block...", id)
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    base.vel *= (base.rand.next_float_vec() * 0.2).as_dvec3();
                    projectile.state = None;
                    projectile.state_time = 0;
                }
            } else {
                let hit_block = world
                    .ray_trace_blocks(base.pos, base.vel, RayTraceKind::Colliding);
                if let Some(hit_block) = &hit_block {
                    base.vel = hit_block.ray;
                }
                let owner_invincible_time = match projectile_kind {
                    ProjectileKind::Fireball(_) => 25,
                    _ => 5,
                };
                let owner_id = projectile
                    .owner_id
                    .filter(|_| projectile.state_time < owner_invincible_time);
                let hit_entity = world
                    .iter_entities_colliding_mut(
                        base.bb.offset(base.vel).inflate(DVec3::ONE),
                    )
                    .filter(|(target_id, Entity(_, target_base_kind))| {
                        match target_base_kind {
                            BaseKind::Item(_)
                            | BaseKind::LightningBolt(_)
                            | BaseKind::Projectile(_, _) => false,
                            _ => Some(*target_id) != owner_id,
                        }
                    })
                    .filter_map(|(target_id, target_entity)| {
                        target_entity
                            .0
                            .bb
                            .inflate(DVec3::splat(0.3))
                            .calc_ray_trace(base.pos, base.vel)
                            .map(|(new_ray, _)| (
                                target_id,
                                target_entity,
                                new_ray.length_squared(),
                            ))
                    })
                    .min_by(|(_, _, len1), (_, _, len2)| len1.total_cmp(len2))
                    .map(|(target_id, target_entity, _)| (target_id, target_entity));
                match projectile_kind {
                    ProjectileKind::Arrow(_) => {
                        if let Some((_, Entity(hit_base, _))) = hit_entity {
                            hit_base
                                .hurt
                                .push(Hurt {
                                    damage: 4,
                                    origin_id: projectile.owner_id,
                                });
                        } else if let Some(hit_block) = hit_block {
                            projectile
                                .state = Some(ProjectileHit {
                                pos: hit_block.pos,
                                block: hit_block.block,
                                metadata: hit_block.metadata,
                            });
                            projectile.shake = 7;
                            if hit_block.face == Face::PosY {
                                base.pos.y += base.size.center as f64;
                            } else if hit_block.face == Face::NegY {} else {
                                base.pos
                                    += hit_block.face.delta().as_dvec3()
                                        * (base.size.width / 2.0 + (2.0 / 32.0)) as f64;
                            }
                        }
                    }
                    ProjectileKind::Snowball(_) | ProjectileKind::Egg(_) => {
                        if let Some((_, Entity(hit_base, _))) = hit_entity {
                            hit_base
                                .hurt
                                .push(Hurt {
                                    damage: 0,
                                    origin_id: projectile.owner_id,
                                });
                        }
                        if hit_entity.is_some() || hit_block.is_some() {
                            world.remove_entity(id, "projectile hit");
                            if let ProjectileKind::Egg(_) = projectile_kind {
                                if base.rand.next_int_bounded(8) == 0 {
                                    let mut count = 1usize;
                                    if base.rand.next_int_bounded(32) == 0 {
                                        count = 4;
                                    }
                                    for _ in 0..count {
                                        world
                                            .spawn_entity(
                                                Chicken::new_with(|new_base, new_living, _| {
                                                    new_base.persistent = true;
                                                    new_base.pos = base.pos;
                                                    new_base
                                                        .look
                                                        .x = base.rand.next_float() * std::f32::consts::TAU;
                                                    new_living.health = 4;
                                                }),
                                            );
                                    }
                                }
                            }
                        }
                    }
                    ProjectileKind::Fireball(_) => {
                        if hit_entity.is_some() || hit_block.is_some() {
                            world.remove_entity(id, "fireball hit");
                            world.explode(base.pos, 1.0, true, projectile.owner_id);
                        }
                    }
                    ProjectileKind::Bobber(bobber) => {
                        if let Some((hit_id, Entity(hit_base, _))) = hit_entity {
                            hit_base
                                .hurt
                                .push(Hurt {
                                    damage: 0,
                                    origin_id: projectile.owner_id,
                                });
                            bobber.attached_id = Some(hit_id);
                        } else if let Some(hit_block) = hit_block {
                            projectile
                                .state = Some(ProjectileHit {
                                pos: hit_block.pos,
                                block: hit_block.block,
                                metadata: hit_block.metadata,
                            });
                        }
                    }
                }
                base.pos += base.vel;
                base.look.x = f64::atan2(base.vel.x, base.vel.z) as f32;
                base.look.y = f64::atan2(base.vel.y, base.vel.xz().length()) as f32;
                if let ProjectileKind::Fireball(fireball) = projectile_kind {
                    if base.in_water {
                        base.vel *= 0.8;
                    } else {
                        base.vel *= 0.95;
                    }
                    base.vel += fireball.accel;
                } else if let ProjectileKind::Bobber(bobber) = projectile_kind {
                    let mut fluid_boost = 0.0;
                    for delta in 0u8..5 {
                        let min_y = base.bb.min.y
                            + base.bb.size_y() * (delta + 0) as f64 / 5.0;
                        let max_y = base.bb.min.y
                            + base.bb.size_y() * (delta + 1) as f64 / 5.0;
                        let check_bb = BoundingBox {
                            min: DVec3 {
                                x: base.bb.min.x,
                                y: min_y,
                                z: base.bb.min.z,
                            },
                            max: DVec3 {
                                x: base.bb.max.x,
                                y: max_y,
                                z: base.bb.max.z,
                            },
                        };
                        if common::has_fluids_colliding(
                            world,
                            check_bb,
                            Material::Water,
                        ) {
                            fluid_boost += 1.0 / 5.0;
                        }
                    }
                    if fluid_boost > 0.0 {
                        if bobber.catch_time > 0 {
                            bobber.catch_time -= 1;
                        } else {
                            let chance = 500;
                            if base.rand.next_int_bounded(chance) == 0 {
                                bobber
                                    .catch_time = base.rand.next_int_bounded(30) as u16 + 10;
                                base.vel.y -= 0.2;
                            }
                        }
                    }
                    if bobber.catch_time > 0 {
                        base.vel.y
                            -= (base.rand.next_float() * base.rand.next_float()
                                * base.rand.next_float()) as f64 * 0.2;
                    }
                    let mut vel_factor = 0.92;
                    base.vel.y += (fluid_boost * 2.0 - 1.0) * 0.04;
                    if fluid_boost > 0.0 {
                        vel_factor *= 0.9;
                        base.vel.y *= 0.8;
                    }
                    base.vel *= vel_factor;
                } else {
                    if base.in_water {
                        base.vel *= 0.8;
                    } else {
                        base.vel *= 0.99;
                    }
                    base.vel.y -= 0.03;
                }
                common::update_bounding_box_from_pos(base);
            }
        }
        /// Tick a living entity to push/being pushed an entity.
        fn tick_living_push(world: &mut World, _id: u32, base: &mut Base) {
            for (_, push_entity) in world
                .iter_entities_colliding_mut(base.bb.inflate(DVec3::new(0.2, 0.0, 0.2)))
            {
                let Entity(push_base, push_base_kind) = push_entity;
                match push_base_kind {
                    BaseKind::Boat(_)
                    | BaseKind::Living(_, _)
                    | BaseKind::Minecart(_) => {}
                    _ => continue,
                }
                let mut dx = base.pos.x - push_base.pos.x;
                let mut dz = base.pos.z - push_base.pos.z;
                let mut delta = f64::max(dx.abs(), dz.abs());
                if delta >= 0.01 {
                    delta = delta.sqrt();
                    dx /= delta;
                    dz /= delta;
                    let delta_inv = 1.0 / delta;
                    dx *= delta_inv;
                    dz *= delta_inv;
                    dx *= 0.05;
                    dz *= 0.05;
                    let delta = DVec3::new(dx, 0.0, dz);
                    push_base.vel -= delta;
                    base.vel += delta;
                }
            }
        }
        /// REF: EntityLiving::moveEntityWithHeading
        fn tick_living_pos(
            world: &mut World,
            id: u32,
            base: &mut Base,
            living: &mut Living,
            living_kind: &mut LivingKind,
        ) {
            if let LivingKind::Squid(squid) = living_kind {
                if squid.animation_speed == 0.0 {
                    squid.animation_speed = 1.0 / (base.rand.next_float() + 1.0) * 0.2;
                }
                squid.animation += squid.animation_speed;
                if squid.animation > std::f32::consts::TAU {
                    squid.animation -= std::f32::consts::TAU;
                    if base.rand.next_int_bounded(10) == 0 {
                        squid
                            .animation_speed = 1.0 / (base.rand.next_float() + 1.0)
                            * 0.2;
                    }
                }
                if base.in_water {
                    if squid.animation < std::f32::consts::PI {
                        let progress = squid.animation / std::f32::consts::PI;
                        if progress > 0.75 {
                            living.accel_forward = 1.0;
                        }
                    } else {
                        living.accel_forward *= 0.9;
                    }
                    let (yaw_sin, yaw_cos) = base.look.x.sin_cos();
                    let pitch_sin = base.look.y.sin();
                    base.vel.x = (yaw_cos * 0.2 * living.accel_forward) as f64;
                    base.vel.z = (yaw_sin * 0.2 * living.accel_forward) as f64;
                    base.vel.y = (pitch_sin * 0.1 * living.accel_forward) as f64;
                } else {
                    base.vel.x = 0.0;
                    base.vel.z = 0.0;
                    base.vel.y -= 0.08;
                    base.vel.y *= 0.98;
                }
                apply_base_vel(world, id, base, base.vel, 0.5);
                return;
            }
            let step_height = 0.5;
            let flying = match living_kind {
                LivingKind::Ghast(_) => true,
                _ => false,
            };
            if base.in_water {
                apply_living_accel(base, living, 0.02);
                apply_base_vel(world, id, base, base.vel, step_height);
                base.vel *= 0.8;
                if !flying {
                    base.vel.y -= 0.02;
                }
            } else if base.in_lava {
                apply_living_accel(base, living, 0.02);
                apply_base_vel(world, id, base, base.vel, step_height);
                base.vel *= 0.5;
                if !flying {
                    base.vel.y -= 0.02;
                }
            } else {
                let mut slipperiness = 0.91;
                if base.on_ground {
                    slipperiness = 546.0 * 0.1 * 0.1 * 0.1;
                    let ground_pos = base.pos.as_ivec3();
                    if let Some((ground_id, _)) = world.get_block(ground_pos) {
                        if ground_id != 0 {
                            slipperiness = block::material::get_slipperiness(ground_id)
                                * 0.91;
                        }
                    }
                }
                let vel_factor = match base.on_ground {
                    true => {
                        0.16277136 / (slipperiness * slipperiness * slipperiness) * 0.1
                    }
                    false => 0.02,
                };
                apply_living_accel(base, living, vel_factor);
                apply_base_vel(world, id, base, base.vel, step_height);
                if flying {
                    base.vel *= slipperiness as f64;
                } else {
                    base.vel.y -= 0.08;
                    base.vel.y *= 0.98;
                    base.vel.x *= slipperiness as f64;
                    base.vel.z *= slipperiness as f64;
                }
            }
        }
        /// Update a living entity velocity according to its strafing/forward accel.
        pub fn apply_living_accel(base: &mut Base, living: &mut Living, factor: f32) {
            let mut strafing = living.accel_strafing;
            let mut forward = living.accel_forward;
            let mut dist = Vec2::new(forward, strafing).length();
            if dist >= 0.01 {
                dist = dist.max(1.0);
                dist = factor / dist;
                strafing *= dist;
                forward *= dist;
                let (yaw_sin, yaw_cos) = base.look.x.sin_cos();
                base.vel.x += (strafing * yaw_cos - forward * yaw_sin) as f64;
                base.vel.z += (forward * yaw_cos + strafing * yaw_sin) as f64;
            }
        }
        /// Common method for moving an entity by a given amount while checking collisions.
        ///
        /// REF: Entity::moveEntity
        pub fn apply_base_vel(
            world: &mut World,
            _id: u32,
            base: &mut Base,
            delta: DVec3,
            step_height: f32,
        ) {
            if base.no_clip {
                base.bb += delta;
                base.on_ground = false;
            } else {
                let colliding_bb = base.bb.expand(delta);
                let mut new_delta = delta;
                common::BOUNDING_BOX
                    .with_borrow_mut(|colliding_bbs| {
                        if true {
                            if !colliding_bbs.is_empty() {
                                ::core::panicking::panic(
                                    "assertion failed: colliding_bbs.is_empty()",
                                )
                            }
                        }
                        colliding_bbs
                            .extend(world.iter_blocks_boxes_colliding(colliding_bb));
                        colliding_bbs
                            .extend(
                                world
                                    .iter_entities_colliding(colliding_bb)
                                    .filter_map(|(_entity_id, entity)| {
                                        if let Entity(base, BaseKind::Boat(_)) = entity {
                                            Some(base.bb)
                                        } else {
                                            None
                                        }
                                    }),
                            );
                        for colliding_bb in &*colliding_bbs {
                            new_delta
                                .y = colliding_bb.calc_y_delta(base.bb, new_delta.y);
                        }
                        base.bb += DVec3::new(0.0, new_delta.y, 0.0);
                        for colliding_bb in &*colliding_bbs {
                            new_delta
                                .x = colliding_bb.calc_x_delta(base.bb, new_delta.x);
                        }
                        base.bb += DVec3::new(new_delta.x, 0.0, 0.0);
                        for colliding_bb in &*colliding_bbs {
                            new_delta
                                .z = colliding_bb.calc_z_delta(base.bb, new_delta.z);
                        }
                        base.bb += DVec3::new(0.0, 0.0, new_delta.z);
                        colliding_bbs.clear();
                    });
                let collided_x = delta.x != new_delta.x;
                let collided_y = delta.y != new_delta.y;
                let collided_z = delta.z != new_delta.z;
                let on_ground = collided_y && delta.y < 0.0;
                if step_height > 0.0 && on_ground && (collided_x || collided_z) {}
                base.on_ground = on_ground;
                if on_ground {
                    if base.fall_distance > 0.0 {}
                    base.fall_distance = 0.0;
                } else if new_delta.y < 0.0 {
                    base.fall_distance -= new_delta.y as f32;
                }
                if collided_x {
                    base.vel.x = 0.0;
                }
                if collided_y {
                    base.vel.y = 0.0;
                }
                if collided_z {
                    base.vel.z = 0.0;
                }
            }
            common::update_pos_from_bounding_box(base);
        }
    }
    mod tick_state {
        //! Tick state of the entity.
        use std::ops::Add;
        use glam::DVec3;
        use crate::entity::{Hurt, LivingKind, ProjectileKind};
        use crate::world::{World, Event, EntityEvent};
        use crate::block::material::Material;
        use crate::item::{self, ItemStack};
        use crate::block;
        use super::{Entity, BaseKind, Base, Living};
        use super::common::{self, let_expect};
        /// Tick base method that is common to every entity kind, this is split in Notchian impl
        /// so we split it here.
        pub(super) fn tick_state(world: &mut World, id: u32, entity: &mut Entity) {
            match entity {
                Entity(_, BaseKind::Living(_, _)) => tick_state_living(world, id, entity),
                Entity(_, _) => tick_state_base(world, id, entity),
            }
        }
        /// REF: Entity::onEntityUpdate
        fn tick_state_base(world: &mut World, id: u32, entity: &mut Entity) {
            let Entity(base, base_kind) = entity;
            let water_bb = match base_kind {
                BaseKind::Item(_) => base.bb,
                _ => base.bb.inflate(DVec3::new(-0.001, -0.4 - 0.001, -0.001)),
            };
            base.in_water = false;
            let mut water_vel = DVec3::ZERO;
            for (pos, block, metadata) in world.iter_blocks_in_box(water_bb) {
                let material = block::material::get_material(block);
                if material == Material::Water {
                    let height = block::fluid::get_actual_height(metadata);
                    if water_bb.max.y.add(1.0).floor() >= pos.y as f64 + height as f64 {
                        base.in_water = true;
                        water_vel
                            += common::calc_fluid_vel(world, pos, material, metadata);
                    }
                }
            }
            let water_vel = water_vel.normalize_or_zero();
            if water_vel != DVec3::ZERO {
                base.vel += water_vel * 0.014;
            }
            if base.in_water {
                base.fire_time = 0;
                base.fall_distance = 0.0;
            } else if match base_kind {
                BaseKind::Living(_, LivingKind::Ghast(_) | LivingKind::PigZombie(_)) => {
                    true
                }
                _ => false,
            } {
                base.fire_time = 0;
            }
            if base.fire_time > 0 {
                if base.fire_time % 20 == 0 {
                    base.hurt.push(Hurt { damage: 1, origin_id: None });
                }
                base.fire_time -= 1;
            }
            let lava_bb = base.bb.inflate(DVec3::new(-0.1, -0.4, -0.1));
            base
                .in_lava = world
                .iter_blocks_in_box(lava_bb)
                .any(|(_, block, _)| {
                    block::material::get_material(block) == Material::Lava
                });
            if base.can_pickup {
                common::ENTITY_ID
                    .with_borrow_mut(|picked_up_entities| {
                        if true {
                            if !picked_up_entities.is_empty() {
                                ::core::panicking::panic(
                                    "assertion failed: picked_up_entities.is_empty()",
                                )
                            }
                        }
                        for (entity_id, entity) in world
                            .iter_entities_colliding(
                                base.bb.inflate(DVec3::new(1.0, 0.0, 1.0)),
                            )
                        {
                            match &entity.1 {
                                BaseKind::Item(item) => {
                                    if item.frozen_time == 0 {
                                        picked_up_entities.push(entity_id);
                                    }
                                }
                                BaseKind::Projectile(
                                    projectile,
                                    ProjectileKind::Arrow(arrow),
                                ) => {
                                    if projectile.state.is_some() && arrow.from_player {
                                        picked_up_entities.push(entity_id);
                                    }
                                }
                                _ => {}
                            }
                        }
                        for entity_id in picked_up_entities.drain(..) {
                            world
                                .push_event(Event::Entity {
                                    id,
                                    inner: EntityEvent::Pickup {
                                        target_id: entity_id,
                                    },
                                });
                        }
                    });
            }
        }
        /// REF: EntityLiving::onEntityUpdate
        fn tick_state_living(world: &mut World, id: u32, entity: &mut Entity) {
            tick_state_base(world, id, entity);
            #[allow(irrefutable_let_patterns)]
            let Entity(base, BaseKind::Living(living, living_kind)) = entity else {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!("invalid argument for this function"),
                        ),
                    );
                };
            };
            let mut check_suffocate = true;
            if let LivingKind::Human(human) = living_kind {
                check_suffocate = !human.sleeping;
            }
            if check_suffocate {
                for i in 0u8..8 {
                    let delta = DVec3 {
                        x: (((i >> 0) & 1) as f64 - 0.5) * base.size.width as f64 * 0.9,
                        y: (((i >> 1) & 1) as f64 - 0.5) * 0.1 + base.eye_height as f64,
                        z: (((i >> 2) & 1) as f64 - 0.5) * base.size.width as f64 * 0.9,
                    };
                    if world.is_block_opaque_cube(base.pos.add(delta).floor().as_ivec3())
                    {
                        base.hurt.push(Hurt { damage: 1, origin_id: None });
                        break;
                    }
                }
            }
            if match living_kind {
                LivingKind::Zombie(_) | LivingKind::Skeleton(_) => true,
                _ => false,
            } {
                let block_pos = base.pos.floor().as_ivec3();
                let height = world.get_height(block_pos).unwrap_or(0) as i32;
                if block_pos.y >= height {
                    let light = common::get_entity_light(world, base);
                    if light.sky_real >= 12 {
                        if base.rand.next_float() * 30.0
                            < (light.brightness() - 0.4) * 2.0
                        {
                            base.fire_time = 300;
                        }
                    }
                }
            }
            if base.in_lava {
                base.hurt.push(Hurt { damage: 4, origin_id: None });
                base.fire_time = 600;
            }
            living.hurt_time = living.hurt_time.saturating_sub(1);
            /// The hurt time when hit for the first time.
            /// PARITY: The Notchian impl doesn't actually use hurt time but another variable
            ///  that have the exact same behavior, so we use hurt time here to be more
            ///  consistent. We also avoid the divide by two thing that is useless.
            const HURT_INITIAL_TIME: u16 = 10;
            let mut killer_id = None;
            while let Some(hurt) = base.hurt.pop() {
                if living.health == 0 {
                    break;
                }
                living.wander_time = 0;
                let mut actual_damage = 0;
                if living.hurt_time == 0 {
                    living.hurt_time = HURT_INITIAL_TIME;
                    living.hurt_last_damage = hurt.damage;
                    actual_damage = hurt.damage;
                    world
                        .push_event(Event::Entity {
                            id,
                            inner: EntityEvent::Damage,
                        });
                    if let Some(origin_id) = hurt.origin_id {
                        if let Some(Entity(origin_base, _)) = world.get_entity(origin_id)
                        {
                            let mut dir = origin_base.pos - base.pos;
                            dir.y = 0.0;
                            while dir.length_squared() < 1.0e-4 {
                                dir = DVec3 {
                                    x: (base.rand.next_double() - base.rand.next_double())
                                        * 0.01,
                                    y: 0.0,
                                    z: (base.rand.next_double() - base.rand.next_double())
                                        * 0.01,
                                };
                            }
                            common::update_knock_back(base, dir);
                        }
                    }
                } else if hurt.damage > living.hurt_last_damage {
                    actual_damage = hurt.damage - living.hurt_last_damage;
                    living.hurt_last_damage = hurt.damage;
                }
                if actual_damage != 0 {
                    living.health = living.health.saturating_sub(actual_damage);
                    if living.health == 0 {
                        killer_id = hurt.origin_id;
                    }
                }
            }
            if living.health == 0 {
                if living.death_time == 0 {
                    world
                        .push_event(Event::Entity {
                            id,
                            inner: EntityEvent::Dead,
                        });
                    spawn_living_loot(world, base, living, living_kind);
                    if let LivingKind::Creeper(_) = living_kind {
                        if let Some(killer_id) = killer_id {
                            if let Some(
                                Entity(_, BaseKind::Living(_, LivingKind::Skeleton(_))),
                            ) = world.get_entity(killer_id)
                            {
                                let item = base
                                    .rand
                                    .next_choice(&[item::RECORD_13, item::RECORD_CAT]);
                                let stack = ItemStack::new_single(item, 0);
                                world.spawn_loot(base.pos, stack, 0.0);
                            }
                        }
                    }
                }
                living.death_time += 1;
                if living.death_time > 20 {
                    world.remove_entity(id, "health dead");
                }
            }
        }
        fn spawn_living_loot(
            world: &mut World,
            base: &mut Base,
            _living: &mut Living,
            living_kind: &mut LivingKind,
        ) {
            let stack = match living_kind {
                LivingKind::Chicken(_) => ItemStack::new_single(item::FEATHER, 0),
                LivingKind::Cow(_) => ItemStack::new_single(item::LEATHER, 0),
                LivingKind::Creeper(_) => ItemStack::new_single(item::GUNPOWDER, 0),
                LivingKind::Ghast(_) => ItemStack::new_single(item::GUNPOWDER, 0),
                LivingKind::Pig(_) => {
                    if base.fire_time == 0 {
                        ItemStack::new_single(item::RAW_PORKCHOP, 0)
                    } else {
                        ItemStack::new_single(item::COOKED_PORKCHOP, 0)
                    }
                }
                LivingKind::PigZombie(_) => {
                    ItemStack::new_single(item::COOKED_PORKCHOP, 0)
                }
                LivingKind::Sheep(sheep) if !sheep.sheared => {
                    ItemStack::new_block(block::WOOL, sheep.color)
                }
                LivingKind::Skeleton(_) => {
                    spawn_many_loot(
                        world,
                        base.pos,
                        ItemStack::new_single(item::ARROW, 0),
                        base.rand.next_int_bounded(3) as usize,
                    );
                    spawn_many_loot(
                        world,
                        base.pos,
                        ItemStack::new_single(item::BONE, 0),
                        base.rand.next_int_bounded(3) as usize,
                    );
                    return;
                }
                LivingKind::Slime(slime) if slime.size == 0 => {
                    ItemStack::new_single(item::SLIMEBALL, 0)
                }
                LivingKind::Spider(_) => ItemStack::new_single(item::STRING, 0),
                LivingKind::Squid(_) => ItemStack::new_single(item::DYE, 0),
                LivingKind::Zombie(_) => ItemStack::new_single(item::FEATHER, 0),
                _ => return,
            };
            let count = match living_kind {
                LivingKind::Squid(_) => 1 + base.rand.next_int_bounded(3) as usize,
                _ => base.rand.next_int_bounded(3) as usize,
            };
            spawn_many_loot(world, base.pos, stack, count);
        }
        fn spawn_many_loot(
            world: &mut World,
            pos: DVec3,
            stack: ItemStack,
            count: usize,
        ) {
            for _ in 0..count {
                world.spawn_loot(pos, stack, 0.0);
            }
        }
    }
    mod tick_ai {
        //! Tick AI of the entity.
        use std::ops::Add;
        use glam::{Vec2, DVec3, IVec3};
        use tracing::trace;
        use crate::entity::{Fireball, Path, LookTarget};
        use crate::world::{World, Event, EntityEvent};
        use crate::path::PathFinder;
        use super::{Entity, BaseKind, LivingKind, EntityCategory};
        use super::common::{self, let_expect};
        use super::tick_attack;
        /// Tick entity "artificial intelligence", like attacking players.
        pub(super) fn tick_ai(world: &mut World, id: u32, entity: &mut Entity) {
            match entity {
                Entity(_, BaseKind::Living(_, LivingKind::Human(_))) => {}
                Entity(_, BaseKind::Living(_, LivingKind::Ghast(_))) => {
                    tick_ghast_ai(world, id, entity)
                }
                Entity(_, BaseKind::Living(_, LivingKind::Squid(_))) => {
                    tick_squid_ai(world, id, entity)
                }
                Entity(_, BaseKind::Living(_, LivingKind::Slime(_))) => {
                    tick_slime_ai(world, id, entity)
                }
                Entity(_, BaseKind::Living(_, _)) => tick_ground_ai(world, id, entity),
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!("invalid argument for this function"),
                        ),
                    );
                }
            }
        }
        /// This is the fallback for all ground entities to just look in random directions.
        ///
        /// REF: EntityLiving::updatePlayerActionState
        fn tick_living_ai(world: &mut World, _id: u32, entity: &mut Entity) {
            /// Multiplier for random yaw velocity: 20 deg
            const YAW_VELOCITY_MUL: f32 = 0.3490658503988659;
            /// Maximum distance for looking at a target.
            const LOOK_AT_MAX_DIST: f64 = 8.0;
            /// Default look step when looking at a target.
            const LOOK_STEP: Vec2 = Vec2::new(0.17453292519943295, 0.6981317007977318);
            /// Slow look step used for sitting dogs.
            const SLOW_LOOK_STEP: Vec2 = Vec2::new(
                0.17453292519943295,
                0.3490658503988659,
            );
            #[allow(irrefutable_let_patterns)]
            let Entity(base, BaseKind::Living(living, living_kind)) = entity else {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!("invalid argument for this function"),
                        ),
                    );
                };
            };
            living.accel_strafing = 0.0;
            living.accel_forward = 0.0;
            if base.rand.next_float() < 0.02 {
                if let Some((target_entity_id, _, _)) = common::find_closest_player_entity(
                    world,
                    base.pos,
                    LOOK_AT_MAX_DIST,
                ) {
                    living
                        .look_target = Some(LookTarget {
                        entity_id: target_entity_id,
                        remaining_time: base.rand.next_int_bounded(20) as u32 + 10,
                    });
                } else {
                    living
                        .yaw_velocity = (base.rand.next_float() - 0.5)
                        * YAW_VELOCITY_MUL;
                }
            }
            if let Some(target) = &mut living.look_target {
                target.remaining_time = target.remaining_time.saturating_sub(1);
                let mut target_release = target.remaining_time == 0;
                if let Some(Entity(target_base, _)) = world.get_entity(target.entity_id)
                {
                    let mut look_step = LOOK_STEP;
                    if let LivingKind::Wolf(wolf) = living_kind {
                        if wolf.sitting {
                            look_step = SLOW_LOOK_STEP;
                        }
                    }
                    common::update_look_at_entity_by_step(base, target_base, look_step);
                    if target_base.pos.distance_squared(base.pos)
                        > LOOK_AT_MAX_DIST.powi(2)
                    {
                        target_release = false;
                    }
                } else {
                    target_release = false;
                }
                if target_release {
                    living.look_target = None;
                }
            } else {
                if base.rand.next_float() < 0.05 {
                    living
                        .yaw_velocity = (base.rand.next_float() - 0.5)
                        * YAW_VELOCITY_MUL;
                }
                base.look.x += living.yaw_velocity;
                base.look.y = 0.0;
            }
            if base.in_water || base.in_lava {
                living.jumping = base.rand.next_float() < 0.8;
            }
        }
        /// Tick an ground creature (animal/mob) entity AI.
        ///
        /// REF: EntityCreature::updatePlayerActionState
        fn tick_ground_ai(world: &mut World, id: u32, entity: &mut Entity) {
            /// Maximum distance for the path finder.
            const PATH_FINDER_MAX_DIST: f32 = 16.0;
            /// Look step when looking at an attacked entity: 30/30 deg
            const LOOK_STEP: Vec2 = Vec2::new(0.5235987755982988, 0.5235987755982988);
            /// Internal structure that defines the target for the path finder.
            struct Target {
                /// Target position.
                pos: DVec3,
                /// True if the path should overwrite the current entity path, even when it
                /// was not found, therefore removing the previous one.
                overwrite: bool,
            }
            if tick_natural_despawn(world, id, entity) {
                return;
            }
            #[allow(irrefutable_let_patterns)]
            let Entity(base, BaseKind::Living(living, living_kind)) = entity else {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!("invalid argument for this function"),
                        ),
                    );
                };
            };
            let mut target_pos = None;
            let mut should_strafe = false;
            if let Some(target_id) = living.attack_target {
                if let Some(Entity(target_base, BaseKind::Living(_, _))) = world
                    .get_entity(target_id)
                {
                    let dist_squared = base.pos.distance_squared(target_base.pos);
                    let eye_track = common::can_eye_track(world, base, target_base);
                    target_pos = Some(Target {
                        pos: target_base.pos,
                        overwrite: true,
                    });
                    tick_attack(
                        world,
                        id,
                        entity,
                        target_id,
                        dist_squared,
                        eye_track,
                        &mut should_strafe,
                    );
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event mc173\\src\\entity\\tick_ai.rs:154",
                                    "mc173::entity::tick_ai",
                                    ::tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "mc173\\src\\entity\\tick_ai.rs",
                                    ),
                                    ::core::option::Option::Some(154u32),
                                    ::core::option::Option::Some("mc173::entity::tick_ai"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("entity #{0}, attack target released", id)
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    living.attack_target = None;
                }
            } else {
                let search_around = match living_kind {
                    LivingKind::Creeper(_) => true,
                    LivingKind::Giant(_) => true,
                    LivingKind::Skeleton(_) => true,
                    LivingKind::Zombie(_) => true,
                    LivingKind::PigZombie(pig_zombie) => pig_zombie.anger,
                    LivingKind::Wolf(wolf) => wolf.angry,
                    LivingKind::Spider(_) => {
                        common::get_entity_light(world, base).brightness() < 0.5
                    }
                    _ => false,
                };
                if search_around {
                    if let Some((target_id, Entity(target_base, _), _)) = common::find_closest_player_entity(
                        world,
                        base.pos,
                        16.0,
                    ) {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event mc173\\src\\entity\\tick_ai.rs:174",
                                        "mc173::entity::tick_ai",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "mc173\\src\\entity\\tick_ai.rs",
                                        ),
                                        ::core::option::Option::Some(174u32),
                                        ::core::option::Option::Some("mc173::entity::tick_ai"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!(
                                                            "entity #{0}, attack target found: #{1}",
                                                            id,
                                                            target_id,
                                                        ) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        living.attack_target = Some(target_id);
                        target_pos = Some(Target {
                            pos: target_base.pos,
                            overwrite: true,
                        });
                    }
                }
            }
            #[allow(irrefutable_let_patterns)]
            let Entity(base, BaseKind::Living(living, living_kind)) = entity else {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!("invalid argument for this function"),
                        ),
                    );
                };
            };
            if should_strafe || living.attack_target.is_none()
                || (living.path.is_some() && base.rand.next_int_bounded(20) != 0)
            {
                if !should_strafe
                    && ((living.path.is_none() && base.rand.next_int_bounded(80) == 0)
                        || base.rand.next_int_bounded(80) == 0)
                {
                    let weight_func = common::path_weight_func(living_kind);
                    let best_pos = (0..10)
                        .map(|_| {
                            IVec3 {
                                x: base
                                    .pos
                                    .x
                                    .add((base.rand.next_int_bounded(13) - 6) as f64)
                                    .floor() as i32,
                                y: base
                                    .pos
                                    .y
                                    .add((base.rand.next_int_bounded(7) - 3) as f64)
                                    .floor() as i32,
                                z: base
                                    .pos
                                    .z
                                    .add((base.rand.next_int_bounded(13) - 6) as f64)
                                    .floor() as i32,
                            }
                        })
                        .map(|pos| (pos, weight_func(world, pos)))
                        .max_by(|(_, a), (_, b)| a.total_cmp(b))
                        .unwrap()
                        .0;
                    target_pos = Some(Target {
                        pos: best_pos.as_dvec3() + 0.5,
                        overwrite: false,
                    });
                }
            }
            if let Some(target) = target_pos {
                let path = PathFinder::new(world)
                    .find_path_from_bounding_box(
                        base.bb,
                        target.pos,
                        PATH_FINDER_MAX_DIST,
                    )
                    .map(Path::from);
                if target.overwrite || path.is_some() {
                    living.path = path;
                }
            }
            let attack_target = living
                .attack_target
                .map(|id| world.get_entity(id).unwrap());
            if let Some(path) = &mut living.path {
                if base.rand.next_int_bounded(100) != 0 {
                    let bb_size = base.bb.size();
                    let double_width = bb_size.x * 2.0;
                    let mut next_pos = None;
                    while let Some(pos) = path.point() {
                        let mut pos = pos.as_dvec3();
                        pos.x += (bb_size.x + 1.0) * 0.5;
                        pos.z += (bb_size.z + 1.0) * 0.5;
                        let pos_dist_sq = pos
                            .distance_squared(DVec3::new(base.pos.x, pos.y, base.pos.z));
                        if pos_dist_sq < double_width * double_width {
                            path.advance();
                        } else {
                            next_pos = Some(pos);
                            break;
                        }
                    }
                    living.jumping = false;
                    if let Some(next_pos) = next_pos {
                        let dx = next_pos.x - base.pos.x;
                        let dy = next_pos.y - base.bb.min.y.add(0.5).floor();
                        let dz = next_pos.z - base.pos.z;
                        let move_speed = match living_kind {
                            LivingKind::Giant(_)
                            | LivingKind::Zombie(_)
                            | LivingKind::PigZombie(_) => 0.5,
                            LivingKind::Spider(_) => 0.8,
                            _ => 0.5,
                        };
                        living.accel_forward = move_speed;
                        base
                            .look
                            .x = f64::atan2(dz, dx) as f32 - std::f32::consts::FRAC_PI_2;
                        if should_strafe {
                            if let Some(Entity(target_base, _)) = attack_target {
                                let dx = target_base.pos.x - base.pos.x;
                                let dz = target_base.pos.z - base.pos.z;
                                base
                                    .look
                                    .x = f64::atan2(dz, dx) as f32
                                    - std::f32::consts::FRAC_PI_2;
                                living
                                    .accel_strafing = -base.look.x.sin() * living.accel_forward;
                                living
                                    .accel_forward = base.look.x.cos() * living.accel_forward;
                            }
                        }
                        if dy > 0.0 {
                            living.jumping = true;
                        }
                    } else {
                        living.path = None;
                    }
                    if let Some(Entity(target_base, _)) = attack_target {
                        common::update_look_at_entity_by_step(
                            base,
                            target_base,
                            LOOK_STEP,
                        );
                    }
                    if base.rand.next_float() < 0.8 && (base.in_water || base.in_lava) {
                        living.jumping = true;
                    }
                    return;
                } else {}
            }
            living.path = None;
            tick_living_ai(world, id, entity);
        }
        /// Tick a slime entity AI.
        ///
        /// REF: EntitySlime::updatePlayerActionState
        fn tick_slime_ai(world: &mut World, id: u32, entity: &mut Entity) {
            /// Look step for slime: 10/20 deg
            const LOOK_STEP: Vec2 = Vec2::new(0.17453292519943295, 0.3490658503988659);
            if tick_natural_despawn(world, id, entity) {
                return;
            }
            #[allow(irrefutable_let_patterns)]
            let Entity(base, BaseKind::Living(living, LivingKind::Slime(slime))) = entity
            else {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!("invalid argument for this function"),
                        ),
                    );
                };
            };
            let closest_player = common::find_closest_player_entity(
                world,
                base.pos,
                16.0,
            );
            if let Some((_, Entity(closest_base, _), _)) = closest_player {
                common::update_look_at_entity_by_step(base, closest_base, LOOK_STEP);
            }
            let mut set_jumping = false;
            if base.on_ground {
                slime.jump_remaining_time = slime.jump_remaining_time.saturating_sub(1);
                if slime.jump_remaining_time == 0 {
                    set_jumping = true;
                }
            }
            if set_jumping {
                slime.jump_remaining_time = base.rand.next_int_bounded(20) as u32 + 10;
                if closest_player.is_some() {
                    slime.jump_remaining_time /= 3;
                }
                living.jumping = true;
                living.accel_strafing = 1.0 - base.rand.next_float() * 2.0;
                living.accel_forward = slime.size as f32 + 1.0;
            } else {
                living.jumping = false;
                if base.on_ground {
                    living.accel_strafing = 0.0;
                    living.accel_forward = 0.0;
                }
            }
        }
        /// Tick a ghast entity AI.
        ///
        /// REF: EntityGhast::updatePlayerActionState
        fn tick_ghast_ai(world: &mut World, id: u32, entity: &mut Entity) {
            const SHOT_MAX_DIST_SQUARED: f64 = 64.0 * 64.0;
            if tick_natural_despawn(world, id, entity) {
                return;
            }
            #[allow(irrefutable_let_patterns)]
            let Entity(base, BaseKind::Living(living, LivingKind::Ghast(ghast))) = entity
            else {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!("invalid argument for this function"),
                        ),
                    );
                };
            };
            let dist = (ghast.waypoint - base.pos).length();
            if dist < 1.0 || dist > 60.0 {
                ghast
                    .waypoint = base.pos
                    + ((base.rand.next_float_vec() * 2.0 - 1.0) * 16.0).as_dvec3();
            }
            ghast.waypoint_check_time = ghast.waypoint_check_time.saturating_sub(1);
            if ghast.waypoint_check_time == 0 {
                ghast.waypoint_check_time = base.rand.next_int_bounded(5) as u8 + 2;
                let delta = ghast.waypoint - base.pos;
                let dist = delta.length();
                let delta_norm = delta / dist;
                if delta_norm.is_finite() {
                    let mut traversable = true;
                    let mut bb = base.bb;
                    for _ in 1..dist.ceil() as usize {
                        bb += delta_norm;
                        if world.iter_blocks_boxes_colliding(bb).next().is_some() {
                            traversable = false;
                            break;
                        }
                    }
                    if traversable {
                        base.vel += delta_norm * 0.1;
                    } else {
                        ghast.waypoint = base.pos;
                    }
                }
            }
            let mut target_entity = living
                .attack_target
                .and_then(|target_id| world.get_entity(target_id));
            if target_entity.is_some() {
                ghast.attack_target_time = ghast.attack_target_time.saturating_sub(1);
            }
            if target_entity.is_none() || ghast.attack_target_time == 0 {
                if let Some((closest_id, closest_entity, _)) = common::find_closest_player_entity(
                    world,
                    base.pos,
                    100.0,
                ) {
                    living.attack_target = Some(closest_id);
                    target_entity = Some(closest_entity);
                    ghast.attack_target_time = 20;
                } else {
                    living.attack_target = None;
                    target_entity = None;
                }
            }
            let mut look_vel = true;
            let mut next_attack_time = living.attack_time.saturating_sub(1);
            if let Some(Entity(target_base, _)) = target_entity {
                if target_base.pos.distance_squared(base.pos) < SHOT_MAX_DIST_SQUARED {
                    look_vel = false;
                    let center = base.bb.center();
                    let delta = target_base.bb.center() - center;
                    base.look.x = -f64::atan2(delta.x, delta.z) as f32;
                    if common::can_eye_track(world, base, target_base) {
                        next_attack_time = living.attack_time.saturating_add(1);
                        if living.attack_time == 60 {
                            next_attack_time = 0;
                            let fireball = Fireball::new_with(|
                                throw_base,
                                throw_projectile,
                                throw_fireball|
                            {
                                let dir = delta + throw_base.rand.next_gaussian_vec() * 0.4;
                                let dir = dir.normalize_or_zero();
                                throw_base.pos = center + dir * DVec3::new(4.0, 0.0, 4.0);
                                throw_base.look = base.look;
                                throw_fireball.accel = dir * 0.1;
                                throw_projectile.owner_id = Some(id);
                            });
                            world.spawn_entity(fireball);
                        }
                    }
                }
            }
            if look_vel {
                base.look.x = -f64::atan2(base.vel.x, base.vel.z) as f32;
            }
            let was_charged = living.attack_time > 50;
            let charged = next_attack_time > 50;
            if was_charged != charged {
                world
                    .push_event(Event::Entity {
                        id,
                        inner: EntityEvent::Metadata,
                    });
            }
            living.attack_time = next_attack_time;
        }
        /// Tick a squid entity AI.
        ///
        /// REF: EntitySquid::updatePlayerActionState
        fn tick_squid_ai(world: &mut World, id: u32, entity: &mut Entity) {
            if tick_natural_despawn(world, id, entity) {
                return;
            }
            #[allow(irrefutable_let_patterns)]
            let Entity(base, BaseKind::Living(_living, LivingKind::Squid(_squid))) = entity
            else {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!("invalid argument for this function"),
                        ),
                    );
                };
            };
            if base.rand.next_int_bounded(50) == 0 || !base.in_water || false {
                base.look.x = base.rand.next_float() * std::f32::consts::TAU;
                base.look.y = base.rand.next_float() * 0.46365 * 2.0 - 0.46365;
            }
        }
        /// Internal function to handle the entity despawning range of entities, which is 128
        /// blocks away from the closest player. This functions return true if the entity is
        /// has been removed for being too far or too old.
        fn tick_natural_despawn(
            world: &mut World,
            id: u32,
            entity: &mut Entity,
        ) -> bool {
            let Entity(base, BaseKind::Living(living, living_kind)) = entity else {
                return false;
            };
            if living.artificial {
                return false;
            }
            if let LivingKind::Wolf(wolf) = living_kind {
                if wolf.owner.is_some() {
                    return false;
                }
            }
            living.wander_time = living.wander_time.saturating_add(1);
            if living_kind.entity_kind().category() == EntityCategory::Mob {
                if common::get_entity_light(world, base).brightness() > 0.5 {
                    living.wander_time = living.wander_time.saturating_add(2);
                }
            }
            if world.get_entity_player_count() == 0 {
                return false;
            }
            if let Some((_, _, dist)) = common::find_closest_player_entity(
                world,
                base.pos,
                128.0,
            ) {
                if dist < 32.0 {
                    living.wander_time = 0;
                    false
                } else if living.wander_time > 600
                    && base.rand.next_int_bounded(800) == 0
                {
                    world.remove_entity(id, "random wandering despawn");
                    true
                } else {
                    false
                }
            } else {
                world.remove_entity(id, "no close player despawn");
                true
            }
        }
    }
    mod tick_attack {
        //! Tick entity attack from AI.
        use glam::{Vec3Swizzles, DVec3};
        use crate::entity::{Hurt, Arrow};
        use crate::world::{World, Event, EntityEvent};
        use super::{Entity, BaseKind, LivingKind};
        use super::common::{self, let_expect};
        /// Tick an attack from the entity to its targeted entity. The targeted entity id is given
        /// as argument and the entity is guaranteed to be present in the world as living entity.
        ///
        /// REF: EntityCreature::attackEntity
        pub(super) fn tick_attack(
            world: &mut World,
            id: u32,
            entity: &mut Entity,
            target_id: u32,
            dist_squared: f64,
            eye_track: bool,
            should_strafe: &mut bool,
        ) {
            match entity {
                Entity(_, BaseKind::Living(_, LivingKind::Spider(_))) => {
                    tick_spider_attack(
                        world,
                        id,
                        entity,
                        target_id,
                        dist_squared,
                        eye_track,
                        should_strafe,
                    )
                }
                Entity(_, BaseKind::Living(_, LivingKind::Creeper(_))) => {
                    tick_creeper_attack(
                        world,
                        id,
                        entity,
                        target_id,
                        dist_squared,
                        eye_track,
                        should_strafe,
                    )
                }
                Entity(_, BaseKind::Living(_, LivingKind::Skeleton(_))) => {
                    tick_skeleton_attack(
                        world,
                        id,
                        entity,
                        target_id,
                        dist_squared,
                        eye_track,
                        should_strafe,
                    )
                }
                Entity(_, BaseKind::Living(_, _)) => {
                    tick_mob_attack(
                        world,
                        id,
                        entity,
                        target_id,
                        dist_squared,
                        eye_track,
                        should_strafe,
                    )
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!("expected a living entity for this function"),
                        ),
                    );
                }
            }
        }
        /// REF: EntityMob::attackEntity
        fn tick_mob_attack(
            world: &mut World,
            id: u32,
            entity: &mut Entity,
            target_id: u32,
            dist_squared: f64,
            eye_track: bool,
            _should_strafe: &mut bool,
        ) {
            /// Maximum distance for the mob to attack.
            const MAX_DIST_SQUARED: f64 = 2.0 * 2.0;
            #[allow(irrefutable_let_patterns)]
            let Entity(base, BaseKind::Living(living, living_kind)) = entity else {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!("invalid argument for this function"),
                        ),
                    );
                };
            };
            living.attack_time = living.attack_time.saturating_sub(1);
            if eye_track && living.attack_time == 0 && dist_squared < MAX_DIST_SQUARED {
                let Some(Entity(target_base, BaseKind::Living(_, _))) = world
                    .get_entity_mut(target_id) else {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("target entity should exists"),
                        );
                    };
                };
                if base.bb.intersects_y(target_base.bb) {
                    let attack_damage = match living_kind {
                        LivingKind::Giant(_) => 50,
                        LivingKind::PigZombie(_) => 5,
                        LivingKind::Zombie(_) => 5,
                        _ => 2,
                    };
                    living.attack_time = 20;
                    target_base
                        .hurt
                        .push(Hurt {
                            damage: attack_damage,
                            origin_id: Some(id),
                        });
                }
            }
        }
        /// REF: EntitySpider::attackEntity
        fn tick_spider_attack(
            world: &mut World,
            id: u32,
            entity: &mut Entity,
            target_id: u32,
            dist_squared: f64,
            eye_track: bool,
            should_strafe: &mut bool,
        ) {
            /// Minimum distance from a player to trigger a climb of the spider.
            const MIN_DIST_SQUARED: f64 = 2.0 * 2.0;
            /// Maximum distance from a player to trigger a climb of the spider.
            const MAX_DIST_SQUARED: f64 = 6.0 * 6.0;
            #[allow(irrefutable_let_patterns)]
            let Entity(base, BaseKind::Living(living, LivingKind::Spider(_))) = entity
            else {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!("invalid argument for this function"),
                        ),
                    );
                };
            };
            if common::get_entity_light(world, base).brightness() > 0.5
                && base.rand.next_int_bounded(100) == 0
            {
                living.attack_target = None;
            } else if dist_squared > MIN_DIST_SQUARED && dist_squared < MAX_DIST_SQUARED
                && base.rand.next_int_bounded(10) == 0
            {
                if base.on_ground {
                    let Entity(target_base, _) = world.get_entity(target_id).unwrap();
                    let delta = target_base.pos.xz() - base.pos.xz();
                    let h_dist = delta.length();
                    let h_vel = delta / h_dist * 0.5 * 0.8 + base.vel.xz() * 0.2;
                    base.vel = DVec3::new(h_vel.x, 0.4, h_vel.y);
                }
            } else {
                tick_mob_attack(
                    world,
                    id,
                    entity,
                    target_id,
                    dist_squared,
                    eye_track,
                    should_strafe,
                )
            }
        }
        /// REF: EntityCreeper::attackEntity
        fn tick_creeper_attack(
            world: &mut World,
            id: u32,
            entity: &mut Entity,
            _target_id: u32,
            dist_squared: f64,
            eye_track: bool,
            _should_strafe: &mut bool,
        ) {
            /// Minimum distance from a player to trigger a climb of the spider.
            const IDLE_MAX_DIST_SQUARED: f64 = 3.0 * 3.0;
            /// Maximum distance from a player to trigger a climb of the spider.
            const IGNITED_MAX_DIST_SQUARED: f64 = 7.0 * 7.0;
            #[allow(irrefutable_let_patterns)]
            let Entity(base, BaseKind::Living(_, LivingKind::Creeper(creeper))) = entity
            else {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "internal error: entered unreachable code: {0}",
                            format_args!("invalid argument for this function"),
                        ),
                    );
                };
            };
            let ignited = eye_track
                && (creeper.ignited_time.is_none()
                    && dist_squared < IDLE_MAX_DIST_SQUARED)
                || (creeper.ignited_time.is_some()
                    && dist_squared < IGNITED_MAX_DIST_SQUARED);
            if ignited {
                if creeper.ignited_time.is_none() {
                    world
                        .push_event(Event::Entity {
                            id,
                            inner: EntityEvent::Metadata,
                        });
                }
                let ignited_time = creeper.ignited_time.unwrap_or(0) + 1;
                creeper.ignited_time = Some(ignited_time);
                if ignited_time >= 30 {
                    world.remove_entity(id, "creeper explode");
                    if creeper.powered {
                        world.explode(base.pos, 6.0, false, Some(id));
                    } else {
                        world.explode(base.pos, 3.0, false, Some(id));
                    }
                }
            } else {
                if creeper.ignited_time.is_some() {
                    world
                        .push_event(Event::Entity {
                            id,
                            inner: EntityEvent::Metadata,
                        });
                    creeper.ignited_time = None;
                }
            }
        }
        /// REF: EntitySkeleton::attackEntity
        fn tick_skeleton_attack(
            world: &mut World,
            id: u32,
            entity: &mut Entity,
            target_id: u32,
            dist_squared: f64,
            eye_track: bool,
            should_strafe: &mut bool,
        ) {
            const MAX_DIST_SQUARED: f64 = 10.0 * 10.0;
            if eye_track && dist_squared < MAX_DIST_SQUARED {
                #[allow(irrefutable_let_patterns)]
                let Entity(base, BaseKind::Living(living, LivingKind::Skeleton(_))) = entity
                else {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("invalid argument for this function"),
                            ),
                        );
                    };
                };
                let Entity(target_base, _) = world.get_entity(target_id).unwrap();
                living.attack_time = living.attack_time.saturating_sub(1);
                if living.attack_time == 0 {
                    living.attack_time = 30;
                    let eye_pos = common::calc_eye_pos(base);
                    let target_eye_pos = common::calc_eye_pos(target_base);
                    let arrow = Arrow::new_with(|arrow_base, arrow_projectile, arrow| {
                        let mut dir = target_eye_pos - eye_pos;
                        dir.y += dir.xz().length() * 0.2;
                        let dir = dir.normalize_or_zero();
                        arrow_base.pos = eye_pos + dir * DVec3::new(1.0, 0.0, 1.0);
                        arrow_base.look = base.look;
                        arrow_base.vel = dir;
                        arrow_base.vel
                            += arrow_base.rand.next_gaussian_vec() * 0.0075 * 12.0;
                        arrow_base.vel *= 0.6;
                        arrow_projectile.owner_id = Some(id);
                        arrow.from_player = false;
                    });
                    world.spawn_entity(arrow);
                }
                *should_strafe = true;
            }
        }
    }
    use tick_state::tick_state;
    use tick_ai::tick_ai;
    use tick_attack::tick_attack;
    /// Kind of entity, without actual data. This enumeration can be used to construct a
    /// real entity instance with default values, to be modified later.
    pub enum EntityKind {
        Item,
        Painting,
        Boat,
        Minecart,
        Bobber,
        LightningBolt,
        FallingBlock,
        Tnt,
        Arrow,
        Egg,
        Fireball,
        Snowball,
        Human,
        Ghast,
        Slime,
        Pig,
        Chicken,
        Cow,
        Sheep,
        Squid,
        Wolf,
        Creeper,
        Giant,
        PigZombie,
        Skeleton,
        Spider,
        Zombie,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EntityKind {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    EntityKind::Item => "Item",
                    EntityKind::Painting => "Painting",
                    EntityKind::Boat => "Boat",
                    EntityKind::Minecart => "Minecart",
                    EntityKind::Bobber => "Bobber",
                    EntityKind::LightningBolt => "LightningBolt",
                    EntityKind::FallingBlock => "FallingBlock",
                    EntityKind::Tnt => "Tnt",
                    EntityKind::Arrow => "Arrow",
                    EntityKind::Egg => "Egg",
                    EntityKind::Fireball => "Fireball",
                    EntityKind::Snowball => "Snowball",
                    EntityKind::Human => "Human",
                    EntityKind::Ghast => "Ghast",
                    EntityKind::Slime => "Slime",
                    EntityKind::Pig => "Pig",
                    EntityKind::Chicken => "Chicken",
                    EntityKind::Cow => "Cow",
                    EntityKind::Sheep => "Sheep",
                    EntityKind::Squid => "Squid",
                    EntityKind::Wolf => "Wolf",
                    EntityKind::Creeper => "Creeper",
                    EntityKind::Giant => "Giant",
                    EntityKind::PigZombie => "PigZombie",
                    EntityKind::Skeleton => "Skeleton",
                    EntityKind::Spider => "Spider",
                    EntityKind::Zombie => "Zombie",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EntityKind {
        #[inline]
        fn clone(&self) -> EntityKind {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for EntityKind {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EntityKind {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EntityKind {
        #[inline]
        fn eq(&self, other: &EntityKind) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for EntityKind {}
    #[automatically_derived]
    impl ::core::cmp::Eq for EntityKind {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    /// Category of entity enumeration, this defines various common properties for groups of
    /// entities, such as natural spawning properties.
    pub enum EntityCategory {
        /// All animal entities.
        Animal = 0,
        /// Water animal entities.
        WaterAnimal = 1,
        /// Mob entities.
        Mob = 2,
        /// All remaining entities.
        Other = 3,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EntityCategory {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    EntityCategory::Animal => "Animal",
                    EntityCategory::WaterAnimal => "WaterAnimal",
                    EntityCategory::Mob => "Mob",
                    EntityCategory::Other => "Other",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EntityCategory {
        #[inline]
        fn clone(&self) -> EntityCategory {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for EntityCategory {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EntityCategory {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EntityCategory {
        #[inline]
        fn eq(&self, other: &EntityCategory) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for EntityCategory {}
    #[automatically_derived]
    impl ::core::cmp::Eq for EntityCategory {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    /// Base type that contains all entity types, this is composed of the entity base data,
    /// which is common to all entities, and the base kind that is the first sub division in
    /// entities. Each subdivision in the entity family tree is composed of the family's
    /// common data as the first tuple element, and the kind of entity as the second element.
    pub struct Entity(pub Base, pub BaseKind);
    #[automatically_derived]
    impl ::core::fmt::Debug for Entity {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field2_finish(
                f,
                "Entity",
                &self.0,
                &&self.1,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Entity {
        #[inline]
        fn clone(&self) -> Entity {
            Entity(
                ::core::clone::Clone::clone(&self.0),
                ::core::clone::Clone::clone(&self.1),
            )
        }
    }
    /// Kind of base entity.
    pub enum BaseKind {
        Item(Item),
        Painting(Painting),
        Boat(Boat),
        Minecart(Minecart),
        LightningBolt(LightningBolt),
        FallingBlock(FallingBlock),
        Tnt(Tnt),
        Projectile(Projectile, ProjectileKind),
        Living(Living, LivingKind),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for BaseKind {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                BaseKind::Item(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Item",
                        &__self_0,
                    )
                }
                BaseKind::Painting(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Painting",
                        &__self_0,
                    )
                }
                BaseKind::Boat(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Boat",
                        &__self_0,
                    )
                }
                BaseKind::Minecart(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Minecart",
                        &__self_0,
                    )
                }
                BaseKind::LightningBolt(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LightningBolt",
                        &__self_0,
                    )
                }
                BaseKind::FallingBlock(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "FallingBlock",
                        &__self_0,
                    )
                }
                BaseKind::Tnt(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Tnt",
                        &__self_0,
                    )
                }
                BaseKind::Projectile(__self_0, __self_1) => {
                    ::core::fmt::Formatter::debug_tuple_field2_finish(
                        f,
                        "Projectile",
                        __self_0,
                        &__self_1,
                    )
                }
                BaseKind::Living(__self_0, __self_1) => {
                    ::core::fmt::Formatter::debug_tuple_field2_finish(
                        f,
                        "Living",
                        __self_0,
                        &__self_1,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BaseKind {
        #[inline]
        fn clone(&self) -> BaseKind {
            match self {
                BaseKind::Item(__self_0) => {
                    BaseKind::Item(::core::clone::Clone::clone(__self_0))
                }
                BaseKind::Painting(__self_0) => {
                    BaseKind::Painting(::core::clone::Clone::clone(__self_0))
                }
                BaseKind::Boat(__self_0) => {
                    BaseKind::Boat(::core::clone::Clone::clone(__self_0))
                }
                BaseKind::Minecart(__self_0) => {
                    BaseKind::Minecart(::core::clone::Clone::clone(__self_0))
                }
                BaseKind::LightningBolt(__self_0) => {
                    BaseKind::LightningBolt(::core::clone::Clone::clone(__self_0))
                }
                BaseKind::FallingBlock(__self_0) => {
                    BaseKind::FallingBlock(::core::clone::Clone::clone(__self_0))
                }
                BaseKind::Tnt(__self_0) => {
                    BaseKind::Tnt(::core::clone::Clone::clone(__self_0))
                }
                BaseKind::Projectile(__self_0, __self_1) => {
                    BaseKind::Projectile(
                        ::core::clone::Clone::clone(__self_0),
                        ::core::clone::Clone::clone(__self_1),
                    )
                }
                BaseKind::Living(__self_0, __self_1) => {
                    BaseKind::Living(
                        ::core::clone::Clone::clone(__self_0),
                        ::core::clone::Clone::clone(__self_1),
                    )
                }
            }
        }
    }
    /// Kind of projectile entity.
    pub enum ProjectileKind {
        Arrow(Arrow),
        Egg(Egg),
        Fireball(Fireball),
        Snowball(Snowball),
        Bobber(Bobber),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ProjectileKind {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ProjectileKind::Arrow(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Arrow",
                        &__self_0,
                    )
                }
                ProjectileKind::Egg(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Egg",
                        &__self_0,
                    )
                }
                ProjectileKind::Fireball(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Fireball",
                        &__self_0,
                    )
                }
                ProjectileKind::Snowball(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Snowball",
                        &__self_0,
                    )
                }
                ProjectileKind::Bobber(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Bobber",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ProjectileKind {
        #[inline]
        fn clone(&self) -> ProjectileKind {
            match self {
                ProjectileKind::Arrow(__self_0) => {
                    ProjectileKind::Arrow(::core::clone::Clone::clone(__self_0))
                }
                ProjectileKind::Egg(__self_0) => {
                    ProjectileKind::Egg(::core::clone::Clone::clone(__self_0))
                }
                ProjectileKind::Fireball(__self_0) => {
                    ProjectileKind::Fireball(::core::clone::Clone::clone(__self_0))
                }
                ProjectileKind::Snowball(__self_0) => {
                    ProjectileKind::Snowball(::core::clone::Clone::clone(__self_0))
                }
                ProjectileKind::Bobber(__self_0) => {
                    ProjectileKind::Bobber(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    /// Kind of living entity, this include animals and mobs.
    pub enum LivingKind {
        Human(Human),
        Ghast(Ghast),
        Slime(Slime),
        Pig(Pig),
        Chicken(Chicken),
        Cow(Cow),
        Sheep(Sheep),
        Squid(Squid),
        Wolf(Wolf),
        Creeper(Creeper),
        Giant(Giant),
        PigZombie(PigZombie),
        Skeleton(Skeleton),
        Spider(Spider),
        Zombie(Zombie),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LivingKind {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                LivingKind::Human(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Human",
                        &__self_0,
                    )
                }
                LivingKind::Ghast(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ghast",
                        &__self_0,
                    )
                }
                LivingKind::Slime(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Slime",
                        &__self_0,
                    )
                }
                LivingKind::Pig(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Pig",
                        &__self_0,
                    )
                }
                LivingKind::Chicken(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Chicken",
                        &__self_0,
                    )
                }
                LivingKind::Cow(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Cow",
                        &__self_0,
                    )
                }
                LivingKind::Sheep(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Sheep",
                        &__self_0,
                    )
                }
                LivingKind::Squid(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Squid",
                        &__self_0,
                    )
                }
                LivingKind::Wolf(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Wolf",
                        &__self_0,
                    )
                }
                LivingKind::Creeper(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Creeper",
                        &__self_0,
                    )
                }
                LivingKind::Giant(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Giant",
                        &__self_0,
                    )
                }
                LivingKind::PigZombie(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "PigZombie",
                        &__self_0,
                    )
                }
                LivingKind::Skeleton(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Skeleton",
                        &__self_0,
                    )
                }
                LivingKind::Spider(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Spider",
                        &__self_0,
                    )
                }
                LivingKind::Zombie(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Zombie",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LivingKind {
        #[inline]
        fn clone(&self) -> LivingKind {
            match self {
                LivingKind::Human(__self_0) => {
                    LivingKind::Human(::core::clone::Clone::clone(__self_0))
                }
                LivingKind::Ghast(__self_0) => {
                    LivingKind::Ghast(::core::clone::Clone::clone(__self_0))
                }
                LivingKind::Slime(__self_0) => {
                    LivingKind::Slime(::core::clone::Clone::clone(__self_0))
                }
                LivingKind::Pig(__self_0) => {
                    LivingKind::Pig(::core::clone::Clone::clone(__self_0))
                }
                LivingKind::Chicken(__self_0) => {
                    LivingKind::Chicken(::core::clone::Clone::clone(__self_0))
                }
                LivingKind::Cow(__self_0) => {
                    LivingKind::Cow(::core::clone::Clone::clone(__self_0))
                }
                LivingKind::Sheep(__self_0) => {
                    LivingKind::Sheep(::core::clone::Clone::clone(__self_0))
                }
                LivingKind::Squid(__self_0) => {
                    LivingKind::Squid(::core::clone::Clone::clone(__self_0))
                }
                LivingKind::Wolf(__self_0) => {
                    LivingKind::Wolf(::core::clone::Clone::clone(__self_0))
                }
                LivingKind::Creeper(__self_0) => {
                    LivingKind::Creeper(::core::clone::Clone::clone(__self_0))
                }
                LivingKind::Giant(__self_0) => {
                    LivingKind::Giant(::core::clone::Clone::clone(__self_0))
                }
                LivingKind::PigZombie(__self_0) => {
                    LivingKind::PigZombie(::core::clone::Clone::clone(__self_0))
                }
                LivingKind::Skeleton(__self_0) => {
                    LivingKind::Skeleton(::core::clone::Clone::clone(__self_0))
                }
                LivingKind::Spider(__self_0) => {
                    LivingKind::Spider(::core::clone::Clone::clone(__self_0))
                }
                LivingKind::Zombie(__self_0) => {
                    LivingKind::Zombie(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    /// The base data common to all entities.
    pub struct Base {
        /// Tell if this entity is persistent or not. A persistent entity is saved with its
        /// chunk, but non-persistent entities are no saved. For example, all player entities
        /// are typically non-persistent because these are not real entities. Some entities
        /// cannot be persistent as they are not supported by the Notchian serialization.
        pub persistent: bool,
        /// The last size that was used when recomputing the bounding box based on the
        /// position, we keep it in order to check that the bounding box don't shift too far
        /// from it because of rounding errors, and also to keep the height center. This is
        /// updated with the bounding box by `tick_base` method when entity isn't coherent.
        pub size: Size,
        /// The bounding box is defining the actual position from the size of the entity, the
        /// actual position of the entity is derived from it. This is recomputed with the size
        /// by `tick_base` method when entity isn't coherent.
        pub bb: BoundingBox,
        /// The current entity position, it is derived from the bounding box and size, it can
        /// be forced by setting it and then calling `resize` on entity.
        pub pos: DVec3,
        /// True if an entity pos event should be sent after update.
        /// The current entity velocity.
        pub vel: DVec3,
        /// Yaw a pitch angles of this entity's look. These are in radians with no range
        /// guarantee, although this will often be normalized in 2pi range. The yaw angle
        /// in Minecraft is set to zero when pointing toward PosZ, and then rotate clockwise
        /// to NegX, NegZ and then PosX.
        ///
        /// Yaw is X and pitch is Y.
        pub look: Vec2,
        /// Lifetime of the entity since it was spawned in the world, it increase at every
        /// world tick.
        pub lifetime: u32,
        /// Height of the eyes, this is an Y offset from the position.
        pub eye_height: f32,
        /// Set to true when the entity is able to pickup surrounding items and arrows on
        /// ground, if so a pickup event is triggered, but the item or arrow is not actually
        /// picked up, it's up to the event listener to decide. Disabled by default.
        pub can_pickup: bool,
        /// No clip is used to disable collision check when moving the entity, if no clip is
        /// false, then the entity will be constrained by bounding box in its way.
        pub no_clip: bool,
        /// Is this entity currently on ground.
        pub on_ground: bool,
        /// Is this entity in water.
        pub in_water: bool,
        /// Is this entity in lava.
        pub in_lava: bool,
        /// Total fall distance, will be used upon contact to calculate damages to deal.
        pub fall_distance: f32,
        /// Remaining fire ticks.
        pub fire_time: u32,
        /// Remaining air ticks to breathe.
        pub air_time: u32,
        /// A list of hurts to apply to the entity.
        pub hurt: Vec<Hurt>,
        /// If this entity is ridden, this contains its entity id.
        pub rider_id: Option<u32>,
        /// If this entity has thrown a bobber for fishing, this contains its entity id.
        pub bobber_id: Option<u32>,
        /// The random number generator used for this entity.
        pub rand: JavaRandom,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Base {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "persistent",
                "size",
                "bb",
                "pos",
                "vel",
                "look",
                "lifetime",
                "eye_height",
                "can_pickup",
                "no_clip",
                "on_ground",
                "in_water",
                "in_lava",
                "fall_distance",
                "fire_time",
                "air_time",
                "hurt",
                "rider_id",
                "bobber_id",
                "rand",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.persistent,
                &self.size,
                &self.bb,
                &self.pos,
                &self.vel,
                &self.look,
                &self.lifetime,
                &self.eye_height,
                &self.can_pickup,
                &self.no_clip,
                &self.on_ground,
                &self.in_water,
                &self.in_lava,
                &self.fall_distance,
                &self.fire_time,
                &self.air_time,
                &self.hurt,
                &self.rider_id,
                &self.bobber_id,
                &&self.rand,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "Base", names, values)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Base {
        #[inline]
        fn clone(&self) -> Base {
            Base {
                persistent: ::core::clone::Clone::clone(&self.persistent),
                size: ::core::clone::Clone::clone(&self.size),
                bb: ::core::clone::Clone::clone(&self.bb),
                pos: ::core::clone::Clone::clone(&self.pos),
                vel: ::core::clone::Clone::clone(&self.vel),
                look: ::core::clone::Clone::clone(&self.look),
                lifetime: ::core::clone::Clone::clone(&self.lifetime),
                eye_height: ::core::clone::Clone::clone(&self.eye_height),
                can_pickup: ::core::clone::Clone::clone(&self.can_pickup),
                no_clip: ::core::clone::Clone::clone(&self.no_clip),
                on_ground: ::core::clone::Clone::clone(&self.on_ground),
                in_water: ::core::clone::Clone::clone(&self.in_water),
                in_lava: ::core::clone::Clone::clone(&self.in_lava),
                fall_distance: ::core::clone::Clone::clone(&self.fall_distance),
                fire_time: ::core::clone::Clone::clone(&self.fire_time),
                air_time: ::core::clone::Clone::clone(&self.air_time),
                hurt: ::core::clone::Clone::clone(&self.hurt),
                rider_id: ::core::clone::Clone::clone(&self.rider_id),
                bobber_id: ::core::clone::Clone::clone(&self.bobber_id),
                rand: ::core::clone::Clone::clone(&self.rand),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Base {
        #[inline]
        fn default() -> Base {
            Base {
                persistent: ::core::default::Default::default(),
                size: ::core::default::Default::default(),
                bb: ::core::default::Default::default(),
                pos: ::core::default::Default::default(),
                vel: ::core::default::Default::default(),
                look: ::core::default::Default::default(),
                lifetime: ::core::default::Default::default(),
                eye_height: ::core::default::Default::default(),
                can_pickup: ::core::default::Default::default(),
                no_clip: ::core::default::Default::default(),
                on_ground: ::core::default::Default::default(),
                in_water: ::core::default::Default::default(),
                in_lava: ::core::default::Default::default(),
                fall_distance: ::core::default::Default::default(),
                fire_time: ::core::default::Default::default(),
                air_time: ::core::default::Default::default(),
                hurt: ::core::default::Default::default(),
                rider_id: ::core::default::Default::default(),
                bobber_id: ::core::default::Default::default(),
                rand: ::core::default::Default::default(),
            }
        }
    }
    /// Hurt data to apply on the next tick to the entity.
    pub struct Hurt {
        /// The damage to deal.
        pub damage: u16,
        /// When damage is dealt, this optionally contains the entity id at the origin of the
        /// hit in order to apply knock back to the entity if needed.
        pub origin_id: Option<u32>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Hurt {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Hurt",
                "damage",
                &self.damage,
                "origin_id",
                &&self.origin_id,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Hurt {
        #[inline]
        fn clone(&self) -> Hurt {
            Hurt {
                damage: ::core::clone::Clone::clone(&self.damage),
                origin_id: ::core::clone::Clone::clone(&self.origin_id),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Hurt {
        #[inline]
        fn default() -> Hurt {
            Hurt {
                damage: ::core::default::Default::default(),
                origin_id: ::core::default::Default::default(),
            }
        }
    }
    /// The data common to all living entities.
    pub struct Living {
        /// Set to true if an entity is artificial, as opposed to natural. If not artificial,
        /// an entity is despawned when too far from the closest player (maximum distance of
        /// 128.0 blocks).
        pub artificial: bool,
        /// The health.
        pub health: u16,
        /// The last damage inflicted to the entity during `hurt_time`, this is used to only
        /// damage for the maximum damage inflicted while `hurt_time` is not zero.
        pub hurt_last_damage: u16,
        /// Hurt countdown, read `hurt_damage` documentation.
        pub hurt_time: u16,
        /// TBD.
        pub attack_time: u16,
        /// The death timer, increasing each tick when no health, after 20 ticks the entity
        /// is definitely removed from the world.
        pub death_time: u16,
        /// The strafing acceleration.
        pub accel_strafing: f32,
        /// The forward acceleration.
        pub accel_forward: f32,
        /// Velocity of the look's yaw axis.
        pub yaw_velocity: f32,
        /// True if this entity is trying to jump.
        pub jumping: bool,
        /// If this entity is looking at another one.
        pub look_target: Option<LookTarget>,
        /// If this entity is attacking another one.
        pub attack_target: Option<u32>,
        /// The path this creature needs to follow.
        pub path: Option<Path>,
        /// This timer is used on entities that are wandering too far from players or that
        /// take hurt damages. This is only used on entities that are AI ticked and on non
        /// persistent living entities. When this time reaches 600 and there are players in
        /// the 128.0 block distance, then this entity has 1/800 chance of despawning.
        pub wander_time: u16,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Living {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "artificial",
                "health",
                "hurt_last_damage",
                "hurt_time",
                "attack_time",
                "death_time",
                "accel_strafing",
                "accel_forward",
                "yaw_velocity",
                "jumping",
                "look_target",
                "attack_target",
                "path",
                "wander_time",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.artificial,
                &self.health,
                &self.hurt_last_damage,
                &self.hurt_time,
                &self.attack_time,
                &self.death_time,
                &self.accel_strafing,
                &self.accel_forward,
                &self.yaw_velocity,
                &self.jumping,
                &self.look_target,
                &self.attack_target,
                &self.path,
                &&self.wander_time,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "Living",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Living {
        #[inline]
        fn clone(&self) -> Living {
            Living {
                artificial: ::core::clone::Clone::clone(&self.artificial),
                health: ::core::clone::Clone::clone(&self.health),
                hurt_last_damage: ::core::clone::Clone::clone(&self.hurt_last_damage),
                hurt_time: ::core::clone::Clone::clone(&self.hurt_time),
                attack_time: ::core::clone::Clone::clone(&self.attack_time),
                death_time: ::core::clone::Clone::clone(&self.death_time),
                accel_strafing: ::core::clone::Clone::clone(&self.accel_strafing),
                accel_forward: ::core::clone::Clone::clone(&self.accel_forward),
                yaw_velocity: ::core::clone::Clone::clone(&self.yaw_velocity),
                jumping: ::core::clone::Clone::clone(&self.jumping),
                look_target: ::core::clone::Clone::clone(&self.look_target),
                attack_target: ::core::clone::Clone::clone(&self.attack_target),
                path: ::core::clone::Clone::clone(&self.path),
                wander_time: ::core::clone::Clone::clone(&self.wander_time),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Living {
        #[inline]
        fn default() -> Living {
            Living {
                artificial: ::core::default::Default::default(),
                health: ::core::default::Default::default(),
                hurt_last_damage: ::core::default::Default::default(),
                hurt_time: ::core::default::Default::default(),
                attack_time: ::core::default::Default::default(),
                death_time: ::core::default::Default::default(),
                accel_strafing: ::core::default::Default::default(),
                accel_forward: ::core::default::Default::default(),
                yaw_velocity: ::core::default::Default::default(),
                jumping: ::core::default::Default::default(),
                look_target: ::core::default::Default::default(),
                attack_target: ::core::default::Default::default(),
                path: ::core::default::Default::default(),
                wander_time: ::core::default::Default::default(),
            }
        }
    }
    /// The data common to all projectile entities.
    pub struct Projectile {
        /// The state of the projectile, none when in air, set to block/metadata when in.
        pub state: Option<ProjectileHit>,
        /// This is the number of ticks the projectile has been in its current state.
        pub state_time: u16,
        /// Some entity id if this projectile was thrown by an entity, this is used to avoid
        /// hitting the owner.
        pub owner_id: Option<u32>,
        /// Current shaking of the projectile.
        pub shake: u8,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Projectile {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Projectile",
                "state",
                &self.state,
                "state_time",
                &self.state_time,
                "owner_id",
                &self.owner_id,
                "shake",
                &&self.shake,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Projectile {
        #[inline]
        fn clone(&self) -> Projectile {
            Projectile {
                state: ::core::clone::Clone::clone(&self.state),
                state_time: ::core::clone::Clone::clone(&self.state_time),
                owner_id: ::core::clone::Clone::clone(&self.owner_id),
                shake: ::core::clone::Clone::clone(&self.shake),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Projectile {
        #[inline]
        fn default() -> Projectile {
            Projectile {
                state: ::core::default::Default::default(),
                state_time: ::core::default::Default::default(),
                owner_id: ::core::default::Default::default(),
                shake: ::core::default::Default::default(),
            }
        }
    }
    pub struct ProjectileHit {
        /// The block position the projectile is in.
        pub pos: IVec3,
        /// The block the projectile is in.
        pub block: u8,
        /// The block metadata the projectile is in.
        pub metadata: u8,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ProjectileHit {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ProjectileHit",
                "pos",
                &self.pos,
                "block",
                &self.block,
                "metadata",
                &&self.metadata,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ProjectileHit {}
    #[automatically_derived]
    impl ::core::clone::Clone for ProjectileHit {
        #[inline]
        fn clone(&self) -> ProjectileHit {
            let _: ::core::clone::AssertParamIsClone<IVec3>;
            let _: ::core::clone::AssertParamIsClone<u8>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for ProjectileHit {
        #[inline]
        fn default() -> ProjectileHit {
            ProjectileHit {
                pos: ::core::default::Default::default(),
                block: ::core::default::Default::default(),
                metadata: ::core::default::Default::default(),
            }
        }
    }
    pub struct Item {
        /// The item stack represented by this entity.
        pub stack: ItemStack,
        /// The item health.
        pub health: u16,
        /// Remaining time for this item to be picked up by entities that have `can_pickup`.
        pub frozen_time: u32,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Item {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Item",
                "stack",
                &self.stack,
                "health",
                &self.health,
                "frozen_time",
                &&self.frozen_time,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Item {
        #[inline]
        fn clone(&self) -> Item {
            Item {
                stack: ::core::clone::Clone::clone(&self.stack),
                health: ::core::clone::Clone::clone(&self.health),
                frozen_time: ::core::clone::Clone::clone(&self.frozen_time),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Item {
        #[inline]
        fn default() -> Item {
            Item {
                stack: ::core::default::Default::default(),
                health: ::core::default::Default::default(),
                frozen_time: ::core::default::Default::default(),
            }
        }
    }
    pub struct Painting {
        /// Block position of this painting.
        pub block_pos: IVec3,
        /// Orientation of this painting at block position.
        pub orientation: PaintingOrientation,
        /// The art of the painting, which define its size.
        pub art: PaintingArt,
        /// This timer is used to repeatedly check if the painting is at a valid position.
        pub check_valid_time: u8,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Painting {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Painting",
                "block_pos",
                &self.block_pos,
                "orientation",
                &self.orientation,
                "art",
                &self.art,
                "check_valid_time",
                &&self.check_valid_time,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Painting {
        #[inline]
        fn clone(&self) -> Painting {
            Painting {
                block_pos: ::core::clone::Clone::clone(&self.block_pos),
                orientation: ::core::clone::Clone::clone(&self.orientation),
                art: ::core::clone::Clone::clone(&self.art),
                check_valid_time: ::core::clone::Clone::clone(&self.check_valid_time),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Painting {
        #[inline]
        fn default() -> Painting {
            Painting {
                block_pos: ::core::default::Default::default(),
                orientation: ::core::default::Default::default(),
                art: ::core::default::Default::default(),
                check_valid_time: ::core::default::Default::default(),
            }
        }
    }
    pub enum PaintingOrientation {
        #[default]
        NegX,
        PosX,
        NegZ,
        PosZ,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PaintingOrientation {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    PaintingOrientation::NegX => "NegX",
                    PaintingOrientation::PosX => "PosX",
                    PaintingOrientation::NegZ => "NegZ",
                    PaintingOrientation::PosZ => "PosZ",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PaintingOrientation {
        #[inline]
        fn clone(&self) -> PaintingOrientation {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for PaintingOrientation {}
    #[automatically_derived]
    impl ::core::default::Default for PaintingOrientation {
        #[inline]
        fn default() -> PaintingOrientation {
            Self::NegX
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PaintingOrientation {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PaintingOrientation {
        #[inline]
        fn eq(&self, other: &PaintingOrientation) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for PaintingOrientation {}
    #[automatically_derived]
    impl ::core::cmp::Eq for PaintingOrientation {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    pub enum PaintingArt {
        #[default]
        Kebab,
        Aztec,
        Alban,
        Aztec2,
        Bomb,
        Plant,
        Wasteland,
        Pool,
        Courbet,
        Sea,
        Sunset,
        Creebet,
        Wanderer,
        Graham,
        Match,
        Bust,
        Stage,
        Void,
        SkullAndRoses,
        Fighters,
        Pointer,
        Pigscene,
        BurningSkull,
        Skeleton,
        DonkeyKong,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PaintingArt {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    PaintingArt::Kebab => "Kebab",
                    PaintingArt::Aztec => "Aztec",
                    PaintingArt::Alban => "Alban",
                    PaintingArt::Aztec2 => "Aztec2",
                    PaintingArt::Bomb => "Bomb",
                    PaintingArt::Plant => "Plant",
                    PaintingArt::Wasteland => "Wasteland",
                    PaintingArt::Pool => "Pool",
                    PaintingArt::Courbet => "Courbet",
                    PaintingArt::Sea => "Sea",
                    PaintingArt::Sunset => "Sunset",
                    PaintingArt::Creebet => "Creebet",
                    PaintingArt::Wanderer => "Wanderer",
                    PaintingArt::Graham => "Graham",
                    PaintingArt::Match => "Match",
                    PaintingArt::Bust => "Bust",
                    PaintingArt::Stage => "Stage",
                    PaintingArt::Void => "Void",
                    PaintingArt::SkullAndRoses => "SkullAndRoses",
                    PaintingArt::Fighters => "Fighters",
                    PaintingArt::Pointer => "Pointer",
                    PaintingArt::Pigscene => "Pigscene",
                    PaintingArt::BurningSkull => "BurningSkull",
                    PaintingArt::Skeleton => "Skeleton",
                    PaintingArt::DonkeyKong => "DonkeyKong",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PaintingArt {
        #[inline]
        fn clone(&self) -> PaintingArt {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for PaintingArt {}
    #[automatically_derived]
    impl ::core::default::Default for PaintingArt {
        #[inline]
        fn default() -> PaintingArt {
            Self::Kebab
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PaintingArt {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PaintingArt {
        #[inline]
        fn eq(&self, other: &PaintingArt) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for PaintingArt {}
    #[automatically_derived]
    impl ::core::cmp::Eq for PaintingArt {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    pub struct Boat {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Boat {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Boat")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Boat {
        #[inline]
        fn clone(&self) -> Boat {
            Boat {}
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Boat {
        #[inline]
        fn default() -> Boat {
            Boat {}
        }
    }
    pub enum Minecart {
        /// A normal minecart for living entity transportation.
        #[default]
        Normal,
        /// A chest minecart for storing a single chest of items.
        Chest {
            /// The inventory storing the items.
            inv: Box<[ItemStack; 27]>,
        },
        /// A furnace minecart that push when fueled.
        Furnace {
            push_x: f64,
            push_z: f64,
            /// Remaining fuel amount.
            fuel: u32,
        },
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Minecart {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Minecart::Normal => ::core::fmt::Formatter::write_str(f, "Normal"),
                Minecart::Chest { inv: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Chest",
                        "inv",
                        &__self_0,
                    )
                }
                Minecart::Furnace {
                    push_x: __self_0,
                    push_z: __self_1,
                    fuel: __self_2,
                } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Furnace",
                        "push_x",
                        __self_0,
                        "push_z",
                        __self_1,
                        "fuel",
                        &__self_2,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Minecart {
        #[inline]
        fn clone(&self) -> Minecart {
            match self {
                Minecart::Normal => Minecart::Normal,
                Minecart::Chest { inv: __self_0 } => {
                    Minecart::Chest {
                        inv: ::core::clone::Clone::clone(__self_0),
                    }
                }
                Minecart::Furnace {
                    push_x: __self_0,
                    push_z: __self_1,
                    fuel: __self_2,
                } => {
                    Minecart::Furnace {
                        push_x: ::core::clone::Clone::clone(__self_0),
                        push_z: ::core::clone::Clone::clone(__self_1),
                        fuel: ::core::clone::Clone::clone(__self_2),
                    }
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Minecart {
        #[inline]
        fn default() -> Minecart {
            Self::Normal
        }
    }
    pub struct Bobber {
        /// Some entity id if this bobber is attached to an entity instead of floating in
        /// water.
        pub attached_id: Option<u32>,
        /// The remaining time for the bobber to be caught and have a chance of getting a
        /// fish.
        pub catch_time: u16,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Bobber {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Bobber",
                "attached_id",
                &self.attached_id,
                "catch_time",
                &&self.catch_time,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Bobber {
        #[inline]
        fn clone(&self) -> Bobber {
            Bobber {
                attached_id: ::core::clone::Clone::clone(&self.attached_id),
                catch_time: ::core::clone::Clone::clone(&self.catch_time),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Bobber {
        #[inline]
        fn default() -> Bobber {
            Bobber {
                attached_id: ::core::default::Default::default(),
                catch_time: ::core::default::Default::default(),
            }
        }
    }
    pub struct LightningBolt {}
    #[automatically_derived]
    impl ::core::fmt::Debug for LightningBolt {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "LightningBolt")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LightningBolt {
        #[inline]
        fn clone(&self) -> LightningBolt {
            LightningBolt {}
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for LightningBolt {
        #[inline]
        fn default() -> LightningBolt {
            LightningBolt {}
        }
    }
    pub struct FallingBlock {
        /// Number of ticks since this block is falling.
        pub fall_time: u32,
        /// The falling block id.
        pub block_id: u8,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FallingBlock {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "FallingBlock",
                "fall_time",
                &self.fall_time,
                "block_id",
                &&self.block_id,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FallingBlock {
        #[inline]
        fn clone(&self) -> FallingBlock {
            FallingBlock {
                fall_time: ::core::clone::Clone::clone(&self.fall_time),
                block_id: ::core::clone::Clone::clone(&self.block_id),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for FallingBlock {
        #[inline]
        fn default() -> FallingBlock {
            FallingBlock {
                fall_time: ::core::default::Default::default(),
                block_id: ::core::default::Default::default(),
            }
        }
    }
    pub struct Tnt {
        pub fuse_time: u32,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Tnt {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Tnt",
                "fuse_time",
                &&self.fuse_time,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Tnt {
        #[inline]
        fn clone(&self) -> Tnt {
            Tnt {
                fuse_time: ::core::clone::Clone::clone(&self.fuse_time),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Tnt {
        #[inline]
        fn default() -> Tnt {
            Tnt {
                fuse_time: ::core::default::Default::default(),
            }
        }
    }
    pub struct Arrow {
        /// Set to true for arrows that are sent by players and therefore can be picked up.
        pub from_player: bool,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Arrow {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Arrow",
                "from_player",
                &&self.from_player,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Arrow {
        #[inline]
        fn clone(&self) -> Arrow {
            Arrow {
                from_player: ::core::clone::Clone::clone(&self.from_player),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Arrow {
        #[inline]
        fn default() -> Arrow {
            Arrow {
                from_player: ::core::default::Default::default(),
            }
        }
    }
    pub struct Egg {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Egg {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Egg")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Egg {
        #[inline]
        fn clone(&self) -> Egg {
            Egg {}
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Egg {
        #[inline]
        fn default() -> Egg {
            Egg {}
        }
    }
    pub struct Fireball {
        /// Acceleration to that fireball.
        pub accel: DVec3,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Fireball {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Fireball",
                "accel",
                &&self.accel,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Fireball {
        #[inline]
        fn clone(&self) -> Fireball {
            Fireball {
                accel: ::core::clone::Clone::clone(&self.accel),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Fireball {
        #[inline]
        fn default() -> Fireball {
            Fireball {
                accel: ::core::default::Default::default(),
            }
        }
    }
    pub struct Snowball {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Snowball {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Snowball")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Snowball {
        #[inline]
        fn clone(&self) -> Snowball {
            Snowball {}
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Snowball {
        #[inline]
        fn default() -> Snowball {
            Snowball {}
        }
    }
    pub struct Human {
        /// The player username.
        pub username: String,
        /// True when the player is sleeping.
        pub sleeping: bool,
        /// True when the player is sneaking.
        pub sneaking: bool,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Human {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Human",
                "username",
                &self.username,
                "sleeping",
                &self.sleeping,
                "sneaking",
                &&self.sneaking,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Human {
        #[inline]
        fn clone(&self) -> Human {
            Human {
                username: ::core::clone::Clone::clone(&self.username),
                sleeping: ::core::clone::Clone::clone(&self.sleeping),
                sneaking: ::core::clone::Clone::clone(&self.sneaking),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Human {
        #[inline]
        fn default() -> Human {
            Human {
                username: ::core::default::Default::default(),
                sleeping: ::core::default::Default::default(),
                sneaking: ::core::default::Default::default(),
            }
        }
    }
    pub struct Ghast {
        /// The ghast waypoint defaults to zero.
        pub waypoint: DVec3,
        /// Remaining time before changing the target waypoint of the ghast.
        pub waypoint_check_time: u8,
        /// Remaining time before searching an attack target again.
        pub attack_target_time: u8,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Ghast {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Ghast",
                "waypoint",
                &self.waypoint,
                "waypoint_check_time",
                &self.waypoint_check_time,
                "attack_target_time",
                &&self.attack_target_time,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Ghast {
        #[inline]
        fn clone(&self) -> Ghast {
            Ghast {
                waypoint: ::core::clone::Clone::clone(&self.waypoint),
                waypoint_check_time: ::core::clone::Clone::clone(
                    &self.waypoint_check_time,
                ),
                attack_target_time: ::core::clone::Clone::clone(&self.attack_target_time),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Ghast {
        #[inline]
        fn default() -> Ghast {
            Ghast {
                waypoint: ::core::default::Default::default(),
                waypoint_check_time: ::core::default::Default::default(),
                attack_target_time: ::core::default::Default::default(),
            }
        }
    }
    pub struct Slime {
        /// Size of the slime, this is a bit different because here the size is initially
        /// at 0 and this is equivalent to 1 in Notchian implementation.
        pub size: u8,
        /// Remaining time before jumping.
        pub jump_remaining_time: u32,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Slime {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Slime",
                "size",
                &self.size,
                "jump_remaining_time",
                &&self.jump_remaining_time,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Slime {
        #[inline]
        fn clone(&self) -> Slime {
            Slime {
                size: ::core::clone::Clone::clone(&self.size),
                jump_remaining_time: ::core::clone::Clone::clone(
                    &self.jump_remaining_time,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Slime {
        #[inline]
        fn default() -> Slime {
            Slime {
                size: ::core::default::Default::default(),
                jump_remaining_time: ::core::default::Default::default(),
            }
        }
    }
    pub struct Pig {
        /// True when the pig has a saddle.
        pub saddle: bool,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Pig {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Pig",
                "saddle",
                &&self.saddle,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Pig {
        #[inline]
        fn clone(&self) -> Pig {
            Pig {
                saddle: ::core::clone::Clone::clone(&self.saddle),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Pig {
        #[inline]
        fn default() -> Pig {
            Pig {
                saddle: ::core::default::Default::default(),
            }
        }
    }
    pub struct Chicken {
        /// Ticks remaining until this chicken lays an egg.
        pub next_egg_ticks: u32,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Chicken {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Chicken",
                "next_egg_ticks",
                &&self.next_egg_ticks,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Chicken {
        #[inline]
        fn clone(&self) -> Chicken {
            Chicken {
                next_egg_ticks: ::core::clone::Clone::clone(&self.next_egg_ticks),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Chicken {
        #[inline]
        fn default() -> Chicken {
            Chicken {
                next_egg_ticks: ::core::default::Default::default(),
            }
        }
    }
    pub struct Cow {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Cow {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Cow")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Cow {
        #[inline]
        fn clone(&self) -> Cow {
            Cow {}
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Cow {
        #[inline]
        fn default() -> Cow {
            Cow {}
        }
    }
    pub struct Sheep {
        pub sheared: bool,
        pub color: u8,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Sheep {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Sheep",
                "sheared",
                &self.sheared,
                "color",
                &&self.color,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Sheep {
        #[inline]
        fn clone(&self) -> Sheep {
            Sheep {
                sheared: ::core::clone::Clone::clone(&self.sheared),
                color: ::core::clone::Clone::clone(&self.color),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Sheep {
        #[inline]
        fn default() -> Sheep {
            Sheep {
                sheared: ::core::default::Default::default(),
                color: ::core::default::Default::default(),
            }
        }
    }
    pub struct Squid {
        /// Animation progress for the squid.
        pub animation: f32,
        /// Speed of the animation.
        pub animation_speed: f32,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Squid {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Squid",
                "animation",
                &self.animation,
                "animation_speed",
                &&self.animation_speed,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Squid {
        #[inline]
        fn clone(&self) -> Squid {
            Squid {
                animation: ::core::clone::Clone::clone(&self.animation),
                animation_speed: ::core::clone::Clone::clone(&self.animation_speed),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Squid {
        #[inline]
        fn default() -> Squid {
            Squid {
                animation: ::core::default::Default::default(),
                animation_speed: ::core::default::Default::default(),
            }
        }
    }
    pub struct Wolf {
        pub angry: bool,
        pub sitting: bool,
        pub owner: Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Wolf {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Wolf",
                "angry",
                &self.angry,
                "sitting",
                &self.sitting,
                "owner",
                &&self.owner,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Wolf {
        #[inline]
        fn clone(&self) -> Wolf {
            Wolf {
                angry: ::core::clone::Clone::clone(&self.angry),
                sitting: ::core::clone::Clone::clone(&self.sitting),
                owner: ::core::clone::Clone::clone(&self.owner),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Wolf {
        #[inline]
        fn default() -> Wolf {
            Wolf {
                angry: ::core::default::Default::default(),
                sitting: ::core::default::Default::default(),
                owner: ::core::default::Default::default(),
            }
        }
    }
    pub struct Creeper {
        /// True when the creeper is powered.
        pub powered: bool,
        /// Set to some time when the creeper is ignited.
        pub ignited_time: Option<u16>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Creeper {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Creeper",
                "powered",
                &self.powered,
                "ignited_time",
                &&self.ignited_time,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Creeper {
        #[inline]
        fn clone(&self) -> Creeper {
            Creeper {
                powered: ::core::clone::Clone::clone(&self.powered),
                ignited_time: ::core::clone::Clone::clone(&self.ignited_time),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Creeper {
        #[inline]
        fn default() -> Creeper {
            Creeper {
                powered: ::core::default::Default::default(),
                ignited_time: ::core::default::Default::default(),
            }
        }
    }
    pub struct Giant {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Giant {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Giant")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Giant {
        #[inline]
        fn clone(&self) -> Giant {
            Giant {}
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Giant {
        #[inline]
        fn default() -> Giant {
            Giant {}
        }
    }
    pub struct PigZombie {
        pub anger: bool,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PigZombie {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "PigZombie",
                "anger",
                &&self.anger,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PigZombie {
        #[inline]
        fn clone(&self) -> PigZombie {
            PigZombie {
                anger: ::core::clone::Clone::clone(&self.anger),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for PigZombie {
        #[inline]
        fn default() -> PigZombie {
            PigZombie {
                anger: ::core::default::Default::default(),
            }
        }
    }
    pub struct Skeleton {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Skeleton {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Skeleton")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Skeleton {
        #[inline]
        fn clone(&self) -> Skeleton {
            Skeleton {}
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Skeleton {
        #[inline]
        fn default() -> Skeleton {
            Skeleton {}
        }
    }
    pub struct Spider {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Spider {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Spider")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Spider {
        #[inline]
        fn clone(&self) -> Spider {
            Spider {}
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Spider {
        #[inline]
        fn default() -> Spider {
            Spider {}
        }
    }
    pub struct Zombie {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Zombie {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Zombie")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Zombie {
        #[inline]
        fn clone(&self) -> Zombie {
            Zombie {}
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Zombie {
        #[inline]
        fn default() -> Zombie {
            Zombie {}
        }
    }
    /// Size of an entity, used to update each entity bounding box prior to ticking if
    /// relevant.
    pub struct Size {
        /// Width of the bounding box, centered on the X/Z coordinates.
        pub width: f32,
        /// Height of the bounding box.
        pub height: f32,
        /// Define the center of the bounding box on Y axis.
        pub center: f32,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Size {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Size",
                "width",
                &self.width,
                "height",
                &self.height,
                "center",
                &&self.center,
            )
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Size {
        #[inline]
        fn default() -> Size {
            Size {
                width: ::core::default::Default::default(),
                height: ::core::default::Default::default(),
                center: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Size {
        #[inline]
        fn clone(&self) -> Size {
            let _: ::core::clone::AssertParamIsClone<f32>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Size {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Size {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Size {
        #[inline]
        fn eq(&self, other: &Size) -> bool {
            self.width == other.width && self.height == other.height
                && self.center == other.center
        }
    }
    impl Size {
        /// New size with the Y position at the bottom center of the bounding box.
        pub fn new(width: f32, height: f32) -> Self {
            Self { width, height, center: 0.0 }
        }
        /// New size with the Y position at the center of the bounding box.
        pub fn new_centered(width: f32, height: f32) -> Self {
            Self {
                width,
                height,
                center: height / 2.0,
            }
        }
    }
    /// Define a target for an entity to look at.
    pub struct LookTarget {
        /// The entity id to look at.
        pub entity_id: u32,
        /// Ticks remaining before stop looking at it.
        pub remaining_time: u32,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LookTarget {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "LookTarget",
                "entity_id",
                &self.entity_id,
                "remaining_time",
                &&self.remaining_time,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LookTarget {
        #[inline]
        fn clone(&self) -> LookTarget {
            LookTarget {
                entity_id: ::core::clone::Clone::clone(&self.entity_id),
                remaining_time: ::core::clone::Clone::clone(&self.remaining_time),
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for LookTarget {
        #[inline]
        fn default() -> LookTarget {
            LookTarget {
                entity_id: ::core::default::Default::default(),
                remaining_time: ::core::default::Default::default(),
            }
        }
    }
    /// A result of the path finder.
    pub struct Path {
        pub points: Vec<IVec3>,
        pub index: usize,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Path {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Path",
                "points",
                &self.points,
                "index",
                &&self.index,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Path {
        #[inline]
        fn clone(&self) -> Path {
            Path {
                points: ::core::clone::Clone::clone(&self.points),
                index: ::core::clone::Clone::clone(&self.index),
            }
        }
    }
    impl From<Vec<IVec3>> for Path {
        fn from(points: Vec<IVec3>) -> Self {
            Self { points, index: 0 }
        }
    }
    impl From<IVec3> for Path {
        fn from(value: IVec3) -> Self {
            Self {
                points: <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([value])),
                index: 0,
            }
        }
    }
    impl Path {
        /// Return the current path position.
        pub fn point(&self) -> Option<IVec3> {
            self.points.get(self.index).copied()
        }
        /// Advanced the path by one point.
        pub fn advance(&mut self) {
            self.index += 1;
        }
    }
    impl Entity {
        /// Get the kind of entity from this instance.
        pub fn kind(&self) -> EntityKind {
            self.1.entity_kind()
        }
        /// Get the category of entity from this instance.
        #[inline]
        pub fn category(&self) -> EntityCategory {
            self.kind().category()
        }
        /// This this entity from its id in a world.
        ///
        /// **This is really important to no change the entity kind when ticking the
        /// function.**
        pub fn tick(&mut self, world: &mut World, id: u32) {
            tick::tick(world, id, self);
        }
        /// Recompute this entity's size and recompute the bounding box from its position.
        pub fn resize(&mut self) {
            let Entity(base, base_kind) = self;
            base
                .size = match base_kind {
                BaseKind::Item(_) => Size::new_centered(0.25, 0.25),
                BaseKind::Painting(_) => Size::new(0.5, 0.5),
                BaseKind::Boat(_) => Size::new_centered(1.5, 0.6),
                BaseKind::Minecart(_) => Size::new_centered(0.98, 0.7),
                BaseKind::LightningBolt(_) => Size::new(0.0, 0.0),
                BaseKind::FallingBlock(_) => Size::new_centered(0.98, 0.98),
                BaseKind::Tnt(_) => Size::new_centered(0.98, 0.98),
                BaseKind::Projectile(_, ProjectileKind::Arrow(_)) => Size::new(0.5, 0.5),
                BaseKind::Projectile(_, ProjectileKind::Egg(_)) => Size::new(0.5, 0.5),
                BaseKind::Projectile(_, ProjectileKind::Fireball(_)) => {
                    Size::new(1.0, 1.0)
                }
                BaseKind::Projectile(_, ProjectileKind::Snowball(_)) => {
                    Size::new(0.5, 0.5)
                }
                BaseKind::Projectile(_, ProjectileKind::Bobber(_)) => {
                    Size::new(0.25, 0.25)
                }
                BaseKind::Living(_, LivingKind::Human(player)) => {
                    if player.sleeping {
                        Size::new(0.2, 0.2)
                    } else {
                        Size::new(0.6, 1.8)
                    }
                }
                BaseKind::Living(_, LivingKind::Ghast(_)) => Size::new(4.0, 4.0),
                BaseKind::Living(_, LivingKind::Slime(slime)) => {
                    let factor = slime.size as f32 + 1.0;
                    Size::new(0.6 * factor, 0.6 * factor)
                }
                BaseKind::Living(_, LivingKind::Pig(_)) => Size::new(0.9, 0.9),
                BaseKind::Living(_, LivingKind::Chicken(_)) => Size::new(0.3, 0.4),
                BaseKind::Living(_, LivingKind::Cow(_)) => Size::new(0.9, 1.3),
                BaseKind::Living(_, LivingKind::Sheep(_)) => Size::new(0.9, 1.3),
                BaseKind::Living(_, LivingKind::Squid(_)) => Size::new(0.95, 0.95),
                BaseKind::Living(_, LivingKind::Wolf(_)) => Size::new(0.8, 0.8),
                BaseKind::Living(_, LivingKind::Creeper(_)) => Size::new(0.6, 1.8),
                BaseKind::Living(_, LivingKind::Giant(_)) => Size::new(3.6, 10.8),
                BaseKind::Living(_, LivingKind::PigZombie(_)) => Size::new(0.6, 1.8),
                BaseKind::Living(_, LivingKind::Skeleton(_)) => Size::new(0.6, 1.8),
                BaseKind::Living(_, LivingKind::Spider(_)) => Size::new(1.4, 0.9),
                BaseKind::Living(_, LivingKind::Zombie(_)) => Size::new(0.6, 1.8),
            };
            base
                .eye_height = match base_kind {
                BaseKind::Living(_, LivingKind::Human(_)) => 1.62,
                BaseKind::Living(_, LivingKind::Wolf(_)) => base.size.height * 0.8,
                BaseKind::Living(_, _) => base.size.height * 0.85,
                _ => 0.0,
            };
            common::update_bounding_box_from_pos(base);
        }
        /// Teleport the entity to a specific position, this function keep the bounding box
        /// synchronized with the position.
        pub fn teleport(&mut self, pos: DVec3) {
            let Entity(base, _) = self;
            base.pos = pos;
            common::update_bounding_box_from_pos(base);
        }
        /// Return true if the entity can naturally spawn at its current position (with
        /// synchronized bounding box) in the given world. The entity is mutated because its
        /// RNG may be used.
        pub fn can_natural_spawn(&mut self, world: &World) -> bool {
            let Entity(base, BaseKind::Living(_, living_kind)) = self else {
                return false;
            };
            let kind = living_kind.entity_kind();
            let block_pos = IVec3 {
                x: base.bb.center_x().floor() as i32,
                y: base.bb.min.y.floor() as i32,
                z: base.bb.center_z().floor() as i32,
            };
            let category = kind.category();
            if category == EntityCategory::Animal {
                if !world.is_block(block_pos - IVec3::Y, block::GRASS) {
                    return false;
                }
                if world.get_light(block_pos).max() <= 8 {
                    return false;
                }
            } else if category == EntityCategory::Mob {
                let light = world.get_light(block_pos);
                if light.sky as i32 > base.rand.next_int_bounded(32) {
                    return false;
                }
                if light.max_real() as i32 > base.rand.next_int_bounded(8) {
                    return false;
                }
            }
            if category != EntityCategory::Other {
                let weight_func = common::path_weight_func(living_kind);
                if weight_func(world, block_pos) < 0.0 {
                    return false;
                }
            }
            if world.has_entity_colliding(base.bb, true) {
                return false;
            }
            if category != EntityCategory::WaterAnimal {
                if world.iter_blocks_boxes_colliding(base.bb).next().is_some() {
                    return false;
                }
                if world
                    .iter_blocks_in_box(base.bb)
                    .any(|(_pos, block, _)| block::material::is_fluid(block))
                {
                    return false;
                }
            }
            true
        }
        /// Initialize this entity for natural spawn, for example this randomize the slime
        /// size or sheep color or make a spider with jokey.
        pub fn init_natural_spawn(&mut self, _world: &mut World) {
            let Entity(base, BaseKind::Living(_, living_kind)) = self else {
                return;
            };
            match living_kind {
                LivingKind::Slime(slime) => {
                    slime.size = 1 << base.rand.next_int_bounded(3) as u8;
                    self.resize();
                }
                LivingKind::Sheep(sheep) => {
                    let rand = base.rand.next_int_bounded(100) as u8;
                    sheep
                        .color = match rand {
                        0..=4 => 15,
                        5..=9 => 7,
                        10..=14 => 8,
                        15..=17 => 12,
                        _ if base.rand.next_int_bounded(500) == 0 => 6,
                        _ => 0,
                    };
                }
                _ => {}
            }
        }
    }
    impl BaseKind {
        /// Get the generic entity kind from this base entity kind.
        pub fn entity_kind(&self) -> EntityKind {
            match self {
                BaseKind::Item(_) => EntityKind::Item,
                BaseKind::Painting(_) => EntityKind::Painting,
                BaseKind::Boat(_) => EntityKind::Boat,
                BaseKind::Minecart(_) => EntityKind::Minecart,
                BaseKind::LightningBolt(_) => EntityKind::LightningBolt,
                BaseKind::FallingBlock(_) => EntityKind::FallingBlock,
                BaseKind::Tnt(_) => EntityKind::Tnt,
                BaseKind::Projectile(_, kind) => kind.entity_kind(),
                BaseKind::Living(_, kind) => kind.entity_kind(),
            }
        }
    }
    impl LivingKind {
        /// Get the generic entity kind from this living entity kind.
        pub fn entity_kind(&self) -> EntityKind {
            match self {
                LivingKind::Human(_) => EntityKind::Human,
                LivingKind::Ghast(_) => EntityKind::Ghast,
                LivingKind::Slime(_) => EntityKind::Slime,
                LivingKind::Pig(_) => EntityKind::Pig,
                LivingKind::Chicken(_) => EntityKind::Chicken,
                LivingKind::Cow(_) => EntityKind::Cow,
                LivingKind::Sheep(_) => EntityKind::Sheep,
                LivingKind::Squid(_) => EntityKind::Squid,
                LivingKind::Wolf(_) => EntityKind::Wolf,
                LivingKind::Creeper(_) => EntityKind::Creeper,
                LivingKind::Giant(_) => EntityKind::Giant,
                LivingKind::PigZombie(_) => EntityKind::PigZombie,
                LivingKind::Skeleton(_) => EntityKind::Skeleton,
                LivingKind::Spider(_) => EntityKind::Spider,
                LivingKind::Zombie(_) => EntityKind::Zombie,
            }
        }
    }
    impl ProjectileKind {
        /// Get the generic entity kind from this projectile entity kind.
        pub fn entity_kind(&self) -> EntityKind {
            match self {
                ProjectileKind::Arrow(_) => EntityKind::Arrow,
                ProjectileKind::Egg(_) => EntityKind::Egg,
                ProjectileKind::Fireball(_) => EntityKind::Fireball,
                ProjectileKind::Snowball(_) => EntityKind::Snowball,
                ProjectileKind::Bobber(_) => EntityKind::Bobber,
            }
        }
    }
    impl EntityKind {
        /// Create a new default entity instance from the given type.
        pub fn new_default(self, pos: DVec3) -> Box<Entity> {
            match self {
                EntityKind::Item => Item::new_default(pos),
                EntityKind::Painting => Painting::new_default(pos),
                EntityKind::Boat => Boat::new_default(pos),
                EntityKind::Minecart => Minecart::new_default(pos),
                EntityKind::Bobber => Bobber::new_default(pos),
                EntityKind::LightningBolt => LightningBolt::new_default(pos),
                EntityKind::FallingBlock => FallingBlock::new_default(pos),
                EntityKind::Tnt => Tnt::new_default(pos),
                EntityKind::Arrow => Arrow::new_default(pos),
                EntityKind::Egg => Egg::new_default(pos),
                EntityKind::Fireball => Fireball::new_default(pos),
                EntityKind::Snowball => Snowball::new_default(pos),
                EntityKind::Human => Human::new_default(pos),
                EntityKind::Ghast => Ghast::new_default(pos),
                EntityKind::Slime => Slime::new_default(pos),
                EntityKind::Pig => Pig::new_default(pos),
                EntityKind::Chicken => Chicken::new_default(pos),
                EntityKind::Cow => Cow::new_default(pos),
                EntityKind::Sheep => Sheep::new_default(pos),
                EntityKind::Squid => Squid::new_default(pos),
                EntityKind::Wolf => Wolf::new_default(pos),
                EntityKind::Creeper => Creeper::new_default(pos),
                EntityKind::Giant => Giant::new_default(pos),
                EntityKind::PigZombie => PigZombie::new_default(pos),
                EntityKind::Skeleton => Skeleton::new_default(pos),
                EntityKind::Spider => Spider::new_default(pos),
                EntityKind::Zombie => Zombie::new_default(pos),
            }
        }
        /// Return true if this entity kind is hard, hard entities prevent block placing and
        /// entity spawning when colliding.
        #[inline]
        pub fn is_hard(self) -> bool {
            match self {
                EntityKind::Item
                | EntityKind::Bobber
                | EntityKind::LightningBolt
                | EntityKind::Arrow
                | EntityKind::Egg
                | EntityKind::Fireball
                | EntityKind::Snowball => false,
                _ => true,
            }
        }
        /// Get the category of this entity kind.
        pub fn category(self) -> EntityCategory {
            match self {
                EntityKind::Pig
                | EntityKind::Chicken
                | EntityKind::Cow
                | EntityKind::Sheep
                | EntityKind::Wolf => EntityCategory::Animal,
                EntityKind::Squid => EntityCategory::WaterAnimal,
                EntityKind::Creeper
                | EntityKind::Giant
                | EntityKind::PigZombie
                | EntityKind::Skeleton
                | EntityKind::Spider
                | EntityKind::Zombie
                | EntityKind::Slime => EntityCategory::Mob,
                _ => EntityCategory::Other,
            }
        }
        /// Returns the maximum number of entities of that kind that can be spawned at once
        /// when natural spawning in a single chunk.
        pub fn natural_spawn_max_chunk_count(self) -> usize {
            match self {
                EntityKind::Ghast => 1,
                EntityKind::Wolf => 8,
                _ => 4,
            }
        }
    }
    impl EntityCategory {
        pub const ALL: [Self; 4] = [
            Self::Animal,
            Self::WaterAnimal,
            Self::Mob,
            Self::Other,
        ];
        /// Returns the maximum number of entities of this category before preventing more
        /// natural spawning. This number will be multiplied by the number of spawn-able
        /// chunks and then by 256 (16x16 chunks). So this is the maximum count of entities
        /// per 16x16 chunks loaded.
        pub fn natural_spawn_max_world_count(self) -> usize {
            match self {
                EntityCategory::Animal => 15,
                EntityCategory::WaterAnimal => 5,
                EntityCategory::Mob => 70,
                EntityCategory::Other => 0,
            }
        }
        /// Returns the material this entity is able to spawn in, this is a preliminary check.
        pub fn natural_spawn_material(self) -> Material {
            match self {
                EntityCategory::Animal => Material::Air,
                EntityCategory::WaterAnimal => Material::Water,
                EntityCategory::Mob => Material::Air,
                EntityCategory::Other => Material::Air,
            }
        }
    }
    impl Item {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(func: impl FnOnce(&mut Base, &mut Item)) -> Box<Entity> {
            let mut entity = Box::new(Entity(def(), BaseKind::Item(def())));
            let Entity(base, BaseKind::Item(this)) = &mut *entity else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            (|_: &mut Base, this: &mut Item| {
                this.health = 5;
                this.stack = ItemStack::new_block(block::STONE, 0);
            })(base, this);
            func(base, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _| base.pos = pos)
        }
    }
    impl Painting {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(func: impl FnOnce(&mut Base, &mut Painting)) -> Box<Entity> {
            let mut entity = Box::new(Entity(def(), BaseKind::Painting(def())));
            let Entity(base, BaseKind::Painting(this)) = &mut *entity else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            func(base, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _| base.pos = pos)
        }
    }
    impl Boat {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(func: impl FnOnce(&mut Base, &mut Boat)) -> Box<Entity> {
            let mut entity = Box::new(Entity(def(), BaseKind::Boat(def())));
            let Entity(base, BaseKind::Boat(this)) = &mut *entity else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            func(base, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _| base.pos = pos)
        }
    }
    impl Minecart {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(func: impl FnOnce(&mut Base, &mut Minecart)) -> Box<Entity> {
            let mut entity = Box::new(Entity(def(), BaseKind::Minecart(def())));
            let Entity(base, BaseKind::Minecart(this)) = &mut *entity else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            func(base, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _| base.pos = pos)
        }
    }
    impl LightningBolt {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut LightningBolt),
        ) -> Box<Entity> {
            let mut entity = Box::new(Entity(def(), BaseKind::LightningBolt(def())));
            let Entity(base, BaseKind::LightningBolt(this)) = &mut *entity else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            func(base, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _| base.pos = pos)
        }
    }
    impl FallingBlock {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(func: impl FnOnce(&mut Base, &mut FallingBlock)) -> Box<Entity> {
            let mut entity = Box::new(Entity(def(), BaseKind::FallingBlock(def())));
            let Entity(base, BaseKind::FallingBlock(this)) = &mut *entity else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            (|_: &mut Base, this: &mut FallingBlock| {
                this.block_id = block::SAND;
            })(base, this);
            func(base, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _| base.pos = pos)
        }
    }
    impl Tnt {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(func: impl FnOnce(&mut Base, &mut Tnt)) -> Box<Entity> {
            let mut entity = Box::new(Entity(def(), BaseKind::Tnt(def())));
            let Entity(base, BaseKind::Tnt(this)) = &mut *entity else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            func(base, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _| base.pos = pos)
        }
    }
    impl Human {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut Living, &mut Human),
        ) -> Box<Entity> {
            let mut entity = Box::new(
                Entity(def(), BaseKind::Living(def(), LivingKind::Human(def()))),
            );
            let Entity(base, BaseKind::Living(living, LivingKind::Human(this))) = &mut *entity
            else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            living.health = 20;
            func(base, living, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _, _| base.pos = pos)
        }
    }
    impl Ghast {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut Living, &mut Ghast),
        ) -> Box<Entity> {
            let mut entity = Box::new(
                Entity(def(), BaseKind::Living(def(), LivingKind::Ghast(def()))),
            );
            let Entity(base, BaseKind::Living(living, LivingKind::Ghast(this))) = &mut *entity
            else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            living.health = 10;
            func(base, living, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _, _| base.pos = pos)
        }
    }
    impl Slime {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut Living, &mut Slime),
        ) -> Box<Entity> {
            let mut entity = Box::new(
                Entity(def(), BaseKind::Living(def(), LivingKind::Slime(def()))),
            );
            let Entity(base, BaseKind::Living(living, LivingKind::Slime(this))) = &mut *entity
            else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            living.health = 1;
            func(base, living, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _, _| base.pos = pos)
        }
    }
    impl Pig {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut Living, &mut Pig),
        ) -> Box<Entity> {
            let mut entity = Box::new(
                Entity(def(), BaseKind::Living(def(), LivingKind::Pig(def()))),
            );
            let Entity(base, BaseKind::Living(living, LivingKind::Pig(this))) = &mut *entity
            else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            living.health = 10;
            func(base, living, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _, _| base.pos = pos)
        }
    }
    impl Chicken {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut Living, &mut Chicken),
        ) -> Box<Entity> {
            let mut entity = Box::new(
                Entity(def(), BaseKind::Living(def(), LivingKind::Chicken(def()))),
            );
            let Entity(base, BaseKind::Living(living, LivingKind::Chicken(this))) = &mut *entity
            else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            living.health = 4;
            func(base, living, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _, _| base.pos = pos)
        }
    }
    impl Cow {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut Living, &mut Cow),
        ) -> Box<Entity> {
            let mut entity = Box::new(
                Entity(def(), BaseKind::Living(def(), LivingKind::Cow(def()))),
            );
            let Entity(base, BaseKind::Living(living, LivingKind::Cow(this))) = &mut *entity
            else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            living.health = 10;
            func(base, living, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _, _| base.pos = pos)
        }
    }
    impl Sheep {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut Living, &mut Sheep),
        ) -> Box<Entity> {
            let mut entity = Box::new(
                Entity(def(), BaseKind::Living(def(), LivingKind::Sheep(def()))),
            );
            let Entity(base, BaseKind::Living(living, LivingKind::Sheep(this))) = &mut *entity
            else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            living.health = 10;
            func(base, living, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _, _| base.pos = pos)
        }
    }
    impl Squid {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut Living, &mut Squid),
        ) -> Box<Entity> {
            let mut entity = Box::new(
                Entity(def(), BaseKind::Living(def(), LivingKind::Squid(def()))),
            );
            let Entity(base, BaseKind::Living(living, LivingKind::Squid(this))) = &mut *entity
            else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            living.health = 10;
            func(base, living, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _, _| base.pos = pos)
        }
    }
    impl Wolf {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut Living, &mut Wolf),
        ) -> Box<Entity> {
            let mut entity = Box::new(
                Entity(def(), BaseKind::Living(def(), LivingKind::Wolf(def()))),
            );
            let Entity(base, BaseKind::Living(living, LivingKind::Wolf(this))) = &mut *entity
            else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            living.health = 8;
            func(base, living, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _, _| base.pos = pos)
        }
    }
    impl Creeper {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut Living, &mut Creeper),
        ) -> Box<Entity> {
            let mut entity = Box::new(
                Entity(def(), BaseKind::Living(def(), LivingKind::Creeper(def()))),
            );
            let Entity(base, BaseKind::Living(living, LivingKind::Creeper(this))) = &mut *entity
            else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            living.health = 20;
            func(base, living, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _, _| base.pos = pos)
        }
    }
    impl Giant {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut Living, &mut Giant),
        ) -> Box<Entity> {
            let mut entity = Box::new(
                Entity(def(), BaseKind::Living(def(), LivingKind::Giant(def()))),
            );
            let Entity(base, BaseKind::Living(living, LivingKind::Giant(this))) = &mut *entity
            else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            living.health = 200;
            func(base, living, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _, _| base.pos = pos)
        }
    }
    impl PigZombie {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut Living, &mut PigZombie),
        ) -> Box<Entity> {
            let mut entity = Box::new(
                Entity(def(), BaseKind::Living(def(), LivingKind::PigZombie(def()))),
            );
            let Entity(base, BaseKind::Living(living, LivingKind::PigZombie(this))) = &mut *entity
            else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            living.health = 20;
            func(base, living, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _, _| base.pos = pos)
        }
    }
    impl Skeleton {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut Living, &mut Skeleton),
        ) -> Box<Entity> {
            let mut entity = Box::new(
                Entity(def(), BaseKind::Living(def(), LivingKind::Skeleton(def()))),
            );
            let Entity(base, BaseKind::Living(living, LivingKind::Skeleton(this))) = &mut *entity
            else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            living.health = 20;
            func(base, living, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _, _| base.pos = pos)
        }
    }
    impl Spider {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut Living, &mut Spider),
        ) -> Box<Entity> {
            let mut entity = Box::new(
                Entity(def(), BaseKind::Living(def(), LivingKind::Spider(def()))),
            );
            let Entity(base, BaseKind::Living(living, LivingKind::Spider(this))) = &mut *entity
            else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            living.health = 20;
            func(base, living, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _, _| base.pos = pos)
        }
    }
    impl Zombie {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut Living, &mut Zombie),
        ) -> Box<Entity> {
            let mut entity = Box::new(
                Entity(def(), BaseKind::Living(def(), LivingKind::Zombie(def()))),
            );
            let Entity(base, BaseKind::Living(living, LivingKind::Zombie(this))) = &mut *entity
            else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            living.health = 20;
            func(base, living, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _, _| base.pos = pos)
        }
    }
    impl Arrow {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut Projectile, &mut Arrow),
        ) -> Box<Entity> {
            let mut entity = Box::new(
                Entity(def(), BaseKind::Projectile(def(), ProjectileKind::Arrow(def()))),
            );
            let Entity(
                base,
                BaseKind::Projectile(projectile, ProjectileKind::Arrow(this)),
            ) = &mut *entity else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            func(base, projectile, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _, _| base.pos = pos)
        }
    }
    impl Egg {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut Projectile, &mut Egg),
        ) -> Box<Entity> {
            let mut entity = Box::new(
                Entity(def(), BaseKind::Projectile(def(), ProjectileKind::Egg(def()))),
            );
            let Entity(
                base,
                BaseKind::Projectile(projectile, ProjectileKind::Egg(this)),
            ) = &mut *entity else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            func(base, projectile, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _, _| base.pos = pos)
        }
    }
    impl Fireball {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut Projectile, &mut Fireball),
        ) -> Box<Entity> {
            let mut entity = Box::new(
                Entity(
                    def(),
                    BaseKind::Projectile(def(), ProjectileKind::Fireball(def())),
                ),
            );
            let Entity(
                base,
                BaseKind::Projectile(projectile, ProjectileKind::Fireball(this)),
            ) = &mut *entity else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            func(base, projectile, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _, _| base.pos = pos)
        }
    }
    impl Snowball {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut Projectile, &mut Snowball),
        ) -> Box<Entity> {
            let mut entity = Box::new(
                Entity(
                    def(),
                    BaseKind::Projectile(def(), ProjectileKind::Snowball(def())),
                ),
            );
            let Entity(
                base,
                BaseKind::Projectile(projectile, ProjectileKind::Snowball(this)),
            ) = &mut *entity else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            func(base, projectile, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _, _| base.pos = pos)
        }
    }
    impl Bobber {
        /// Create a new instance of this entity type and initialize the entity with
        /// a closure, the entity is then resized to initialize its bounding box.
        #[inline]
        pub fn new_with(
            func: impl FnOnce(&mut Base, &mut Projectile, &mut Bobber),
        ) -> Box<Entity> {
            let mut entity = Box::new(
                Entity(def(), BaseKind::Projectile(def(), ProjectileKind::Bobber(def()))),
            );
            let Entity(
                base,
                BaseKind::Projectile(projectile, ProjectileKind::Bobber(this)),
            ) = &mut *entity else {
                ::core::panicking::panic("internal error: entered unreachable code")
            };
            func(base, projectile, this);
            entity.resize();
            entity
        }
        /// Create a new instance of this entity at the given position, the entity is
        /// then resized to initialize its bounding box.
        pub fn new_default(pos: DVec3) -> Box<Entity> {
            Self::new_with(|base, _, _| base.pos = pos)
        }
    }
}
pub mod block_entity {
    //! Block entities structures and logic implementation.
    use glam::IVec3;
    use crate::world::World;
    pub mod chest {
        //! Chest block entity.
        use crate::item::ItemStack;
        pub struct ChestBlockEntity {
            /// The inventory of the chest.
            pub inv: Box<[ItemStack; 27]>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ChestBlockEntity {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ChestBlockEntity",
                    "inv",
                    &&self.inv,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ChestBlockEntity {
            #[inline]
            fn clone(&self) -> ChestBlockEntity {
                ChestBlockEntity {
                    inv: ::core::clone::Clone::clone(&self.inv),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ChestBlockEntity {
            #[inline]
            fn default() -> ChestBlockEntity {
                ChestBlockEntity {
                    inv: ::core::default::Default::default(),
                }
            }
        }
    }
    pub mod furnace {
        //! Furnace block entity.
        use glam::IVec3;
        use crate::item::{self, ItemStack};
        use crate::world::{
            World, Event, BlockEntityEvent, BlockEntityStorage, BlockEntityProgress,
        };
        use crate::{smelt, block};
        pub struct FurnaceBlockEntity {
            /// Input stack of the furnace.
            pub input_stack: ItemStack,
            /// Item stack for fueling the furnace.
            pub fuel_stack: ItemStack,
            /// Output stack of the furnace.
            pub output_stack: ItemStack,
            /// Max burn ticks for the current fuel being consumed.
            pub burn_max_ticks: u16,
            /// Current burn remaining ticks until a fuel item need to be consumed again.
            pub burn_remaining_ticks: u16,
            /// Current ticks count since the current item has been added.
            pub smelt_ticks: u16,
            /// Last input stack, used to compare to new one and update the current recipe.
            last_input_stack: ItemStack,
            /// Last output stack, used to compare to new one and update the current recipe.
            last_output_stack: ItemStack,
            /// If some recipe has been found for the current input stack, this contains the
            /// future output stack that will be assigned to output stack.
            active_output_stack: Option<ItemStack>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for FurnaceBlockEntity {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "input_stack",
                    "fuel_stack",
                    "output_stack",
                    "burn_max_ticks",
                    "burn_remaining_ticks",
                    "smelt_ticks",
                    "last_input_stack",
                    "last_output_stack",
                    "active_output_stack",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.input_stack,
                    &self.fuel_stack,
                    &self.output_stack,
                    &self.burn_max_ticks,
                    &self.burn_remaining_ticks,
                    &self.smelt_ticks,
                    &self.last_input_stack,
                    &self.last_output_stack,
                    &&self.active_output_stack,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "FurnaceBlockEntity",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for FurnaceBlockEntity {
            #[inline]
            fn clone(&self) -> FurnaceBlockEntity {
                FurnaceBlockEntity {
                    input_stack: ::core::clone::Clone::clone(&self.input_stack),
                    fuel_stack: ::core::clone::Clone::clone(&self.fuel_stack),
                    output_stack: ::core::clone::Clone::clone(&self.output_stack),
                    burn_max_ticks: ::core::clone::Clone::clone(&self.burn_max_ticks),
                    burn_remaining_ticks: ::core::clone::Clone::clone(
                        &self.burn_remaining_ticks,
                    ),
                    smelt_ticks: ::core::clone::Clone::clone(&self.smelt_ticks),
                    last_input_stack: ::core::clone::Clone::clone(
                        &self.last_input_stack,
                    ),
                    last_output_stack: ::core::clone::Clone::clone(
                        &self.last_output_stack,
                    ),
                    active_output_stack: ::core::clone::Clone::clone(
                        &self.active_output_stack,
                    ),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for FurnaceBlockEntity {
            #[inline]
            fn default() -> FurnaceBlockEntity {
                FurnaceBlockEntity {
                    input_stack: ::core::default::Default::default(),
                    fuel_stack: ::core::default::Default::default(),
                    output_stack: ::core::default::Default::default(),
                    burn_max_ticks: ::core::default::Default::default(),
                    burn_remaining_ticks: ::core::default::Default::default(),
                    smelt_ticks: ::core::default::Default::default(),
                    last_input_stack: ::core::default::Default::default(),
                    last_output_stack: ::core::default::Default::default(),
                    active_output_stack: ::core::default::Default::default(),
                }
            }
        }
        impl FurnaceBlockEntity {
            /// Internal function to compute the new recipe depending on the current input item.
            /// None is returned if the input stack is empty, if no recipe can be found, or if
            /// the recipe's output do not fit in the output stack.
            fn find_new_output_stack(&self) -> Option<ItemStack> {
                if self.input_stack.size == 0 {
                    return None;
                }
                let input_id = self.input_stack.id;
                let input_damage = self.input_stack.damage;
                let mut output_stack = smelt::find_smelting_output(
                    input_id,
                    input_damage,
                )?;
                if !self.output_stack.is_empty() {
                    if (self.output_stack.id, self.output_stack.damage)
                        != (output_stack.id, output_stack.damage)
                    {
                        return None;
                    } else if self.output_stack.size + output_stack.size
                        > item::from_id(output_stack.id).max_stack_size
                    {
                        return None;
                    } else {
                        output_stack.size += self.output_stack.size;
                    }
                }
                Some(output_stack)
            }
            /// Tick the furnace block entity.
            pub fn tick(&mut self, world: &mut World, pos: IVec3) {
                if self.input_stack != self.last_input_stack
                    || self.output_stack != self.last_output_stack
                {
                    self.active_output_stack = self.find_new_output_stack();
                    self.last_input_stack = self.input_stack;
                    self.last_output_stack = self.output_stack;
                }
                let mut smelt_modified = false;
                let mut fuel_modified = false;
                let initial_burning = self.burn_remaining_ticks != 0;
                if initial_burning {
                    self.burn_remaining_ticks -= 1;
                    fuel_modified = true;
                }
                if let Some(active_output_stack) = &self.active_output_stack {
                    if self.burn_remaining_ticks == 0 && !self.fuel_stack.is_empty() {
                        self.burn_max_ticks = smelt::get_burn_ticks(self.fuel_stack.id);
                        self.burn_remaining_ticks = self.burn_max_ticks;
                        if self.burn_max_ticks != 0 {
                            self.fuel_stack.size -= 1;
                            fuel_modified = true;
                            world
                                .push_event(Event::BlockEntity {
                                    pos,
                                    inner: BlockEntityEvent::Storage {
                                        storage: BlockEntityStorage::FurnaceFuel,
                                        stack: self.fuel_stack,
                                    },
                                });
                            world
                                .push_event(Event::BlockEntity {
                                    pos,
                                    inner: BlockEntityEvent::Progress {
                                        progress: BlockEntityProgress::FurnaceBurnMaxTime,
                                        value: self.burn_max_ticks,
                                    },
                                });
                        }
                    }
                    if self.burn_remaining_ticks == 0 {
                        if self.smelt_ticks != 0 {
                            self.smelt_ticks = 0;
                            smelt_modified = true;
                        }
                    } else {
                        self.smelt_ticks += 1;
                        if self.smelt_ticks == 200 {
                            self.smelt_ticks = 0;
                            self.input_stack.size -= 1;
                            self.output_stack = *active_output_stack;
                            world
                                .push_event(Event::BlockEntity {
                                    pos,
                                    inner: BlockEntityEvent::Storage {
                                        storage: BlockEntityStorage::FurnaceInput,
                                        stack: self.input_stack,
                                    },
                                });
                            world
                                .push_event(Event::BlockEntity {
                                    pos,
                                    inner: BlockEntityEvent::Storage {
                                        storage: BlockEntityStorage::FurnaceOutput,
                                        stack: self.output_stack,
                                    },
                                });
                        }
                        smelt_modified = true;
                    }
                } else if self.smelt_ticks != 0 {
                    self.smelt_ticks = 0;
                    smelt_modified = true;
                }
                if smelt_modified {
                    world
                        .push_event(Event::BlockEntity {
                            pos,
                            inner: BlockEntityEvent::Progress {
                                progress: BlockEntityProgress::FurnaceSmeltTime,
                                value: self.smelt_ticks,
                            },
                        });
                }
                if fuel_modified {
                    world
                        .push_event(Event::BlockEntity {
                            pos,
                            inner: BlockEntityEvent::Progress {
                                progress: BlockEntityProgress::FurnaceBurnRemainingTime,
                                value: self.burn_remaining_ticks,
                            },
                        });
                }
                if initial_burning != (self.burn_remaining_ticks != 0) {
                    let (_id, metadata) = world
                        .get_block(pos)
                        .expect("should not be ticking if not loaded");
                    if initial_burning {
                        world.set_block_notify(pos, block::FURNACE, metadata);
                    } else {
                        world.set_block_notify(pos, block::FURNACE_LIT, metadata);
                    }
                }
            }
        }
    }
    pub mod dispenser {
        //! Dispenser block entity.
        use crate::rand::JavaRandom;
        use crate::item::ItemStack;
        pub struct DispenserBlockEntity {
            /// The inventory of the dispenser.
            pub inv: Box<[ItemStack; 9]>,
            /// The dispenser has its own RNG.
            pub rand: JavaRandom,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DispenserBlockEntity {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "DispenserBlockEntity",
                    "inv",
                    &self.inv,
                    "rand",
                    &&self.rand,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DispenserBlockEntity {
            #[inline]
            fn clone(&self) -> DispenserBlockEntity {
                DispenserBlockEntity {
                    inv: ::core::clone::Clone::clone(&self.inv),
                    rand: ::core::clone::Clone::clone(&self.rand),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for DispenserBlockEntity {
            #[inline]
            fn default() -> DispenserBlockEntity {
                DispenserBlockEntity {
                    inv: ::core::default::Default::default(),
                    rand: ::core::default::Default::default(),
                }
            }
        }
        impl DispenserBlockEntity {
            /// Randomly pick a non-empty stack in this dispenser, returning its index if any,
            /// none if there are only empty stacks in the inventory.
            pub fn pick_random_index(&mut self) -> Option<usize> {
                let mut bound = 0;
                let mut selected_index = None;
                for (index, stack) in self.inv.iter_mut().enumerate() {
                    if !stack.is_empty() {
                        bound += 1;
                        if self.rand.next_int_bounded(bound) == 0 {
                            selected_index = Some(index);
                        }
                    }
                }
                selected_index
            }
        }
    }
    pub mod spawner {
        //! Spawner block entity.
        use glam::{IVec3, DVec3};
        use tracing::trace;
        use crate::entity::{EntityKind, Entity};
        use crate::geom::BoundingBox;
        use crate::world::World;
        pub struct SpawnerBlockEntity {
            /// Remaining ticks to spawn the entity.
            pub remaining_time: u16,
            /// Kind of entity.
            pub entity_kind: EntityKind,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SpawnerBlockEntity {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "SpawnerBlockEntity",
                    "remaining_time",
                    &self.remaining_time,
                    "entity_kind",
                    &&self.entity_kind,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SpawnerBlockEntity {
            #[inline]
            fn clone(&self) -> SpawnerBlockEntity {
                SpawnerBlockEntity {
                    remaining_time: ::core::clone::Clone::clone(&self.remaining_time),
                    entity_kind: ::core::clone::Clone::clone(&self.entity_kind),
                }
            }
        }
        impl Default for SpawnerBlockEntity {
            #[inline]
            fn default() -> Self {
                Self {
                    remaining_time: 20,
                    entity_kind: EntityKind::Pig,
                }
            }
        }
        impl SpawnerBlockEntity {
            /// Tick the furnace block entity.
            pub fn tick(&mut self, world: &mut World, pos: IVec3) {
                /// Maximum distance for a player to load the spawner.
                const LOAD_DIST_SQUARED: f64 = 16.0 * 16.0;
                let center = pos.as_dvec3() + 0.5;
                let loaded = world
                    .iter_entities()
                    .filter(|(_, entity)| entity.kind() == EntityKind::Human)
                    .any(|(_, Entity(base, _))| {
                        base.pos.distance_squared(center) < LOAD_DIST_SQUARED
                    });
                if !loaded {
                    return;
                }
                if self.remaining_time > 0 {
                    self.remaining_time -= 1;
                    return;
                }
                self
                    .remaining_time = 200
                    + world.get_rand_mut().next_int_bounded(600) as u16;
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event mc173\\src\\block_entity\\spawner.rs:55",
                                "mc173::block_entity::spawner",
                                ::tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "mc173\\src\\block_entity\\spawner.rs",
                                ),
                                ::core::option::Option::Some(55u32),
                                ::core::option::Option::Some(
                                    "mc173::block_entity::spawner",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &format_args!(
                                                    "spawner {1}, reached spawn time, next time in: {0}",
                                                    self.remaining_time,
                                                    pos,
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let bb = BoundingBox::CUBE + pos.as_dvec3();
                let mut same_count = world
                    .iter_entities_colliding(bb.inflate(DVec3::new(8.0, 4.0, 8.0)))
                    .filter(|(_, entity)| entity.kind() == self.entity_kind)
                    .count();
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event mc173\\src\\block_entity\\spawner.rs:63",
                                "mc173::block_entity::spawner",
                                ::tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "mc173\\src\\block_entity\\spawner.rs",
                                ),
                                ::core::option::Option::Some(63u32),
                                ::core::option::Option::Some(
                                    "mc173::block_entity::spawner",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &format_args!(
                                                    "spawner {0}, same entity count: {1}",
                                                    pos,
                                                    same_count,
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                for _ in 0..4 {
                    if same_count > 5 {
                        break;
                    }
                    let rand = world.get_rand_mut();
                    let pos = pos.as_dvec3()
                        + DVec3 {
                            x: (rand.next_double() - rand.next_double()) * 4.0,
                            y: (rand.next_int_bounded(3) - 1) as f64,
                            z: (rand.next_double() - rand.next_double()) * 4.0,
                        };
                    let mut entity = self.entity_kind.new_default(pos);
                    entity.0.look.x = rand.next_float();
                    if entity.can_natural_spawn(world) {
                        world.spawn_entity(entity);
                        same_count += 1;
                    }
                }
            }
        }
    }
    pub mod note_block {
        //! Note block block entity.
        pub struct NoteBlockBlockEntity {
            /// The note to play.
            pub note: u8,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NoteBlockBlockEntity {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "NoteBlockBlockEntity",
                    "note",
                    &&self.note,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NoteBlockBlockEntity {
            #[inline]
            fn clone(&self) -> NoteBlockBlockEntity {
                NoteBlockBlockEntity {
                    note: ::core::clone::Clone::clone(&self.note),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for NoteBlockBlockEntity {
            #[inline]
            fn default() -> NoteBlockBlockEntity {
                NoteBlockBlockEntity {
                    note: ::core::default::Default::default(),
                }
            }
        }
    }
    pub mod piston {
        //! Moving piston block entity.
        use glam::IVec3;
        use crate::world::World;
        use crate::geom::Face;
        pub struct PistonBlockEntity {
            /// The block id of the moving piston block.
            pub block: u8,
            /// The block metadata of the moving piston block.
            pub metadata: u8,
            /// Face toward the block is moving.
            pub face: Face,
            /// Progress of the move animation.
            pub progress: f32,
            /// True when the piston is extending, false when retracting.
            pub extending: bool,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PistonBlockEntity {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "PistonBlockEntity",
                    "block",
                    &self.block,
                    "metadata",
                    &self.metadata,
                    "face",
                    &self.face,
                    "progress",
                    &self.progress,
                    "extending",
                    &&self.extending,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PistonBlockEntity {
            #[inline]
            fn clone(&self) -> PistonBlockEntity {
                PistonBlockEntity {
                    block: ::core::clone::Clone::clone(&self.block),
                    metadata: ::core::clone::Clone::clone(&self.metadata),
                    face: ::core::clone::Clone::clone(&self.face),
                    progress: ::core::clone::Clone::clone(&self.progress),
                    extending: ::core::clone::Clone::clone(&self.extending),
                }
            }
        }
        impl Default for PistonBlockEntity {
            fn default() -> Self {
                Self {
                    block: 0,
                    metadata: 0,
                    face: Face::PosY,
                    progress: 0.0,
                    extending: false,
                }
            }
        }
        impl PistonBlockEntity {
            pub fn tick(&mut self, world: &mut World, pos: IVec3) {
                let _ = (world, pos);
            }
        }
    }
    pub mod sign {
        //! Sign block entity.
        pub struct SignBlockEntity {
            /// Text line of this sign block.
            pub lines: Box<[String; 4]>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SignBlockEntity {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "SignBlockEntity",
                    "lines",
                    &&self.lines,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SignBlockEntity {
            #[inline]
            fn clone(&self) -> SignBlockEntity {
                SignBlockEntity {
                    lines: ::core::clone::Clone::clone(&self.lines),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for SignBlockEntity {
            #[inline]
            fn default() -> SignBlockEntity {
                SignBlockEntity {
                    lines: ::core::default::Default::default(),
                }
            }
        }
    }
    pub mod jukebox {
        //! Sign block entity.
        pub struct JukeboxBlockEntity {
            /// The record currently playing in the jukebox.
            pub record: u32,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for JukeboxBlockEntity {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "JukeboxBlockEntity",
                    "record",
                    &&self.record,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for JukeboxBlockEntity {
            #[inline]
            fn clone(&self) -> JukeboxBlockEntity {
                JukeboxBlockEntity {
                    record: ::core::clone::Clone::clone(&self.record),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for JukeboxBlockEntity {
            #[inline]
            fn default() -> JukeboxBlockEntity {
                JukeboxBlockEntity {
                    record: ::core::default::Default::default(),
                }
            }
        }
    }
    /// All kinds of block entities.
    pub enum BlockEntity {
        Chest(chest::ChestBlockEntity),
        Furnace(furnace::FurnaceBlockEntity),
        Dispenser(dispenser::DispenserBlockEntity),
        Spawner(spawner::SpawnerBlockEntity),
        NoteBlock(note_block::NoteBlockBlockEntity),
        Piston(piston::PistonBlockEntity),
        Sign(sign::SignBlockEntity),
        Jukebox(jukebox::JukeboxBlockEntity),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for BlockEntity {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                BlockEntity::Chest(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Chest",
                        &__self_0,
                    )
                }
                BlockEntity::Furnace(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Furnace",
                        &__self_0,
                    )
                }
                BlockEntity::Dispenser(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Dispenser",
                        &__self_0,
                    )
                }
                BlockEntity::Spawner(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Spawner",
                        &__self_0,
                    )
                }
                BlockEntity::NoteBlock(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NoteBlock",
                        &__self_0,
                    )
                }
                BlockEntity::Piston(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Piston",
                        &__self_0,
                    )
                }
                BlockEntity::Sign(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Sign",
                        &__self_0,
                    )
                }
                BlockEntity::Jukebox(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Jukebox",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BlockEntity {
        #[inline]
        fn clone(&self) -> BlockEntity {
            match self {
                BlockEntity::Chest(__self_0) => {
                    BlockEntity::Chest(::core::clone::Clone::clone(__self_0))
                }
                BlockEntity::Furnace(__self_0) => {
                    BlockEntity::Furnace(::core::clone::Clone::clone(__self_0))
                }
                BlockEntity::Dispenser(__self_0) => {
                    BlockEntity::Dispenser(::core::clone::Clone::clone(__self_0))
                }
                BlockEntity::Spawner(__self_0) => {
                    BlockEntity::Spawner(::core::clone::Clone::clone(__self_0))
                }
                BlockEntity::NoteBlock(__self_0) => {
                    BlockEntity::NoteBlock(::core::clone::Clone::clone(__self_0))
                }
                BlockEntity::Piston(__self_0) => {
                    BlockEntity::Piston(::core::clone::Clone::clone(__self_0))
                }
                BlockEntity::Sign(__self_0) => {
                    BlockEntity::Sign(::core::clone::Clone::clone(__self_0))
                }
                BlockEntity::Jukebox(__self_0) => {
                    BlockEntity::Jukebox(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    impl BlockEntity {
        /// Tick the block entity at its position in the world.
        pub fn tick(&mut self, world: &mut World, pos: IVec3) {
            match self {
                BlockEntity::Chest(_) => {}
                BlockEntity::Furnace(furnace) => furnace.tick(world, pos),
                BlockEntity::Dispenser(_) => {}
                BlockEntity::Spawner(spawner) => spawner.tick(world, pos),
                BlockEntity::NoteBlock(_) => {}
                BlockEntity::Piston(piston) => piston.tick(world, pos),
                BlockEntity::Sign(_) => {}
                BlockEntity::Jukebox(_) => {}
            }
        }
    }
}
pub mod biome {
    //! This modules provide the biome enumeration, it is stored in each chunk on the 2D grid.
    //! The Notchian implementation doesn't store the biomes, so they are generated on each
    //! chunk load, biomes are also not sent to the client, so it is also recomputed
    //! client-side in order to have the proper foliage color.
    use crate::entity::{EntityCategory, EntityKind};
    /// Possible biomes, only used server-side for natural mob spawning.
    pub enum Biome {
        #[default]
        Void,
        RainForest,
        Swampland,
        SeasonalForest,
        Forest,
        Savanna,
        ShrubLand,
        Taiga,
        Desert,
        Plains,
        IceDesert,
        Tundra,
        Nether,
        Sky,
    }
    #[automatically_derived]
    impl ::core::default::Default for Biome {
        #[inline]
        fn default() -> Biome {
            Self::Void
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Biome {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Biome::Void => "Void",
                    Biome::RainForest => "RainForest",
                    Biome::Swampland => "Swampland",
                    Biome::SeasonalForest => "SeasonalForest",
                    Biome::Forest => "Forest",
                    Biome::Savanna => "Savanna",
                    Biome::ShrubLand => "ShrubLand",
                    Biome::Taiga => "Taiga",
                    Biome::Desert => "Desert",
                    Biome::Plains => "Plains",
                    Biome::IceDesert => "IceDesert",
                    Biome::Tundra => "Tundra",
                    Biome::Nether => "Nether",
                    Biome::Sky => "Sky",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Biome {
        #[inline]
        fn clone(&self) -> Biome {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Biome {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Biome {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Biome {
        #[inline]
        fn eq(&self, other: &Biome) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Biome {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Biome {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    impl Biome {
        /// Return true if it is possible to rain in a chunk.
        #[inline]
        pub fn has_rain(self) -> bool {
            match self {
                Biome::Desert | Biome::IceDesert | Biome::Nether | Biome::Sky => false,
                _ => true,
            }
        }
        /// Return true if this is snowing in the biome.
        #[inline]
        pub fn has_snow(self) -> bool {
            match self {
                Biome::Taiga | Biome::IceDesert | Biome::Tundra => true,
                _ => false,
            }
        }
        /// Get the natural entity kinds for the given category and this current biome.
        pub fn natural_entity_kinds(
            self,
            category: EntityCategory,
        ) -> &'static [NaturalEntityKind] {
            const ANIMALS: &'static [NaturalEntityKind] = &[
                NaturalEntityKind::new(EntityKind::Sheep, 12),
                NaturalEntityKind::new(EntityKind::Pig, 10),
                NaturalEntityKind::new(EntityKind::Chicken, 10),
                NaturalEntityKind::new(EntityKind::Cow, 8),
                NaturalEntityKind::new(EntityKind::Wolf, 2),
            ];
            const WATER_ANIMALS: &'static [NaturalEntityKind] = &[
                NaturalEntityKind::new(EntityKind::Squid, 10),
            ];
            const MOBS: &'static [NaturalEntityKind] = &[
                NaturalEntityKind::new(EntityKind::Spider, 10),
                NaturalEntityKind::new(EntityKind::Zombie, 10),
                NaturalEntityKind::new(EntityKind::Skeleton, 10),
                NaturalEntityKind::new(EntityKind::Creeper, 10),
                NaturalEntityKind::new(EntityKind::Slime, 10),
            ];
            const NETHER_MOBS: &'static [NaturalEntityKind] = &[
                NaturalEntityKind::new(EntityKind::Ghast, 10),
                NaturalEntityKind::new(EntityKind::PigZombie, 10),
            ];
            const SKY_ANIMALS: &'static [NaturalEntityKind] = &[
                NaturalEntityKind::new(EntityKind::Chicken, 10),
            ];
            match self {
                Biome::Void => &[],
                Biome::RainForest
                | Biome::Swampland
                | Biome::SeasonalForest
                | Biome::Savanna
                | Biome::ShrubLand
                | Biome::Desert
                | Biome::Plains
                | Biome::IceDesert
                | Biome::Tundra => {
                    match category {
                        EntityCategory::Animal => &ANIMALS[..ANIMALS.len() - 1],
                        EntityCategory::WaterAnimal => WATER_ANIMALS,
                        EntityCategory::Mob => MOBS,
                        EntityCategory::Other => &[],
                    }
                }
                Biome::Forest | Biome::Taiga => {
                    match category {
                        EntityCategory::Animal => ANIMALS,
                        EntityCategory::WaterAnimal => WATER_ANIMALS,
                        EntityCategory::Mob => MOBS,
                        EntityCategory::Other => &[],
                    }
                }
                Biome::Nether => {
                    match category {
                        EntityCategory::Mob => NETHER_MOBS,
                        _ => &[],
                    }
                }
                Biome::Sky => {
                    match category {
                        EntityCategory::Animal => SKY_ANIMALS,
                        _ => &[],
                    }
                }
            }
        }
    }
    /// Describe a natural
    pub struct NaturalEntityKind {
        /// The entity kind.
        pub kind: EntityKind,
        /// The higher the rate is, the higher probability is to spawn.
        pub chance: u16,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for NaturalEntityKind {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "NaturalEntityKind",
                "kind",
                &self.kind,
                "chance",
                &&self.chance,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for NaturalEntityKind {
        #[inline]
        fn clone(&self) -> NaturalEntityKind {
            let _: ::core::clone::AssertParamIsClone<EntityKind>;
            let _: ::core::clone::AssertParamIsClone<u16>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for NaturalEntityKind {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for NaturalEntityKind {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for NaturalEntityKind {
        #[inline]
        fn eq(&self, other: &NaturalEntityKind) -> bool {
            self.kind == other.kind && self.chance == other.chance
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for NaturalEntityKind {}
    #[automatically_derived]
    impl ::core::cmp::Eq for NaturalEntityKind {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<EntityKind>;
            let _: ::core::cmp::AssertParamIsEq<u16>;
        }
    }
    impl NaturalEntityKind {
        #[inline]
        pub const fn new(kind: EntityKind, chance: u16) -> Self {
            Self { kind, chance }
        }
    }
}
pub mod inventory {
    //! Inventory data structure storing item stacks.
    use std::ops::Range;
    use crate::item::ItemStack;
    use crate::item;
    /// An inventory handle is used to assists item insertion into inventory. It also record
    /// stack indices that have changed and therefore allows selective events.
    pub struct InventoryHandle<'a> {
        inv: &'a mut [ItemStack],
        changes: u64,
    }
    impl<'a> InventoryHandle<'a> {
        /// Construct a new inventory handle to a slice of item stacks. This functions panics
        /// if the given slice is bigger than 64 stacks.
        pub fn new(inv: &'a mut [ItemStack]) -> Self {
            if !(inv.len() <= 64) {
                ::core::panicking::panic("assertion failed: inv.len() <= 64")
            }
            Self { inv, changes: 0 }
        }
        /// Get the item stack at the given index.
        #[inline]
        pub fn get(&self, index: usize) -> ItemStack {
            self.inv[index]
        }
        /// Set the item stack at the given index.
        #[inline]
        pub fn set(&mut self, index: usize, stack: ItemStack) {
            if self.inv[index] != stack {
                self.inv[index] = stack;
                self.changes |= 1 << index;
            }
        }
        /// Add an item to the inventory, starting by the first slots.
        ///
        /// The given item stack is modified according to the amount of items actually added
        /// to the inventory, its size will be set to zero if fully consumed.
        pub fn push_front(&mut self, stack: &mut ItemStack) {
            self.push(stack, 0..self.inv.len(), false);
        }
        /// Add an item to the inventory, starting from the last slots.
        ///
        /// The given item stack is modified according to the amount of items actually added
        /// to the inventory, its size will be set to zero if fully consumed.
        pub fn push_back(&mut self, stack: &mut ItemStack) {
            self.push(stack, 0..self.inv.len(), true);
        }
        /// Same as [`push_front`](Self::push_front), but this work in a slice of inventory.
        pub fn push_front_in(&mut self, stack: &mut ItemStack, range: Range<usize>) {
            self.push(stack, range, false);
        }
        /// Same as [`push_back`](Self::push_back), but this work in a slice of inventory.
        pub fn push_back_in(&mut self, stack: &mut ItemStack, range: Range<usize>) {
            self.push(stack, range, true);
        }
        /// Add an item to the inventory. The given item stack is modified according to the
        /// amount of items actually added to the inventory, its size will be set to zero if
        /// fully consumed.
        fn push(&mut self, stack: &mut ItemStack, range: Range<usize>, back: bool) {
            if stack.is_empty() {
                return;
            }
            let item = item::from_id(stack.id);
            if item.max_stack_size > 1 {
                let mut range = range.clone();
                while let Some(index) = if back {
                    range.next_back()
                } else {
                    range.next()
                } {
                    let slot = &mut self.inv[index];
                    if slot.size != 0 && slot.id == stack.id
                        && slot.damage == stack.damage && slot.size < item.max_stack_size
                    {
                        let available = item.max_stack_size - slot.size;
                        let to_add = available.min(stack.size);
                        slot.size += to_add;
                        stack.size -= to_add;
                        self.changes |= 1 << index;
                        if stack.size == 0 {
                            return;
                        }
                    }
                }
            }
            let mut range = range.clone();
            while let Some(index) = if back { range.next_back() } else { range.next() } {
                let slot = &mut self.inv[index];
                if slot.is_empty() {
                    *slot = *stack;
                    stack.size = 0;
                    self.changes |= 1 << index;
                    return;
                }
            }
        }
        /// Test if the given item can be pushed in this inventory. If true is returned, a
        /// call to `push_*` function is guaranteed to fully consume the stack.
        pub fn can_push(&self, mut stack: ItemStack) -> bool {
            if stack.is_empty() {
                return true;
            }
            let item = item::from_id(stack.id);
            for slot in &self.inv[..] {
                if slot.is_empty() {
                    return true;
                } else if slot.size != 0 && slot.id == stack.id
                    && slot.damage == stack.damage && slot.size < item.max_stack_size
                {
                    let available = item.max_stack_size - slot.size;
                    let to_add = available.min(stack.size);
                    stack.size -= to_add;
                    if stack.size == 0 {
                        return true;
                    }
                }
            }
            false
        }
        /// Consume the equivalent of the given item stack, returning true if successful.
        pub fn consume(&mut self, stack: ItemStack) -> bool {
            for (index, slot) in self.inv.iter_mut().enumerate() {
                if slot.id == stack.id && slot.damage == stack.damage
                    && slot.size >= stack.size
                {
                    slot.size -= stack.size;
                    self.changes |= 1 << index;
                    return true;
                }
            }
            false
        }
        /// Get an iterator for changes that happened in this inventory.
        pub fn iter_changes(&self) -> ChangesIter {
            ChangesIter {
                changes: self.changes,
                count: 0,
            }
        }
    }
    /// An iterator of changes that happened to an inventory.
    pub struct ChangesIter {
        changes: u64,
        count: u8,
    }
    impl Iterator for ChangesIter {
        type Item = usize;
        fn next(&mut self) -> Option<Self::Item> {
            while self.count < 64 {
                let ret = ((self.changes & 1) != 0).then_some(self.count as usize);
                self.changes >>= 1;
                self.count += 1;
                if let Some(ret) = ret {
                    return Some(ret);
                }
            }
            None
        }
    }
}
pub mod craft {
    //! Item crafting management.
    use crate::item::{self, ItemStack};
    use crate::block;
    /// This structure keeps track of the current crafting recipe selected and allows lazy
    /// update of the crafting recipe. A crafting recipe is based on a 3x3 item grid.
    pub struct CraftTracker {
        /// The index and result item of the current selected recipe
        current_recipe: Option<(usize, ItemStack)>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for CraftTracker {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "CraftTracker",
                "current_recipe",
                &&self.current_recipe,
            )
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for CraftTracker {
        #[inline]
        fn default() -> CraftTracker {
            CraftTracker {
                current_recipe: ::core::default::Default::default(),
            }
        }
    }
    impl CraftTracker {
        /// Update this tracker to track a new 3x3 grid of items.
        pub fn update(&mut self, grid: &[ItemStack; 9]) {
            self.current_recipe = None;
            if grid.iter().copied().all(ItemStack::is_empty) {
                return;
            }
            for (recipe_index, recipe) in RECIPES.iter().enumerate() {
                let item = match recipe {
                    Recipe::Shaped(shaped) => shaped.check(grid),
                    Recipe::Shapeless(shapeless) => shapeless.check(grid),
                };
                if let Some(item) = item {
                    self.current_recipe = Some((recipe_index, item));
                    break;
                }
            }
        }
        /// If there is a selected recipe, consume the recipe items from the given inventory,
        /// this inventory should be coherent with the one that selected this recipe through
        /// the `update` method. You need to call the `update` method again in order to update
        /// the tracker for the new inventory.
        pub fn consume(&self, grid: &mut [ItemStack; 9]) {
            if self.current_recipe.is_none() {
                return;
            }
            for stack in grid.iter_mut() {
                if stack.is_empty() || stack.size == 1 {
                    *stack = ItemStack::EMPTY;
                } else {
                    *stack = stack.with_size(stack.size - 1);
                }
            }
        }
        /// If a crafting recipe is currently selected, return the result item.
        pub fn recipe(&self) -> Option<ItemStack> {
            self.current_recipe.map(|(_, item)| item)
        }
    }
    const EMPTY: ItemStack = ItemStack::EMPTY;
    const PAPER_3: ItemStack = ItemStack::new_sized(item::PAPER, 0, 3);
    const FENCE_2: ItemStack = ItemStack::new_block_sized(block::FENCE, 0, 2);
    const STONE_SLAB_3: ItemStack = ItemStack::new_block_sized(block::SLAB, 0, 3);
    const SANDSTONE_SLAB_3: ItemStack = ItemStack::new_block_sized(block::SLAB, 1, 3);
    const WOOD_SLAB_3: ItemStack = ItemStack::new_block_sized(block::SLAB, 2, 3);
    const COBBLESTONE_SLAB_3: ItemStack = ItemStack::new_block_sized(block::SLAB, 3, 3);
    const LADDER_2: ItemStack = ItemStack::new_block_sized(block::LADDER, 0, 2);
    const TRAPDOOR_2: ItemStack = ItemStack::new_block_sized(block::TRAPDOOR, 0, 2);
    const WOOD_4: ItemStack = ItemStack::new_block_sized(block::WOOD, 0, 4);
    const STICK_4: ItemStack = ItemStack::new_sized(item::STICK, 0, 4);
    const TORCH_4: ItemStack = ItemStack::new_block_sized(block::TORCH, 0, 4);
    const CHARCOAL: ItemStack = ItemStack::new_single(item::COAL, 1);
    const BOWL_4: ItemStack = ItemStack::new_sized(item::BOWL, 0, 4);
    const RAIL_16: ItemStack = ItemStack::new_block_sized(block::RAIL, 0, 16);
    const POWERED_RAIL_6: ItemStack = ItemStack::new_block_sized(
        block::POWERED_RAIL,
        0,
        6,
    );
    const DETECTOR_RAIL_6: ItemStack = ItemStack::new_block_sized(
        block::DETECTOR_RAIL,
        0,
        6,
    );
    const WOOD_STAIR_4: ItemStack = ItemStack::new_block_sized(block::WOOD_STAIR, 0, 4);
    const COBBLESTONE_STAIR_4: ItemStack = ItemStack::new_block_sized(
        block::COBBLESTONE_STAIR,
        0,
        4,
    );
    const ARROW_4: ItemStack = ItemStack::new_sized(item::ARROW, 0, 4);
    const LAPIS: ItemStack = ItemStack::new_single(item::DYE, 4);
    const COOKIE_8: ItemStack = ItemStack::new_sized(item::COOKIE, 0, 8);
    const COCOA: ItemStack = ItemStack::new_single(item::DYE, 3);
    const YELLOW_DYE_2: ItemStack = ItemStack::new_sized(item::DYE, 11, 2);
    const RED_DYE_2: ItemStack = ItemStack::new_sized(item::DYE, 1, 2);
    const BONE_MEAL_2: ItemStack = ItemStack::new_sized(item::DYE, 15, 3);
    const SUGAR_CANES: ItemStack = ItemStack {
        id: item::SUGAR_CANES as u16,
        size: 1,
        damage: 0,
    };
    const PAPER: ItemStack = ItemStack {
        id: item::PAPER as u16,
        size: 1,
        damage: 0,
    };
    const BOOK: ItemStack = ItemStack {
        id: item::BOOK as u16,
        size: 1,
        damage: 0,
    };
    const STICK: ItemStack = ItemStack {
        id: item::STICK as u16,
        size: 1,
        damage: 0,
    };
    const DIAMOND: ItemStack = ItemStack {
        id: item::DIAMOND as u16,
        size: 1,
        damage: 0,
    };
    const WOOD: ItemStack = ItemStack {
        id: block::WOOD as u16,
        size: 1,
        damage: 0,
    };
    const JUKEBOX: ItemStack = ItemStack {
        id: block::JUKEBOX as u16,
        size: 1,
        damage: 0,
    };
    const REDSTONE: ItemStack = ItemStack {
        id: item::REDSTONE as u16,
        size: 1,
        damage: 0,
    };
    const NOTE_BLOCK: ItemStack = ItemStack {
        id: block::NOTE_BLOCK as u16,
        size: 1,
        damage: 0,
    };
    const BOOKSHELF: ItemStack = ItemStack {
        id: block::BOOKSHELF as u16,
        size: 1,
        damage: 0,
    };
    const SNOWBALL: ItemStack = ItemStack {
        id: item::SNOWBALL as u16,
        size: 1,
        damage: 0,
    };
    const SNOW_BLOCK: ItemStack = ItemStack {
        id: block::SNOW_BLOCK as u16,
        size: 1,
        damage: 0,
    };
    const CLAY: ItemStack = ItemStack {
        id: item::CLAY as u16,
        size: 1,
        damage: 0,
    };
    const CLAY_BLOCK: ItemStack = ItemStack {
        id: block::CLAY as u16,
        size: 1,
        damage: 0,
    };
    const BRICK: ItemStack = ItemStack {
        id: item::BRICK as u16,
        size: 1,
        damage: 0,
    };
    const BRICK_BLOCK: ItemStack = ItemStack {
        id: block::BRICK as u16,
        size: 1,
        damage: 0,
    };
    const GLOWSTONE_DUST: ItemStack = ItemStack {
        id: item::GLOWSTONE_DUST as u16,
        size: 1,
        damage: 0,
    };
    const GLOWSTONE: ItemStack = ItemStack {
        id: block::GLOWSTONE as u16,
        size: 1,
        damage: 0,
    };
    const STRING: ItemStack = ItemStack {
        id: item::STRING as u16,
        size: 1,
        damage: 0,
    };
    const WOOL: ItemStack = ItemStack {
        id: block::WOOL as u16,
        size: 1,
        damage: 0,
    };
    const GUNPOWDER: ItemStack = ItemStack {
        id: item::GUNPOWDER as u16,
        size: 1,
        damage: 0,
    };
    const SAND: ItemStack = ItemStack {
        id: block::SAND as u16,
        size: 1,
        damage: 0,
    };
    const TNT: ItemStack = ItemStack {
        id: block::TNT as u16,
        size: 1,
        damage: 0,
    };
    const BED: ItemStack = ItemStack {
        id: item::BED as u16,
        size: 1,
        damage: 0,
    };
    const STONE: ItemStack = ItemStack {
        id: block::STONE as u16,
        size: 1,
        damage: 0,
    };
    const SANDSTONE: ItemStack = ItemStack {
        id: block::SANDSTONE as u16,
        size: 1,
        damage: 0,
    };
    const COBBLE: ItemStack = ItemStack {
        id: block::COBBLESTONE as u16,
        size: 1,
        damage: 0,
    };
    const WOOD_DOOR: ItemStack = ItemStack {
        id: item::WOOD_DOOR as u16,
        size: 1,
        damage: 0,
    };
    const IRON_DOOR: ItemStack = ItemStack {
        id: item::IRON_DOOR as u16,
        size: 1,
        damage: 0,
    };
    const IRON_INGOT: ItemStack = ItemStack {
        id: item::IRON_INGOT as u16,
        size: 1,
        damage: 0,
    };
    const SIGN: ItemStack = ItemStack {
        id: item::SIGN as u16,
        size: 1,
        damage: 0,
    };
    const SUGAR: ItemStack = ItemStack {
        id: item::SUGAR as u16,
        size: 1,
        damage: 0,
    };
    const MILK_BUCKET: ItemStack = ItemStack {
        id: item::MILK_BUCKET as u16,
        size: 1,
        damage: 0,
    };
    const WHEAT: ItemStack = ItemStack {
        id: item::WHEAT as u16,
        size: 1,
        damage: 0,
    };
    const EGG: ItemStack = ItemStack {
        id: item::EGG as u16,
        size: 1,
        damage: 0,
    };
    const CAKE: ItemStack = ItemStack {
        id: item::CAKE as u16,
        size: 1,
        damage: 0,
    };
    const LOG: ItemStack = ItemStack {
        id: block::LOG as u16,
        size: 1,
        damage: 0,
    };
    const COAL: ItemStack = ItemStack {
        id: item::COAL as u16,
        size: 1,
        damage: 0,
    };
    const GOLD_INGOT: ItemStack = ItemStack {
        id: item::GOLD_INGOT as u16,
        size: 1,
        damage: 0,
    };
    const STONE_PRESSURE_PLATE: ItemStack = ItemStack {
        id: block::STONE_PRESSURE_PLATE as u16,
        size: 1,
        damage: 0,
    };
    const MINECART: ItemStack = ItemStack {
        id: item::MINECART as u16,
        size: 1,
        damage: 0,
    };
    const PUMPKIN: ItemStack = ItemStack {
        id: block::PUMPKIN as u16,
        size: 1,
        damage: 0,
    };
    const TORCH: ItemStack = ItemStack {
        id: block::TORCH as u16,
        size: 1,
        damage: 0,
    };
    const PUMPKIN_LIT: ItemStack = ItemStack {
        id: block::PUMPKIN_LIT as u16,
        size: 1,
        damage: 0,
    };
    const CHEST_MINECART: ItemStack = ItemStack {
        id: item::CHEST_MINECART as u16,
        size: 1,
        damage: 0,
    };
    const FURNACE_MINECART: ItemStack = ItemStack {
        id: item::FURNACE_MINECART as u16,
        size: 1,
        damage: 0,
    };
    const CHEST: ItemStack = ItemStack {
        id: block::CHEST as u16,
        size: 1,
        damage: 0,
    };
    const FURNACE: ItemStack = ItemStack {
        id: block::FURNACE as u16,
        size: 1,
        damage: 0,
    };
    const BOAT: ItemStack = ItemStack {
        id: item::BOAT as u16,
        size: 1,
        damage: 0,
    };
    const BUCKET: ItemStack = ItemStack {
        id: item::BUCKET as u16,
        size: 1,
        damage: 0,
    };
    const FLINT_AND_STEEL: ItemStack = ItemStack {
        id: item::FLINT_AND_STEEL as u16,
        size: 1,
        damage: 0,
    };
    const FLINT: ItemStack = ItemStack {
        id: item::FLINT as u16,
        size: 1,
        damage: 0,
    };
    const BREAD: ItemStack = ItemStack {
        id: item::BREAD as u16,
        size: 1,
        damage: 0,
    };
    const FISHING_ROD: ItemStack = ItemStack {
        id: item::FISHING_ROD as u16,
        size: 1,
        damage: 0,
    };
    const PAINTING: ItemStack = ItemStack {
        id: item::PAINTING as u16,
        size: 1,
        damage: 0,
    };
    const APPLE: ItemStack = ItemStack {
        id: item::APPLE as u16,
        size: 1,
        damage: 0,
    };
    const GOLD_APPLE: ItemStack = ItemStack {
        id: item::GOLD_APPLE as u16,
        size: 1,
        damage: 0,
    };
    const LEVER: ItemStack = ItemStack {
        id: block::LEVER as u16,
        size: 1,
        damage: 0,
    };
    const REDSTONE_TORCH: ItemStack = ItemStack {
        id: block::REDSTONE_TORCH_LIT as u16,
        size: 1,
        damage: 0,
    };
    const REPEATER: ItemStack = ItemStack {
        id: item::REPEATER as u16,
        size: 1,
        damage: 0,
    };
    const CLOCK: ItemStack = ItemStack {
        id: item::CLOCK as u16,
        size: 1,
        damage: 0,
    };
    const COMPASS: ItemStack = ItemStack {
        id: item::COMPASS as u16,
        size: 1,
        damage: 0,
    };
    const MAP: ItemStack = ItemStack {
        id: item::MAP as u16,
        size: 1,
        damage: 0,
    };
    const BUTTON: ItemStack = ItemStack {
        id: block::BUTTON as u16,
        size: 1,
        damage: 0,
    };
    const WOOD_PRESSURE_PLATE: ItemStack = ItemStack {
        id: block::WOOD_PRESSURE_PLATE as u16,
        size: 1,
        damage: 0,
    };
    const DISPENSER: ItemStack = ItemStack {
        id: block::DISPENSER as u16,
        size: 1,
        damage: 0,
    };
    const BOW: ItemStack = ItemStack {
        id: item::BOW as u16,
        size: 1,
        damage: 0,
    };
    const FEATHER: ItemStack = ItemStack {
        id: item::FEATHER as u16,
        size: 1,
        damage: 0,
    };
    const PISTON: ItemStack = ItemStack {
        id: block::PISTON as u16,
        size: 1,
        damage: 0,
    };
    const STICKY_PISTON: ItemStack = ItemStack {
        id: block::STICKY_PISTON as u16,
        size: 1,
        damage: 0,
    };
    const SLIMEBALL: ItemStack = ItemStack {
        id: item::SLIMEBALL as u16,
        size: 1,
        damage: 0,
    };
    const SHEARS: ItemStack = ItemStack {
        id: item::SHEARS as u16,
        size: 1,
        damage: 0,
    };
    const BOWL: ItemStack = ItemStack {
        id: item::BOWL as u16,
        size: 1,
        damage: 0,
    };
    const MUSHROOM_STEW: ItemStack = ItemStack {
        id: item::MUSHROOM_STEW as u16,
        size: 1,
        damage: 0,
    };
    const BROWN_MUSHROOM: ItemStack = ItemStack {
        id: block::BROWN_MUSHROOM as u16,
        size: 1,
        damage: 0,
    };
    const RED_MUSHROOM: ItemStack = ItemStack {
        id: block::RED_MUSHROOM as u16,
        size: 1,
        damage: 0,
    };
    const CRAFTING_TABLE: ItemStack = ItemStack {
        id: block::CRAFTING_TABLE as u16,
        size: 1,
        damage: 0,
    };
    const LEATHER: ItemStack = ItemStack {
        id: item::LEATHER as u16,
        size: 1,
        damage: 0,
    };
    const DANDELION: ItemStack = ItemStack {
        id: block::DANDELION as u16,
        size: 1,
        damage: 0,
    };
    const POPPY: ItemStack = ItemStack {
        id: block::POPPY as u16,
        size: 1,
        damage: 0,
    };
    const BONE: ItemStack = ItemStack {
        id: item::BONE as u16,
        size: 1,
        damage: 0,
    };
    const RECIPES: &'static [Recipe] = &[
        Recipe::new_shaped(PAPER_3, &[SUGAR_CANES, SUGAR_CANES, SUGAR_CANES], 3),
        Recipe::new_shaped(BOOK, &[PAPER, PAPER, PAPER], 1),
        Recipe::new_shaped(FENCE_2, &[STICK, STICK, STICK, STICK, STICK, STICK], 3),
        Recipe::new_shaped(
            JUKEBOX,
            &[WOOD, WOOD, WOOD, WOOD, DIAMOND, WOOD, WOOD, WOOD, WOOD],
            3,
        ),
        Recipe::new_shaped(
            NOTE_BLOCK,
            &[WOOD, WOOD, WOOD, WOOD, REDSTONE, WOOD, WOOD, WOOD, WOOD],
            3,
        ),
        Recipe::new_shaped(
            BOOKSHELF,
            &[WOOD, WOOD, WOOD, BOOK, BOOK, BOOK, WOOD, WOOD, WOOD],
            3,
        ),
        Recipe::new_shaped(SNOW_BLOCK, &[SNOWBALL, SNOWBALL, SNOWBALL, SNOWBALL], 2),
        Recipe::new_shaped(CLAY_BLOCK, &[CLAY, CLAY, CLAY, CLAY], 2),
        Recipe::new_shaped(BRICK_BLOCK, &[BRICK, BRICK, BRICK, BRICK], 2),
        Recipe::new_shaped(
            GLOWSTONE,
            &[GLOWSTONE_DUST, GLOWSTONE_DUST, GLOWSTONE_DUST, GLOWSTONE_DUST],
            2,
        ),
        Recipe::new_shaped(WOOL, &[STRING, STRING, STRING, STRING], 2),
        Recipe::new_shaped(
            TNT,
            &[
                GUNPOWDER,
                SAND,
                GUNPOWDER,
                SAND,
                GUNPOWDER,
                SAND,
                GUNPOWDER,
                SAND,
                GUNPOWDER,
            ],
            3,
        ),
        Recipe::new_shaped(STONE_SLAB_3, &[STONE, STONE, STONE], 3),
        Recipe::new_shaped(SANDSTONE_SLAB_3, &[SANDSTONE, SANDSTONE, SANDSTONE], 3),
        Recipe::new_shaped(WOOD_SLAB_3, &[WOOD, WOOD, WOOD], 3),
        Recipe::new_shaped(COBBLESTONE_SLAB_3, &[COBBLE, COBBLE, COBBLE], 3),
        Recipe::new_shaped(
            LADDER_2,
            &[STICK, EMPTY, STICK, STICK, STICK, STICK, STICK, EMPTY, STICK],
            3,
        ),
        Recipe::new_shaped(WOOD_DOOR, &[WOOD, WOOD, WOOD, WOOD, WOOD, WOOD], 2),
        Recipe::new_shaped(TRAPDOOR_2, &[WOOD, WOOD, WOOD, WOOD, WOOD, WOOD], 3),
        Recipe::new_shaped(
            IRON_DOOR,
            &[IRON_INGOT, IRON_INGOT, IRON_INGOT, IRON_INGOT, IRON_INGOT, IRON_INGOT],
            2,
        ),
        Recipe::new_shaped(
            SIGN,
            &[WOOD, WOOD, WOOD, WOOD, WOOD, WOOD, EMPTY, STICK, EMPTY],
            3,
        ),
        Recipe::new_shaped(
            CAKE,
            &[
                MILK_BUCKET,
                MILK_BUCKET,
                MILK_BUCKET,
                SUGAR,
                EGG,
                SUGAR,
                WHEAT,
                WHEAT,
                WHEAT,
            ],
            3,
        ),
        Recipe::new_shaped(SUGAR, &[SUGAR_CANES], 1),
        Recipe::new_shaped(WOOD_4, &[LOG], 1),
        Recipe::new_shaped(STICK_4, &[WOOD, WOOD], 1),
        Recipe::new_shaped(TORCH_4, &[COAL, STICK], 1),
        Recipe::new_shaped(TORCH_4, &[CHARCOAL, STICK], 1),
        Recipe::new_shaped(BOWL_4, &[WOOD, EMPTY, WOOD, EMPTY, WOOD, EMPTY], 3),
        Recipe::new_shaped(
            RAIL_16,
            &[
                IRON_INGOT,
                EMPTY,
                IRON_INGOT,
                IRON_INGOT,
                STICK,
                IRON_INGOT,
                IRON_INGOT,
                EMPTY,
                IRON_INGOT,
            ],
            3,
        ),
        Recipe::new_shaped(
            POWERED_RAIL_6,
            &[
                GOLD_INGOT,
                EMPTY,
                GOLD_INGOT,
                GOLD_INGOT,
                STICK,
                GOLD_INGOT,
                GOLD_INGOT,
                REDSTONE,
                GOLD_INGOT,
            ],
            3,
        ),
        Recipe::new_shaped(
            DETECTOR_RAIL_6,
            &[
                IRON_INGOT,
                EMPTY,
                IRON_INGOT,
                IRON_INGOT,
                STONE_PRESSURE_PLATE,
                IRON_INGOT,
                IRON_INGOT,
                REDSTONE,
                IRON_INGOT,
            ],
            3,
        ),
        Recipe::new_shaped(
            MINECART,
            &[IRON_INGOT, EMPTY, IRON_INGOT, IRON_INGOT, IRON_INGOT, IRON_INGOT],
            3,
        ),
        Recipe::new_shaped(PUMPKIN_LIT, &[PUMPKIN, TORCH], 1),
        Recipe::new_shaped(CHEST_MINECART, &[CHEST, MINECART], 1),
        Recipe::new_shaped(FURNACE_MINECART, &[FURNACE, MINECART], 1),
        Recipe::new_shaped(BOAT, &[WOOD, EMPTY, WOOD, WOOD, WOOD, WOOD], 3),
        Recipe::new_shaped(
            BUCKET,
            &[IRON_INGOT, EMPTY, IRON_INGOT, EMPTY, IRON_INGOT, EMPTY],
            3,
        ),
        Recipe::new_shaped(FLINT_AND_STEEL, &[IRON_INGOT, EMPTY, EMPTY, FLINT], 2),
        Recipe::new_shaped(BREAD, &[WHEAT, WHEAT, WHEAT], 3),
        Recipe::new_shaped(
            WOOD_STAIR_4,
            &[WOOD, EMPTY, EMPTY, WOOD, WOOD, EMPTY, WOOD, WOOD, WOOD],
            3,
        ),
        Recipe::new_shaped(
            FISHING_ROD,
            &[EMPTY, EMPTY, STICK, EMPTY, STICK, STRING, STICK, EMPTY, STRING],
            3,
        ),
        Recipe::new_shaped(
            COBBLESTONE_STAIR_4,
            &[COBBLE, EMPTY, EMPTY, COBBLE, COBBLE, EMPTY, COBBLE, COBBLE, COBBLE],
            3,
        ),
        Recipe::new_shaped(
            PAINTING,
            &[STICK, STICK, STICK, STICK, WOOL, STICK, STICK, STICK, STICK],
            3,
        ),
        Recipe::new_shaped(
            GOLD_APPLE,
            &[
                GOLD_INGOT,
                GOLD_INGOT,
                GOLD_INGOT,
                GOLD_INGOT,
                APPLE,
                GOLD_INGOT,
                GOLD_INGOT,
                GOLD_INGOT,
            ],
            3,
        ),
        Recipe::new_shaped(LEVER, &[STICK, COBBLE], 1),
        Recipe::new_shaped(REDSTONE_TORCH, &[REDSTONE, STICK], 1),
        Recipe::new_shaped(
            REPEATER,
            &[REDSTONE_TORCH, REDSTONE, REDSTONE_TORCH, STONE, STONE, STONE],
            3,
        ),
        Recipe::new_shaped(
            CLOCK,
            &[
                EMPTY,
                GOLD_INGOT,
                EMPTY,
                GOLD_INGOT,
                REDSTONE,
                GOLD_INGOT,
                EMPTY,
                GOLD_INGOT,
                EMPTY,
            ],
            3,
        ),
        Recipe::new_shaped(
            COMPASS,
            &[
                EMPTY,
                IRON_INGOT,
                EMPTY,
                IRON_INGOT,
                REDSTONE,
                IRON_INGOT,
                EMPTY,
                IRON_INGOT,
                EMPTY,
            ],
            3,
        ),
        Recipe::new_shaped(
            MAP,
            &[PAPER, PAPER, PAPER, PAPER, COMPASS, PAPER, PAPER, PAPER, PAPER],
            3,
        ),
        Recipe::new_shaped(BUTTON, &[STONE, STONE], 1),
        Recipe::new_shaped(STONE_PRESSURE_PLATE, &[STONE, STONE], 2),
        Recipe::new_shaped(WOOD_PRESSURE_PLATE, &[WOOD, WOOD], 2),
        Recipe::new_shaped(
            DISPENSER,
            &[COBBLE, COBBLE, COBBLE, COBBLE, BOW, COBBLE, COBBLE, REDSTONE, COBBLE],
            3,
        ),
        Recipe::new_shaped(
            PISTON,
            &[WOOD, WOOD, WOOD, COBBLE, IRON_INGOT, COBBLE, COBBLE, REDSTONE, COBBLE],
            3,
        ),
        Recipe::new_shaped(STICKY_PISTON, &[SLIMEBALL, PISTON], 1),
        Recipe::new_shaped(BED, &[WOOL, WOOL, WOOL, WOOD, WOOD], 3),
        Recipe::new_shaped(SHEARS, &[IRON_INGOT, EMPTY, EMPTY, IRON_INGOT], 2),
        Recipe::new_shaped(
            BOW,
            &[EMPTY, STICK, STRING, STICK, EMPTY, STRING, EMPTY, STICK, STRING],
            3,
        ),
        Recipe::new_shaped(ARROW_4, &[FLINT, STICK, FEATHER], 1),
        Recipe::new_shaped(MUSHROOM_STEW, &[RED_MUSHROOM, BROWN_MUSHROOM, BOWL], 1),
        Recipe::new_shaped(MUSHROOM_STEW, &[BROWN_MUSHROOM, RED_MUSHROOM, BOWL], 1),
        Recipe::new_shaped(COOKIE_8, &[WHEAT, COCOA, WHEAT], 3),
        Recipe::new_shaped(
            CHEST,
            &[WOOD, WOOD, WOOD, WOOD, EMPTY, WOOD, WOOD, WOOD, WOOD],
            3,
        ),
        Recipe::new_shaped(
            FURNACE,
            &[COBBLE, COBBLE, COBBLE, COBBLE, EMPTY, COBBLE, COBBLE, COBBLE, COBBLE],
            3,
        ),
        Recipe::new_shaped(CRAFTING_TABLE, &[WOOD, WOOD, WOOD, WOOD], 2),
        Recipe::new_shaped(SANDSTONE, &[SAND, SAND, SAND, SAND], 2),
        Recipe::new_shaped(
            ItemStack::new_single(item::WOOD_PICKAXE, 0),
            &[WOOD, WOOD, WOOD, EMPTY, STICK, EMPTY, EMPTY, STICK, EMPTY],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::STONE_PICKAXE, 0),
            &[COBBLE, COBBLE, COBBLE, EMPTY, STICK, EMPTY, EMPTY, STICK, EMPTY],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::GOLD_PICKAXE, 0),
            &[
                GOLD_INGOT,
                GOLD_INGOT,
                GOLD_INGOT,
                EMPTY,
                STICK,
                EMPTY,
                EMPTY,
                STICK,
                EMPTY,
            ],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::IRON_PICKAXE, 0),
            &[
                IRON_INGOT,
                IRON_INGOT,
                IRON_INGOT,
                EMPTY,
                STICK,
                EMPTY,
                EMPTY,
                STICK,
                EMPTY,
            ],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::DIAMOND_PICKAXE, 0),
            &[DIAMOND, DIAMOND, DIAMOND, EMPTY, STICK, EMPTY, EMPTY, STICK, EMPTY],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::WOOD_AXE, 0),
            &[WOOD, WOOD, STICK, WOOD, STICK, EMPTY],
            2,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::STONE_AXE, 0),
            &[COBBLE, COBBLE, STICK, COBBLE, STICK, EMPTY],
            2,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::GOLD_AXE, 0),
            &[GOLD_INGOT, GOLD_INGOT, STICK, GOLD_INGOT, STICK, EMPTY],
            2,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::IRON_AXE, 0),
            &[IRON_INGOT, IRON_INGOT, STICK, IRON_INGOT, STICK, EMPTY],
            2,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::DIAMOND_AXE, 0),
            &[DIAMOND, DIAMOND, STICK, DIAMOND, STICK, EMPTY],
            2,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::WOOD_SHOVEL, 0),
            &[WOOD, STICK, STICK],
            1,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::STONE_SHOVEL, 0),
            &[COBBLE, STICK, STICK],
            1,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::GOLD_SHOVEL, 0),
            &[GOLD_INGOT, STICK, STICK],
            1,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::IRON_SHOVEL, 0),
            &[IRON_INGOT, STICK, STICK],
            1,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::DIAMOND_SHOVEL, 0),
            &[DIAMOND, STICK, STICK],
            1,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::WOOD_HOE, 0),
            &[WOOD, WOOD, STICK, EMPTY, STICK, EMPTY],
            2,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::STONE_HOE, 0),
            &[COBBLE, COBBLE, STICK, EMPTY, STICK, EMPTY],
            2,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::GOLD_HOE, 0),
            &[GOLD_INGOT, GOLD_INGOT, STICK, EMPTY, STICK, EMPTY],
            2,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::IRON_HOE, 0),
            &[IRON_INGOT, IRON_INGOT, STICK, EMPTY, STICK, EMPTY],
            2,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::DIAMOND_HOE, 0),
            &[DIAMOND, DIAMOND, STICK, EMPTY, STICK, EMPTY],
            2,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::WOOD_SWORD, 0),
            &[WOOD, WOOD, STICK],
            1,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::STONE_SWORD, 0),
            &[COBBLE, COBBLE, STICK],
            1,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::GOLD_SWORD, 0),
            &[GOLD_INGOT, GOLD_INGOT, STICK],
            1,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::IRON_SWORD, 0),
            &[IRON_INGOT, IRON_INGOT, STICK],
            1,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::DIAMOND_SWORD, 0),
            &[DIAMOND, DIAMOND, STICK],
            1,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::LEATHER_HELMET, 0),
            &[LEATHER, LEATHER, LEATHER, LEATHER, EMPTY, LEATHER],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::GOLD_HELMET, 0),
            &[GOLD_INGOT, GOLD_INGOT, GOLD_INGOT, GOLD_INGOT, EMPTY, GOLD_INGOT],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::IRON_HELMET, 0),
            &[IRON_INGOT, IRON_INGOT, IRON_INGOT, IRON_INGOT, EMPTY, IRON_INGOT],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::DIAMOND_HELMET, 0),
            &[DIAMOND, DIAMOND, DIAMOND, DIAMOND, EMPTY, DIAMOND],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::LEATHER_CHESTPLATE, 0),
            &[
                LEATHER,
                EMPTY,
                LEATHER,
                LEATHER,
                LEATHER,
                LEATHER,
                LEATHER,
                LEATHER,
                LEATHER,
            ],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::GOLD_CHESTPLATE, 0),
            &[
                GOLD_INGOT,
                EMPTY,
                GOLD_INGOT,
                GOLD_INGOT,
                GOLD_INGOT,
                GOLD_INGOT,
                GOLD_INGOT,
                GOLD_INGOT,
                GOLD_INGOT,
            ],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::IRON_CHESTPLATE, 0),
            &[
                IRON_INGOT,
                EMPTY,
                IRON_INGOT,
                IRON_INGOT,
                IRON_INGOT,
                IRON_INGOT,
                IRON_INGOT,
                IRON_INGOT,
                IRON_INGOT,
            ],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::DIAMOND_CHESTPLATE, 0),
            &[
                DIAMOND,
                EMPTY,
                DIAMOND,
                DIAMOND,
                DIAMOND,
                DIAMOND,
                DIAMOND,
                DIAMOND,
                DIAMOND,
            ],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::LEATHER_LEGGINGS, 0),
            &[
                LEATHER,
                LEATHER,
                LEATHER,
                LEATHER,
                EMPTY,
                LEATHER,
                LEATHER,
                EMPTY,
                LEATHER,
            ],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::GOLD_LEGGINGS, 0),
            &[
                GOLD_INGOT,
                GOLD_INGOT,
                GOLD_INGOT,
                GOLD_INGOT,
                EMPTY,
                GOLD_INGOT,
                GOLD_INGOT,
                EMPTY,
                GOLD_INGOT,
            ],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::IRON_LEGGINGS, 0),
            &[
                IRON_INGOT,
                IRON_INGOT,
                IRON_INGOT,
                IRON_INGOT,
                EMPTY,
                IRON_INGOT,
                IRON_INGOT,
                EMPTY,
                IRON_INGOT,
            ],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::DIAMOND_LEGGINGS, 0),
            &[
                DIAMOND,
                DIAMOND,
                DIAMOND,
                DIAMOND,
                EMPTY,
                DIAMOND,
                DIAMOND,
                EMPTY,
                DIAMOND,
            ],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::LEATHER_BOOTS, 0),
            &[LEATHER, EMPTY, LEATHER, LEATHER, EMPTY, LEATHER],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::GOLD_BOOTS, 0),
            &[GOLD_INGOT, EMPTY, GOLD_INGOT, GOLD_INGOT, EMPTY, GOLD_INGOT],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::IRON_BOOTS, 0),
            &[IRON_INGOT, EMPTY, IRON_INGOT, IRON_INGOT, EMPTY, IRON_INGOT],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_single(item::DIAMOND_BOOTS, 0),
            &[DIAMOND, EMPTY, DIAMOND, DIAMOND, EMPTY, DIAMOND],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_block(block::IRON_BLOCK, 0),
            &[
                IRON_INGOT,
                IRON_INGOT,
                IRON_INGOT,
                IRON_INGOT,
                IRON_INGOT,
                IRON_INGOT,
                IRON_INGOT,
                IRON_INGOT,
                IRON_INGOT,
            ],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_block(block::GOLD_BLOCK, 0),
            &[
                GOLD_INGOT,
                GOLD_INGOT,
                GOLD_INGOT,
                GOLD_INGOT,
                GOLD_INGOT,
                GOLD_INGOT,
                GOLD_INGOT,
                GOLD_INGOT,
                GOLD_INGOT,
            ],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_block(block::DIAMOND_BLOCK, 0),
            &[
                DIAMOND,
                DIAMOND,
                DIAMOND,
                DIAMOND,
                DIAMOND,
                DIAMOND,
                DIAMOND,
                DIAMOND,
                DIAMOND,
            ],
            3,
        ),
        Recipe::new_shaped(
            ItemStack::new_block(block::LAPIS_BLOCK, 0),
            &[LAPIS, LAPIS, LAPIS, LAPIS, LAPIS, LAPIS, LAPIS, LAPIS, LAPIS],
            3,
        ),
        Recipe::new_shaped(
            IRON_INGOT.with_size(9),
            &[ItemStack::new_block(block::IRON_BLOCK, 0)],
            1,
        ),
        Recipe::new_shaped(
            GOLD_INGOT.with_size(9),
            &[ItemStack::new_block(block::GOLD_BLOCK, 0)],
            1,
        ),
        Recipe::new_shaped(
            DIAMOND.with_size(9),
            &[ItemStack::new_block(block::DIAMOND_BLOCK, 0)],
            1,
        ),
        Recipe::new_shaped(
            LAPIS.with_size(9),
            &[ItemStack::new_block(block::LAPIS_BLOCK, 0)],
            1,
        ),
        Recipe::new_shapeless(YELLOW_DYE_2, &[DANDELION]),
        Recipe::new_shapeless(RED_DYE_2, &[POPPY]),
        Recipe::new_shapeless(BONE_MEAL_2, &[BONE]),
        Recipe::new_shapeless(
            ItemStack::new_sized(item::DYE, 9, 2),
            &[ItemStack::new_single(item::DYE, 1), ItemStack::new_single(item::DYE, 15)],
        ),
        Recipe::new_shapeless(
            ItemStack::new_sized(item::DYE, 14, 2),
            &[ItemStack::new_single(item::DYE, 1), ItemStack::new_single(item::DYE, 11)],
        ),
        Recipe::new_shapeless(
            ItemStack::new_sized(item::DYE, 10, 2),
            &[ItemStack::new_single(item::DYE, 2), ItemStack::new_single(item::DYE, 15)],
        ),
        Recipe::new_shapeless(
            ItemStack::new_sized(item::DYE, 8, 2),
            &[ItemStack::new_single(item::DYE, 0), ItemStack::new_single(item::DYE, 15)],
        ),
        Recipe::new_shapeless(
            ItemStack::new_sized(item::DYE, 7, 2),
            &[ItemStack::new_single(item::DYE, 8), ItemStack::new_single(item::DYE, 15)],
        ),
        Recipe::new_shapeless(
            ItemStack::new_sized(item::DYE, 7, 3),
            &[
                ItemStack::new_single(item::DYE, 0),
                ItemStack::new_single(item::DYE, 15),
                ItemStack::new_single(item::DYE, 15),
            ],
        ),
        Recipe::new_shapeless(
            ItemStack::new_sized(item::DYE, 12, 2),
            &[ItemStack::new_single(item::DYE, 4), ItemStack::new_single(item::DYE, 15)],
        ),
        Recipe::new_shapeless(
            ItemStack::new_sized(item::DYE, 6, 2),
            &[ItemStack::new_single(item::DYE, 4), ItemStack::new_single(item::DYE, 2)],
        ),
        Recipe::new_shapeless(
            ItemStack::new_sized(item::DYE, 5, 2),
            &[ItemStack::new_single(item::DYE, 4), ItemStack::new_single(item::DYE, 1)],
        ),
        Recipe::new_shapeless(
            ItemStack::new_sized(item::DYE, 13, 2),
            &[ItemStack::new_single(item::DYE, 5), ItemStack::new_single(item::DYE, 9)],
        ),
        Recipe::new_shapeless(
            ItemStack::new_sized(item::DYE, 13, 3),
            &[
                ItemStack::new_single(item::DYE, 4),
                ItemStack::new_single(item::DYE, 1),
                ItemStack::new_single(item::DYE, 9),
            ],
        ),
        Recipe::new_shapeless(
            ItemStack::new_sized(item::DYE, 13, 4),
            &[
                ItemStack::new_single(item::DYE, 4),
                ItemStack::new_single(item::DYE, 1),
                ItemStack::new_single(item::DYE, 1),
                ItemStack::new_single(item::DYE, 15),
            ],
        ),
    ];
    /// The recipe enumeration stores different types of recipes.
    ///
    /// **Note that crafting recipes currently ignore the stack size in of patterns.**
    enum Recipe {
        /// A shaped crafting recipe requires the items to be in a specific pattern, the
        /// pattern has a size and if smaller than 3x3 it can be moved everywhere in the
        /// table.
        Shaped(ShapedRecipe),
        /// A shapeless crafting just define a list of items that must be present in the
        /// crafting grid, each stack must be present once.
        Shapeless(ShapelessRecipe),
    }
    struct ShapedRecipe {
        result: ItemStack,
        pattern: &'static [ItemStack],
        width: u8,
    }
    struct ShapelessRecipe {
        result: ItemStack,
        pattern: &'static [ItemStack],
    }
    impl Recipe {
        const fn new_shaped(
            result: ItemStack,
            pattern: &'static [ItemStack],
            width: u8,
        ) -> Self {
            Self::Shaped(ShapedRecipe {
                result,
                pattern,
                width,
            })
        }
        const fn new_shapeless(
            result: ItemStack,
            pattern: &'static [ItemStack],
        ) -> Self {
            Self::Shapeless(ShapelessRecipe { result, pattern })
        }
    }
    impl ShapedRecipe {
        /// Check if this shaped recipe can be crafted with the given inventory of the given
        /// size and items.
        fn check(&self, grid: &[ItemStack; 9]) -> Option<ItemStack> {
            let recipe_width = self.width as usize;
            let recipe_height = (self.pattern.len() + recipe_width - 1) / recipe_width;
            if recipe_width > 3 || recipe_height > 3 {
                return None;
            }
            for start_x in 0..=(3 - recipe_width) {
                'out: for start_y in 0..=(3 - recipe_height) {
                    let mut normal_valid = true;
                    let mut flip_valid = true;
                    for dx in 0..3 {
                        for dy in 0..3 {
                            let stack = grid[dx + dy * 3];
                            if dx < start_x || dx >= start_x + recipe_width
                                || dy < start_y || dy >= start_y + recipe_height
                            {
                                if !stack.is_empty() {
                                    continue 'out;
                                }
                            } else {
                                let pattern_x = dx - start_x;
                                let pattern_y = dy - start_y;
                                let flip_pattern_x = recipe_width - pattern_x - 1;
                                if normal_valid {
                                    let normal_stack = self
                                        .pattern[pattern_x + pattern_y * recipe_width];
                                    normal_valid = (normal_stack.is_empty() && stack.is_empty())
                                        || (!stack.is_empty()
                                            && (normal_stack.id, normal_stack.damage)
                                                == (stack.id, stack.damage));
                                }
                                if flip_valid {
                                    let flip_stack = self
                                        .pattern[flip_pattern_x + pattern_y * recipe_width];
                                    flip_valid = (flip_stack.is_empty() && stack.is_empty())
                                        || (!stack.is_empty()
                                            && (flip_stack.id, flip_stack.damage)
                                                == (stack.id, stack.damage));
                                }
                                if !normal_valid && !flip_valid {
                                    continue 'out;
                                }
                            }
                        }
                    }
                    if normal_valid || flip_valid {
                        return Some(self.result);
                    }
                }
            }
            None
        }
    }
    impl ShapelessRecipe {
        /// Check if this shapeless recipe can be crafted with the given inventory items.
        fn check(&self, inv: &[ItemStack; 9]) -> Option<ItemStack> {
            if inv.len() < self.pattern.len() {
                return None;
            }
            let mut pat_matched = 0u32;
            'inv: for stack in inv.iter().copied() {
                if !stack.is_empty() {
                    for (i, pat_stack) in self.pattern.iter().copied().enumerate() {
                        if pat_matched & (1 << i) == 0 {
                            if (pat_stack.id, pat_stack.damage)
                                == (stack.id, stack.damage)
                            {
                                pat_matched |= 1 << i;
                                continue 'inv;
                            }
                        }
                    }
                    return None;
                }
            }
            if pat_matched != (1 << self.pattern.len()) - 1 {
                None
            } else {
                Some(self.result)
            }
        }
    }
}
pub mod smelt {
    //! Item smelting management.
    use crate::block::material::Material;
    use crate::item::ItemStack;
    use crate::{block, item};
    /// Find a smelting recipe output from given input item/damage.
    pub fn find_smelting_output(id: u16, damage: u16) -> Option<ItemStack> {
        for recipe in RECIPES {
            if (recipe.input.id, recipe.input.damage) == (id, damage) {
                return Some(recipe.output);
            }
        }
        None
    }
    /// Get burn time of the given item id, returning 0 if the given item id is not a fuel.
    pub fn get_burn_ticks(id: u16) -> u16 {
        if let Ok(id) = u8::try_from(id) {
            match id {
                block::SAPLING => 100,
                _ if block::material::get_material(id) == Material::Wood => 300,
                _ => 0,
            }
        } else {
            match id {
                item::COAL => 1600,
                item::LAVA_BUCKET => 20000,
                item::STICK => 100,
                _ => 0,
            }
        }
    }
    const RECIPES: &'static [Recipe] = &[
        Recipe::new(
            ItemStack::new_block(block::IRON_ORE, 0),
            ItemStack::new_single(item::IRON_INGOT, 0),
        ),
        Recipe::new(
            ItemStack::new_block(block::GOLD_ORE, 0),
            ItemStack::new_single(item::GOLD_INGOT, 0),
        ),
        Recipe::new(
            ItemStack::new_block(block::DIAMOND_ORE, 0),
            ItemStack::new_single(item::DIAMOND, 0),
        ),
        Recipe::new(
            ItemStack::new_block(block::SAND, 0),
            ItemStack::new_block(block::GLASS, 0),
        ),
        Recipe::new(
            ItemStack::new_single(item::RAW_PORKCHOP, 0),
            ItemStack::new_single(item::COOKED_PORKCHOP, 0),
        ),
        Recipe::new(
            ItemStack::new_single(item::RAW_FISH, 0),
            ItemStack::new_single(item::COOKED_FISH, 0),
        ),
        Recipe::new(
            ItemStack::new_block(block::COBBLESTONE, 0),
            ItemStack::new_block(block::STONE, 0),
        ),
        Recipe::new(
            ItemStack::new_single(item::CLAY, 0),
            ItemStack::new_single(item::BRICK, 0),
        ),
        Recipe::new(
            ItemStack::new_block(block::CACTUS, 0),
            ItemStack::new_single(item::DYE, 2),
        ),
        Recipe::new(
            ItemStack::new_block(block::LOG, 0),
            ItemStack::new_single(item::COAL, 1),
        ),
    ];
    /// Define a smelting recipe.
    struct Recipe {
        /// The item stack that is consumed to produce the output one.
        input: ItemStack,
        /// The output stack that is produced by consuming the input one.
        output: ItemStack,
    }
    impl Recipe {
        const fn new(input: ItemStack, output: ItemStack) -> Self {
            Self { input, output }
        }
    }
}
pub mod path {
    //! Path finder utility for world.
    use std::collections::HashMap;
    use std::collections::hash_map::Entry;
    use std::ops::{Sub, Add};
    use glam::{IVec3, DVec3};
    use crate::block::material::Material;
    use crate::geom::BoundingBox;
    use crate::world::World;
    use crate::block;
    /// A path finder on a world.
    pub struct PathFinder<'a> {
        /// Back-reference to the world.
        world: &'a World,
        /// The size of the entity (or whatever you want) that should go through the path.
        entity_size: IVec3,
        /// All points allocated by the path finder.
        points: Vec<PathPoint>,
        /// Mapping of points from their block position.
        points_map: HashMap<IVec3, usize>,
        /// A sorted array of points by distance to target, decreasing order. We use
        /// decreasing order because we'll always take the point with less distance to
        /// target, getting it from the end reduces overhead of the operation because no
        /// other element need to be moved.
        pending: Vec<usize>,
    }
    struct PathPoint {
        /// The block position of this path point.
        pos: IVec3,
        /// Total distance of the path containing this point.
        total_distance: f32,
        /// Distance to next point.
        distance_to_next: f32,
        /// A sum of known distance and direct distance to destination point.
        distance_to_target: f32,
        /// True if this point has been the nearest one at some point in path finding.
        is_first: bool,
        /// Previous point index, if currently in the path.
        previous_index: Option<usize>,
        /// True if this point is in the pending list, ordered by its distance to target.
        pending: bool,
    }
    #[automatically_derived]
    impl ::core::default::Default for PathPoint {
        #[inline]
        fn default() -> PathPoint {
            PathPoint {
                pos: ::core::default::Default::default(),
                total_distance: ::core::default::Default::default(),
                distance_to_next: ::core::default::Default::default(),
                distance_to_target: ::core::default::Default::default(),
                is_first: ::core::default::Default::default(),
                previous_index: ::core::default::Default::default(),
                pending: ::core::default::Default::default(),
            }
        }
    }
    impl<'a> PathFinder<'a> {
        pub fn new(world: &'a World) -> Self {
            Self {
                world,
                entity_size: IVec3::ONE,
                points: Vec::new(),
                points_map: HashMap::new(),
                pending: Vec::new(),
            }
        }
        fn distance(from: IVec3, to: IVec3) -> f32 {
            to.sub(from).as_vec3().length()
        }
        fn ensure_point(&mut self, pos: IVec3) -> (usize, &mut PathPoint) {
            match self.points_map.entry(pos) {
                Entry::Occupied(o) => {
                    let index = *o.into_mut();
                    (index, &mut self.points[index])
                }
                Entry::Vacant(v) => {
                    let index = self.points.len();
                    v.insert(index);
                    self.points
                        .push(PathPoint {
                            pos,
                            ..Default::default()
                        });
                    (index, &mut self.points[index])
                }
            }
        }
        /// Check clearance of the given position, depending on the current entity size.
        fn check_clearance(&self, pos: IVec3) -> PathClearance {
            for (_, block, metadata) in self
                .world
                .iter_blocks_in(pos, pos + self.entity_size)
            {
                match block {
                    block::AIR => {}
                    block::IRON_DOOR | block::WOOD_DOOR => {
                        if !block::door::is_open(metadata) {
                            return PathClearance::Blocked;
                        }
                    }
                    _ => {
                        match block::material::get_material(block) {
                            Material::Water => return PathClearance::Water,
                            Material::Lava => return PathClearance::Lava,
                            material => {
                                if material.is_solid() {
                                    return PathClearance::Blocked;
                                }
                            }
                        }
                    }
                }
            }
            PathClearance::Clear
        }
        /// Find a safe point to path find to in above or below the given position.
        fn find_safe_point(&mut self, mut pos: IVec3, clear: bool) -> Option<usize> {
            let mut ret = None;
            if self.check_clearance(pos) == PathClearance::Clear {
                ret = Some(self.ensure_point(pos).0);
            }
            if ret.is_none() && clear
                && self.check_clearance(pos + IVec3::Y) == PathClearance::Clear
            {
                pos.y += 1;
                ret = Some(self.ensure_point(pos).0);
            }
            if let Some(point_index) = &mut ret {
                let mut height = 0;
                while pos.y > 0 {
                    pos.y -= 1;
                    height += 1;
                    match self.check_clearance(pos) {
                        PathClearance::Clear => {}
                        PathClearance::Lava => return None,
                        _ => break,
                    }
                    if height >= 4 {
                        return None;
                    }
                    *point_index = self.ensure_point(pos).0;
                }
            }
            ret
        }
        /// Find path options around the given 'from' position, with a maximum distance.
        fn find_path_options(
            &mut self,
            from: IVec3,
            to: IVec3,
            dist: f32,
        ) -> [Option<usize>; 4] {
            let clear = self.check_clearance(from + IVec3::Y) == PathClearance::Clear;
            let mut ret = [
                self.find_safe_point(from + IVec3::Z, clear),
                self.find_safe_point(from - IVec3::X, clear),
                self.find_safe_point(from + IVec3::X, clear),
                self.find_safe_point(from - IVec3::Z, clear),
            ];
            for option_index in &mut ret {
                if let Some(index) = *option_index {
                    let point = &self.points[index];
                    if point.is_first || Self::distance(point.pos, to) >= dist {
                        *option_index = None;
                    }
                }
            }
            ret
        }
        /// Ensure that a point (given its index) is present in the pending list.
        fn ensure_pending_point(&mut self, point_index: usize) {
            let point = &mut self.points[point_index];
            let point_distance_to_target = point.distance_to_target;
            if point.pending {
                let index = self
                    .pending
                    .iter()
                    .position(|&index| index == point_index)
                    .expect("should be in the pending list");
                self.pending.remove(index);
            }
            point.pending = true;
            let insert_index = self
                .pending
                .binary_search_by(|&index| {
                    let distance_to_target = self.points[index].distance_to_target;
                    point_distance_to_target.total_cmp(&distance_to_target)
                })
                .unwrap_or_else(|index| index);
            self.pending.insert(insert_index, point_index);
        }
        /// Find a path in the world from on position to another, with a given maximum
        /// distance, if no path can be found none is returned. The result also depends on
        /// the entity size, which will determine wether or not the entity can go through
        /// a hole or not.
        pub fn find_path(
            &mut self,
            from: IVec3,
            to: IVec3,
            entity_size: IVec3,
            dist: f32,
        ) -> Option<Vec<IVec3>> {
            self.entity_size = entity_size;
            let (from_index, from_point) = self.ensure_point(from);
            from_point.total_distance = 0.0;
            from_point.distance_to_next = Self::distance(from, to);
            from_point.distance_to_target = from_point.distance_to_next;
            self.pending.push(from_index);
            let mut near_pos = from;
            let mut near_index = 0;
            while let Some(current_index) = self.pending.pop() {
                let current_point = &mut self.points[current_index];
                if current_point.pos == to {
                    near_index = current_index;
                    break;
                }
                if Self::distance(current_point.pos, to) < Self::distance(near_pos, to) {
                    near_pos = current_point.pos;
                    near_index = current_index;
                }
                current_point.is_first = true;
                let current_pos = current_point.pos;
                let current_total_distance = current_point.total_distance;
                for option in self.find_path_options(current_pos, to, dist) {
                    if let Some(option_index) = option {
                        let option_point = &mut self.points[option_index];
                        let added_distance = Self::distance(
                            current_pos,
                            option_point.pos,
                        );
                        let new_total_distance = current_total_distance + added_distance;
                        if !option_point.pending
                            || new_total_distance < current_total_distance
                        {
                            option_point.previous_index = Some(current_index);
                            option_point.total_distance = new_total_distance;
                            option_point
                                .distance_to_next = Self::distance(option_point.pos, to);
                            option_point
                                .distance_to_target = option_point.total_distance
                                + option_point.distance_to_next;
                            self.ensure_pending_point(option_index);
                        }
                    }
                }
            }
            if near_index == 0 {
                None
            } else {
                let mut ret = Vec::new();
                loop {
                    let point = &self.points[near_index];
                    ret.push(point.pos);
                    if let Some(previous_index) = point.previous_index {
                        near_index = previous_index;
                    } else {
                        break;
                    }
                }
                self.points.clear();
                self.points_map.clear();
                self.pending.clear();
                ret.reverse();
                Some(ret)
            }
        }
        /// A specialization or [`find_path`](Self::find_path) to find a path of a moving
        /// bounding box to a given position. The actual position of the bounding is its
        /// bottom center.
        pub fn find_path_from_bounding_box(
            &mut self,
            from: BoundingBox,
            to: DVec3,
            dist: f32,
        ) -> Option<Vec<IVec3>> {
            let size = from.size();
            let from = from.min.floor().as_ivec3();
            let to = to
                .sub(DVec3 {
                    x: size.x / 2.0,
                    y: 0.0,
                    z: size.z / 2.0,
                })
                .floor()
                .as_ivec3();
            self.find_path(from, to, size.add(1.0).floor().as_ivec3(), dist)
        }
    }
    enum PathClearance {
        Clear,
        Blocked,
        Water,
        Lava,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PathClearance {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    PathClearance::Clear => "Clear",
                    PathClearance::Blocked => "Blocked",
                    PathClearance::Water => "Water",
                    PathClearance::Lava => "Lava",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PathClearance {
        #[inline]
        fn clone(&self) -> PathClearance {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for PathClearance {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PathClearance {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PathClearance {
        #[inline]
        fn eq(&self, other: &PathClearance) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for PathClearance {}
    #[automatically_derived]
    impl ::core::cmp::Eq for PathClearance {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
}
pub mod chunk {
    //! A chunk storing block and light data of a world, optimized for runtime performance.
    //! This  module only provides low-level data structures, refer to the
    //! [`world`](crate::world) module for world manipulation methods.
    use std::io::Write;
    use std::sync::Arc;
    use std::io;
    use glam::{IVec3, DVec3};
    use crate::biome::Biome;
    use crate::block;
    /// Chunk size in both X and Z coordinates.
    pub const CHUNK_WIDTH: usize = 16;
    /// Chunk height.
    pub const CHUNK_HEIGHT: usize = 128;
    /// Internal chunk 2D size, in number of columns per chunk.
    pub const CHUNK_2D_SIZE: usize = CHUNK_WIDTH * CHUNK_WIDTH;
    /// Internal chunk 3D size, in number of block per chunk.
    pub const CHUNK_3D_SIZE: usize = CHUNK_HEIGHT * CHUNK_2D_SIZE;
    /// Calculate the index in the chunk's arrays for the given position (local or not). This
    /// is the same layout used by Minecraft's code `_xxx xzzz zyyy yyyy`. Only firsts
    /// relevant bits are taken in each coordinate component.
    #[inline]
    fn calc_3d_index(pos: IVec3) -> usize {
        if true {
            if !(pos.y >= 0 && pos.y < CHUNK_HEIGHT as i32) {
                ::core::panicking::panic(
                    "assertion failed: pos.y >= 0 && pos.y < CHUNK_HEIGHT as i32",
                )
            }
        }
        let x = pos.x as u32 & 0b1111;
        let z = pos.z as u32 & 0b1111;
        let y = pos.y as u32 & 0b1111111;
        ((x << 11) | (z << 7) | (y << 0)) as usize
    }
    /// Calculate the index in the chunk's 2D arrays for the given position (local or not).
    /// Y position is ignored.
    #[inline]
    fn calc_2d_index(pos: IVec3) -> usize {
        let x = pos.x as u32 & 0b1111;
        let z = pos.z as u32 & 0b1111;
        ((z << 4) | (x << 0)) as usize
    }
    /// Calculate the chunk position corresponding to the given block position. This returns
    /// no position if the Y coordinate is invalid.
    #[inline]
    pub fn calc_chunk_pos(pos: IVec3) -> Option<(i32, i32)> {
        if pos.y < 0 || pos.y >= CHUNK_HEIGHT as i32 {
            None
        } else {
            Some(calc_chunk_pos_unchecked(pos))
        }
    }
    /// Calculate the chunk position corresponding to the given block position. The Y
    /// coordinate is ignored, so it may be invalid.
    #[inline]
    pub fn calc_chunk_pos_unchecked(pos: IVec3) -> (i32, i32) {
        (pos.x >> 4, pos.z >> 4)
    }
    /// Calculate the chunk position where the given entity should be cached.
    #[inline]
    pub fn calc_entity_chunk_pos(pos: DVec3) -> (i32, i32) {
        calc_chunk_pos_unchecked(pos.floor().as_ivec3())
    }
    /// Data structure storing every chunk-local data, chunks are a world subdivision of
    /// 16x16x128 blocks.
    pub struct Chunk {
        /// The numeric identifier of the block.
        pub block: ChunkArray3<u8>,
        /// Four byte metadata for each block.
        pub metadata: ChunkNibbleArray3,
        /// Block list level for each block.
        pub block_light: ChunkNibbleArray3,
        /// Sky light level for each block.
        pub sky_light: ChunkNibbleArray3,
        /// The height map, the height map is closely related to sky light level, the height
        /// is set to the first block in a column (start from Y = 0) that has sky light 15,
        /// and therefore all blocks above also have sky light 15. The height must be in
        /// range 0..=128.
        pub height: ChunkArray2<u8>,
        /// The biome map, this map is not actually saved nor sent to the client. It is
        /// internally used by this implementation to really split the chunk generation from
        /// the running world. The Notchian server is different because the mob spawning
        /// algorithms requires the biome map to be generated at runtime. This also explains
        /// why we can use a Rust enumeration for this one, and not raw value, because we
        /// don't need to deserialize it and therefore don't risk any unwanted value.
        pub biome: ChunkArray2<Biome>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Chunk {
        #[inline]
        fn clone(&self) -> Chunk {
            Chunk {
                block: ::core::clone::Clone::clone(&self.block),
                metadata: ::core::clone::Clone::clone(&self.metadata),
                block_light: ::core::clone::Clone::clone(&self.block_light),
                sky_light: ::core::clone::Clone::clone(&self.sky_light),
                height: ::core::clone::Clone::clone(&self.height),
                biome: ::core::clone::Clone::clone(&self.biome),
            }
        }
    }
    impl Chunk {
        /// Create a new empty chunk, full of air blocks. All block light is zero and all sky
        /// light is 15. This constructor directly returns an arc chunk to ensure that no
        /// useless copy will be done, and also because it make no sense to hold this
        /// structure on stack.
        ///
        /// The chunk is specifically returned in a Atomic Reference-Counted container in
        /// order to be used as some kind of Clone-On-Write container (through the method
        /// [`Arc::make_mut`]), this is especially useful when dealing with zero-copy
        /// asynchronous chunk saving.
        pub fn new() -> Arc<Self> {
            Arc::new(Self {
                block: [block::AIR; CHUNK_3D_SIZE],
                metadata: ChunkNibbleArray3::new(0),
                block_light: ChunkNibbleArray3::new(0),
                sky_light: ChunkNibbleArray3::new(15),
                height: [0; CHUNK_2D_SIZE],
                biome: [Biome::Void; CHUNK_2D_SIZE],
            })
        }
        /// Get block id and metadata at the given global position (rebased to chunk-local).
        /// Panics if Y component of the position is not between 0 and 128 (excluded).
        #[inline]
        pub fn get_block(&self, pos: IVec3) -> (u8, u8) {
            let index = calc_3d_index(pos);
            (self.block[index], self.metadata.get(index))
        }
        /// Set block id and metadata at the given global position (rebased to chunk-local).
        /// Panics if Y component of the position is not between 0 and 128 (excluded).
        #[inline]
        pub fn set_block(&mut self, pos: IVec3, id: u8, metadata: u8) {
            let index = calc_3d_index(pos);
            self.block[index] = id;
            self.metadata.set(index, metadata);
        }
        /// Get block light level at the given global position (rebased to chunk-local).
        /// Panics if Y component of the position is not between 0 and 128 (excluded).
        #[inline]
        pub fn get_block_light(&self, pos: IVec3) -> u8 {
            self.block_light.get(calc_3d_index(pos))
        }
        /// Get block light level at the given global position (rebased to chunk-local).
        /// Panics if Y component of the position is not between 0 and 128 (excluded).
        #[inline]
        pub fn set_block_light(&mut self, pos: IVec3, light: u8) {
            self.block_light.set(calc_3d_index(pos), light);
        }
        /// Get sky light level at the given global position (rebased to chunk-local).
        /// Panics if Y component of the position is not between 0 and 128 (excluded).
        #[inline]
        pub fn get_sky_light(&self, pos: IVec3) -> u8 {
            self.sky_light.get(calc_3d_index(pos))
        }
        /// Get sky light level at the given global position (rebased to chunk-local).
        /// Panics if Y component of the position is not between 0 and 128 (excluded).
        #[inline]
        pub fn set_sky_light(&mut self, pos: IVec3, light: u8) {
            self.sky_light.set(calc_3d_index(pos), light);
        }
        /// Get the height at the given position, the Y component is ignored.
        ///
        /// The height value corresponds to the Y value of the first block above the column
        /// with full sky light.
        #[inline]
        pub fn get_height(&self, pos: IVec3) -> u8 {
            self.height[calc_2d_index(pos)]
        }
        /// Set the height at the given position, the Y component is ignored.
        ///
        /// The height value corresponds to the Y value of the first block above the column
        /// with full sky light.
        #[inline]
        pub fn set_height(&mut self, pos: IVec3, height: u8) {
            if true {
                if !(height <= 128) {
                    {
                        ::core::panicking::panic_fmt(format_args!("illegal height"));
                    }
                }
            }
            self.height[calc_2d_index(pos)] = height;
        }
        /// Get the biome at the given position, the Y component is ignored.
        #[inline]
        pub fn get_biome(&self, pos: IVec3) -> Biome {
            self.biome[calc_2d_index(pos)]
        }
        /// Set the biome at the given position, the Y component is ignored.
        #[inline]
        pub fn set_biome(&mut self, pos: IVec3, biome: Biome) {
            self.biome[calc_2d_index(pos)] = biome;
        }
        /// Fill the given chunk area with given block id and metadata.
        /// Panics if Y component of the position is not between 0 and 128 (excluded).
        pub fn fill_block(&mut self, from: IVec3, size: IVec3, id: u8, metadata: u8) {
            for x in from.x..from.x + size.x {
                for z in from.z..from.z + size.z {
                    for y in from.y..from.y + size.y {
                        let index = calc_3d_index(IVec3::new(x, y, z));
                        self.block[index] = id;
                        self.metadata.set(index, metadata);
                    }
                }
            }
        }
        /// Fill the given chunk area with given block and sky light values.
        /// Panics if Y component of the position is not between 0 and 128 (excluded).
        pub fn fill_light(
            &mut self,
            from: IVec3,
            size: IVec3,
            block_light: u8,
            sky_light: u8,
        ) {
            for x in from.x..from.x + size.x {
                for z in from.z..from.z + size.z {
                    for y in from.y..from.y + size.y {
                        let index = calc_3d_index(IVec3::new(x, y, z));
                        self.block_light.set(index, block_light);
                        self.sky_light.set(index, sky_light);
                    }
                }
            }
        }
        /// Recompute the height column after the modification of the given block position.
        /// The height is recomputed and the skylight is also recomputed.
        ///
        /// This function also returns a Y position, lower that the given one, that represent
        pub fn recompute_height(&mut self, pos: IVec3) -> u8 {
            if !(pos.y >= 0 && pos.y < CHUNK_HEIGHT as i32) {
                ::core::panicking::panic(
                    "assertion failed: pos.y >= 0 && pos.y < CHUNK_HEIGHT as i32",
                )
            }
            let prev_height = self.get_height(pos) as i32;
            let mut new_height = prev_height.max(pos.y + 1);
            while new_height > 0 {
                new_height -= 1;
                let pos = IVec3::new(pos.x, new_height, pos.z);
                let (id, _) = self.get_block(pos);
                if block::material::get_light_opacity(id) != 0 {
                    new_height += 1;
                    break;
                }
            }
            if new_height == prev_height {
                return prev_height as u8;
            }
            if new_height < prev_height {
                for y in new_height..prev_height {
                    let pos = IVec3::new(pos.x, y, pos.z);
                    self.set_sky_light(pos, 15);
                }
            }
            let mut sky_light = 15u8;
            for y in (0..new_height).rev() {
                let pos = IVec3::new(pos.x, y, pos.z);
                if sky_light > 0 {
                    let (id, _) = self.get_block(pos);
                    let opacity = block::material::get_light_opacity(id).max(1);
                    sky_light = sky_light.saturating_sub(opacity);
                }
                self.set_sky_light(pos, sky_light);
            }
            self.set_height(pos, new_height as u8);
            new_height as u8
        }
        /// Recompute the whole height map based on all block in the chunk. This also reset
        /// all sky light values to the right values each columns. Note that skylight is not
        /// propagated and therefore the updates should be scheduled manually when chunk is
        /// added to a world. Block light is not touched.
        pub fn recompute_all_height(&mut self) {
            for x in 0..CHUNK_WIDTH {
                for z in 0..CHUNK_WIDTH {
                    self.recompute_height(IVec3::new(x as i32, 127, z as i32));
                }
            }
        }
        /// Write this chunk's data to the given writer, the data is copied from the start
        /// point for the given size. Note that this function may change the start and size
        /// of the area to be more efficient while while writing data.
        pub fn write_data(
            &self,
            mut writer: impl Write,
            from: &mut IVec3,
            size: &mut IVec3,
        ) -> io::Result<()> {
            if from.y % 2 != 0 {
                from.y -= 1;
                size.y += 1;
            }
            size.y = (size.y + 1) & !1;
            if true {
                if !(from.y % 2 == 0) {
                    ::core::panicking::panic("assertion failed: from.y % 2 == 0")
                }
            }
            if true {
                if !(size.y % 2 == 0) {
                    ::core::panicking::panic("assertion failed: size.y % 2 == 0")
                }
            }
            if true {
                if !(size.x <= 16 && size.y <= 128 && size.z <= 16) {
                    ::core::panicking::panic(
                        "assertion failed: size.x <= 16 && size.y <= 128 && size.z <= 16",
                    )
                }
            }
            let height = size.y as usize;
            let half_height = height / 2;
            let from = *from;
            let to = from + *size;
            if size.x == 16 && size.z == 16 && size.y == 128 {
                writer.write_all(&self.block)?;
                writer.write_all(&self.metadata.inner)?;
                writer.write_all(&self.block_light.inner)?;
                writer.write_all(&self.sky_light.inner)?;
            } else {
                for x in from.x..to.x {
                    for z in from.z..to.z {
                        let index = calc_3d_index(IVec3::new(x, from.y, z));
                        writer.write_all(&self.block[index..index + height])?;
                    }
                }
                for x in from.x..to.x {
                    for z in from.z..to.z {
                        let index = calc_3d_index(IVec3::new(x, from.y, z)) / 2;
                        writer
                            .write_all(
                                &self.metadata.inner[index..index + half_height],
                            )?;
                    }
                }
                for x in from.x..to.x {
                    for z in from.z..to.z {
                        let index = calc_3d_index(IVec3::new(x, from.y, z)) / 2;
                        writer
                            .write_all(
                                &self.block_light.inner[index..index + half_height],
                            )?;
                    }
                }
                for x in from.x..to.x {
                    for z in from.z..to.z {
                        let index = calc_3d_index(IVec3::new(x, from.y, z)) / 2;
                        writer
                            .write_all(
                                &self.sky_light.inner[index..index + half_height],
                            )?;
                    }
                }
            }
            Ok(())
        }
    }
    /// Type alias for a chunk array that stores `u8 * CHUNK_2D_SIZE` values.
    pub type ChunkArray2<T> = [T; CHUNK_2D_SIZE];
    /// Type alias for a chunk array that stores `u8 * CHUNK_3D_SIZE` values.
    pub type ChunkArray3<T> = [T; CHUNK_3D_SIZE];
    /// Special arrays for chunks that stores `u4 * CHUNK_3D_SIZE` values.
    pub struct ChunkNibbleArray3 {
        pub inner: [u8; CHUNK_3D_SIZE / 2],
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ChunkNibbleArray3 {
        #[inline]
        fn clone(&self) -> ChunkNibbleArray3 {
            ChunkNibbleArray3 {
                inner: ::core::clone::Clone::clone(&self.inner),
            }
        }
    }
    impl ChunkNibbleArray3 {
        pub const fn new(init: u8) -> Self {
            if true {
                if !(init <= 0x0F) {
                    ::core::panicking::panic("assertion failed: init <= 0x0F")
                }
            }
            let init = init << 4 | init;
            Self {
                inner: [init; CHUNK_3D_SIZE / 2],
            }
        }
        #[inline]
        pub fn get(&self, index: usize) -> u8 {
            let slot = self.inner[index >> 1];
            if index & 1 == 0 { slot & 0x0F } else { (slot & 0xF0) >> 4 }
        }
        #[inline]
        pub fn set(&mut self, index: usize, value: u8) {
            if true {
                if !(value <= 0x0F) {
                    ::core::panicking::panic("assertion failed: value <= 0x0F")
                }
            }
            let slot = &mut self.inner[index >> 1];
            if index & 1 == 0 {
                *slot = (*slot & 0xF0) | value;
            } else {
                *slot = (*slot & 0x0F) | (value << 4);
            }
        }
    }
}
pub mod world {
    //! Data structure for storing a world (overworld or nether) at runtime.
    use std::collections::{HashMap, BTreeSet, HashSet, VecDeque};
    use std::collections::hash_map::Entry;
    use std::ops::{Deref, DerefMut};
    use std::iter::FusedIterator;
    use std::cmp::Ordering;
    use std::hash::Hash;
    use std::cell::Cell;
    use std::sync::Arc;
    use std::slice;
    use std::mem;
    use glam::{IVec3, Vec2, DVec3};
    use indexmap::IndexMap;
    use tracing::trace;
    use crate::entity::{Entity, EntityCategory, EntityKind};
    use crate::block_entity::BlockEntity;
    use crate::biome::Biome;
    use crate::chunk::{
        Chunk, calc_chunk_pos, calc_chunk_pos_unchecked, calc_entity_chunk_pos,
        CHUNK_HEIGHT, CHUNK_WIDTH,
    };
    use crate::geom::{BoundingBox, Face};
    use crate::rand::JavaRandom;
    use crate::item::ItemStack;
    use crate::block;
    pub mod material {
        //! Various shortcut methods to directly check block materials.
        use glam::IVec3;
        use crate::block::material::Material;
        use crate::block;
        use super::World;
        /// Shortcut methods for directly querying and checking a block material and properties.
        impl World {
            /// Get the block material at given position, defaults to air if no chunk.
            pub fn get_block_material(&self, pos: IVec3) -> Material {
                self.get_block(pos)
                    .map(|(id, _)| block::material::get_material(id))
                    .unwrap_or_default()
            }
            /// Return true if the block at given position can be replaced.
            pub fn is_block_replaceable(&self, pos: IVec3) -> bool {
                if let Some((id, _)) = self.get_block(pos) {
                    block::material::get_material(id).is_replaceable()
                } else {
                    false
                }
            }
            /// Return true if the block at position is opaque.
            ///
            /// FIXME: A lot of calls to this function should instead be for "normal_cube". This
            /// is not exactly the same properties in the Notchian implementation.
            pub fn is_block_opaque_cube(&self, pos: IVec3) -> bool {
                if let Some((id, _)) = self.get_block(pos) {
                    block::material::is_opaque_cube(id)
                } else {
                    false
                }
            }
            /// Return true if the block at position is material solid.
            pub fn is_block_solid(&self, pos: IVec3) -> bool {
                if let Some((id, _)) = self.get_block(pos) {
                    block::material::get_material(id).is_solid()
                } else {
                    false
                }
            }
            /// Return true if the block at position is air.
            #[inline]
            pub fn is_block_air(&self, pos: IVec3) -> bool {
                if let Some((id, _)) = self.get_block(pos) {
                    id == block::AIR
                } else {
                    true
                }
            }
            /// Return true if the block at position is the given one.
            #[inline]
            pub fn is_block(&self, pos: IVec3, id: u8) -> bool {
                if let Some((pos_id, _)) = self.get_block(pos) {
                    pos_id == id
                } else {
                    false
                }
            }
        }
    }
    pub mod bound {
        //! Block overlay and colliding bounding box extension for world. This module also
        //! provides methods to ray trace and find colliding boxes in a world.
        use std::ops::Add;
        use glam::{IVec3, DVec3};
        use crate::block_entity::BlockEntity;
        use crate::geom::{BoundingBox, Face};
        use crate::block;
        use super::World;
        const PIXEL: f64 = 1.0 / 16.0;
        const PIXEL_2: f64 = 2.0 / 16.0;
        const PIXEL_3: f64 = 3.0 / 16.0;
        /// Methods related to block collisions and overlay bounds and also for ray tracing.
        impl World {
            /// Get the colliding boxes for a block, the colliding box will be offset to the
            /// block's position as needed. Not to confuse with overlay boxes, which are just used
            /// to client side placement rendering, and used server-side to compute ray tracing
            /// when using items such as bucket.
            pub fn iter_block_colliding_boxes(
                &self,
                pos: IVec3,
                id: u8,
                metadata: u8,
            ) -> BlockCollidingBoxesIter {
                if id == block::PISTON_MOVING {
                    if let Some(BlockEntity::Piston(piston)) = self.get_block_entity(pos)
                    {
                        let progress = if piston.extending {
                            1.0 - piston.progress
                        } else {
                            piston.progress
                        };
                        return BlockCollidingBoxesIter {
                            offset: pos.as_dvec3()
                                - piston.face.delta().as_dvec3() * progress as f64,
                            id,
                            metadata,
                            index: 0,
                        };
                    }
                }
                BlockCollidingBoxesIter {
                    offset: pos.as_dvec3(),
                    id,
                    metadata,
                    index: 0,
                }
            }
            /// Get the colliding box for a block, this returns a single bounding box that is an
            /// union between all boxes returned by [`iter_block_colliding_boxes`] iterator.
            ///
            /// [`iter_block_colliding_boxes`]: Self::iter_block_colliding_boxes
            pub fn get_block_colliding_box(
                &self,
                pos: IVec3,
                id: u8,
                metadata: u8,
            ) -> Option<BoundingBox> {
                let mut iter = self.iter_block_colliding_boxes(pos, id, metadata);
                let mut bb = iter.next()?;
                while let Some(other) = iter.next() {
                    bb |= other;
                }
                Some(bb)
            }
            /// Get the exclusion box of a block, this function doesn't take the block metadata.
            ///
            /// PARITY: The Notchian implementation is terrible because it uses the colliding box
            /// for the exclusion box but with the metadata of the block currently at the
            /// position, so we fix this in this implementation by just returning a full block
            /// for blocks that usually depends on metadata (such as doors, trapdoors).
            pub fn get_block_exclusion_box(
                &self,
                pos: IVec3,
                id: u8,
            ) -> Option<BoundingBox> {
                let bb = match id {
                    block::BED => Face::NegY.extrude(0.0, 9.0 / 16.0),
                    block::CAKE => Face::NegY.extrude(PIXEL, 0.5),
                    block::CACTUS => Face::NegY.extrude(PIXEL, 1.0),
                    block::SOULSAND => Face::NegY.extrude(0.0, 1.0 - PIXEL_2),
                    block::AIR
                    | block::LEVER
                    | block::BUTTON
                    | block::PORTAL
                    | block::WOOD_PRESSURE_PLATE
                    | block::STONE_PRESSURE_PLATE
                    | block::RAIL
                    | block::POWERED_RAIL
                    | block::DETECTOR_RAIL
                    | block::SIGN
                    | block::WALL_SIGN
                    | block::WHEAT
                    | block::DANDELION
                    | block::POPPY
                    | block::RED_MUSHROOM
                    | block::BROWN_MUSHROOM
                    | block::DEAD_BUSH
                    | block::SAPLING
                    | block::TALL_GRASS
                    | block::WATER_MOVING
                    | block::WATER_STILL
                    | block::LAVA_MOVING
                    | block::LAVA_STILL
                    | block::REDSTONE
                    | block::SUGAR_CANES
                    | block::TORCH
                    | block::REDSTONE_TORCH
                    | block::REDSTONE_TORCH_LIT
                    | block::COBWEB => return None,
                    _ => BoundingBox::CUBE,
                };
                Some(bb + pos.as_dvec3())
            }
            /// Get the overlay box of the block, this overlay is what should be shown client-side
            /// around the block and where the player can click. Unlike colliding boxes, there is
            /// only one overlay box per block.
            ///
            /// **Note that** liquid blocks returns no box.
            pub fn get_block_overlay_box(
                &self,
                pos: IVec3,
                id: u8,
                metadata: u8,
            ) -> Option<BoundingBox> {
                let bb = match id {
                    block::BED => Face::NegY.extrude(0.0, 9.0 / 16.0),
                    block::CAKE => {
                        BoundingBox::new(
                            (1 + metadata * 2) as f64 / 16.0,
                            0.0,
                            PIXEL,
                            1.0 - PIXEL,
                            0.5,
                            1.0 - PIXEL,
                        )
                    }
                    block::CACTUS => Face::NegY.extrude(PIXEL, 1.0),
                    block::REDSTONE => Face::NegY.extrude(0.0, PIXEL),
                    block::WOOD_DOOR | block::IRON_DOOR => {
                        block::door::get_actual_face(metadata).extrude(0.0, PIXEL_3)
                    }
                    block::LEVER => {
                        let (face, _) = block::lever::get_face(metadata)?;
                        if face == Face::NegY {
                            face.extrude(0.25, 0.6)
                        } else {
                            face.extrude(5.0 / 16.0, 6.0 / 16.0)
                                .inflate(DVec3::new(0.0, PIXEL_2, 0.0))
                        }
                    }
                    block::BUTTON => {
                        let face = block::button::get_face(metadata)?;
                        let active = block::button::is_active(metadata);
                        face.extrude(0.6, if active { PIXEL } else { PIXEL_2 })
                            .inflate(DVec3::new(0.0, -PIXEL, 0.0))
                    }
                    block::PISTON | block::STICKY_PISTON => {
                        if block::piston::is_extended(metadata) {
                            block::piston::get_face(metadata)?.extrude(0.0, 12.0 / 16.0)
                        } else {
                            BoundingBox::CUBE
                        }
                    }
                    block::PISTON_EXT => {
                        block::piston::get_face(metadata)?.extrude(0.0, 0.25)
                    }
                    block::PISTON_MOVING => return None,
                    block::PORTAL => return None,
                    block::WOOD_PRESSURE_PLATE | block::STONE_PRESSURE_PLATE => {
                        Face::NegY
                            .extrude(
                                PIXEL,
                                if metadata == 1 { PIXEL / 2.0 } else { PIXEL },
                            )
                    }
                    block::RAIL | block::POWERED_RAIL | block::DETECTOR_RAIL => {
                        Face::NegY
                            .extrude(
                                0.0,
                                if metadata >= 2 && metadata <= 5 {
                                    10.0 / 16.0
                                } else {
                                    PIXEL_2
                                },
                            )
                    }
                    block::SIGN | block::WALL_SIGN => return None,
                    block::SNOW => {
                        let layers = metadata & 7;
                        Face::NegY.extrude(0.0, 2.0 * (1.0 + layers as f64) / 16.0)
                    }
                    block::TRAPDOOR => {
                        if block::trapdoor::is_open(metadata) {
                            block::trapdoor::get_face(metadata).extrude(0.0, PIXEL_3)
                        } else {
                            Face::NegY.extrude(0.0, PIXEL_3)
                        }
                    }
                    block::WHEAT => Face::NegY.extrude(0.0, 0.25),
                    block::DANDELION | block::POPPY => Face::NegY.extrude(0.3, 0.6),
                    block::RED_MUSHROOM | block::BROWN_MUSHROOM => {
                        Face::NegY.extrude(0.3, 0.4)
                    }
                    block::DEAD_BUSH | block::SAPLING | block::TALL_GRASS => {
                        Face::NegY.extrude(0.1, 0.8)
                    }
                    block::SUGAR_CANES => Face::NegY.extrude(PIXEL_2, 1.0),
                    block::WATER_MOVING
                    | block::WATER_STILL
                    | block::LAVA_MOVING
                    | block::LAVA_STILL
                    | block::AIR => return None,
                    _ => BoundingBox::CUBE,
                };
                Some(bb + pos.as_dvec3())
            }
            /// Iterate over all blocks that are in the bounding box area, this doesn't check for
            /// actual collision with the block's bounding box, it just return all potential
            /// blocks in the bounding box' area.
            pub fn iter_blocks_in_box(
                &self,
                bb: BoundingBox,
            ) -> impl Iterator<Item = (IVec3, u8, u8)> + '_ {
                let min = bb.min.floor().as_ivec3();
                let max = bb.max.add(1.0).floor().as_ivec3();
                self.iter_blocks_in(min, max)
            }
            /// Iterate over all bounding boxes in the given area.
            /// *Min is inclusive and max is exclusive.*
            pub fn iter_blocks_boxes_in(
                &self,
                min: IVec3,
                max: IVec3,
            ) -> impl Iterator<Item = BoundingBox> + '_ {
                self.iter_blocks_in(min, max)
                    .flat_map(|(pos, id, metadata)| {
                        self.iter_block_colliding_boxes(pos, id, metadata)
                    })
            }
            /// Iterate over all bounding boxes in the given area that are colliding with the
            /// given one.
            pub fn iter_blocks_boxes_colliding(
                &self,
                bb: BoundingBox,
            ) -> impl Iterator<Item = BoundingBox> + '_ {
                let min = bb.min.floor().as_ivec3();
                let max = bb.max.add(1.0).floor().as_ivec3();
                self.iter_blocks_boxes_in(min, max)
                    .filter(move |block_bb| block_bb.intersects(bb))
            }
            /// Ray trace from an origin point and return the first colliding blocks, either
            /// entity or block. The fluid argument is used to hit the fluid **source** blocks or
            /// not. The overlay argument is used to select the block overlay box instead of the
            /// block bound box.
            pub fn ray_trace_blocks(
                &self,
                origin: DVec3,
                ray: DVec3,
                kind: RayTraceKind,
            ) -> Option<RayTraceHit> {
                let ray_norm = ray.normalize();
                let mut pos = origin;
                let mut block_pos = pos.floor().as_ivec3();
                let stop_pos = origin.add(ray).floor().as_ivec3();
                while let Some((block, metadata)) = self.get_block(block_pos) {
                    let bb = match kind {
                        RayTraceKind::Colliding => {
                            self.get_block_colliding_box(block_pos, block, metadata)
                        }
                        RayTraceKind::OverlayWithFluid if match block {
                            block::WATER_MOVING
                            | block::WATER_STILL
                            | block::LAVA_MOVING
                            | block::LAVA_STILL => true,
                            _ => false,
                        } => {
                            block::fluid::is_source(metadata)
                                .then_some(BoundingBox::CUBE + block_pos.as_dvec3())
                        }
                        RayTraceKind::Overlay | RayTraceKind::OverlayWithFluid => {
                            self.get_block_overlay_box(block_pos, block, metadata)
                        }
                    };
                    if let Some(bb) = bb {
                        if let Some((new_ray, face)) = bb.calc_ray_trace(origin, ray) {
                            return Some(RayTraceHit {
                                ray: new_ray,
                                pos: block_pos,
                                block,
                                metadata,
                                face,
                            });
                        }
                    }
                    if block_pos == stop_pos {
                        break;
                    }
                    let mut tmp_norm = ray_norm;
                    let mut tmp_norm_div_count = 0u8;
                    let mut next_block_pos;
                    'a: loop {
                        pos += tmp_norm;
                        next_block_pos = pos.floor().as_ivec3();
                        if next_block_pos != block_pos {
                            if tmp_norm_div_count >= 6 {
                                break 'a;
                            }
                            tmp_norm_div_count += 1;
                            tmp_norm /= 2.0;
                        }
                        while next_block_pos != block_pos {
                            let pos_delta = (next_block_pos - block_pos).abs();
                            if pos_delta.x + pos_delta.y + pos_delta.z == 1 {
                                break 'a;
                            }
                            pos -= tmp_norm;
                            next_block_pos = pos.floor().as_ivec3();
                        }
                    }
                    block_pos = next_block_pos;
                }
                None
            }
        }
        /// Internal iterator implementation for bounding boxes of a block with metadata, we must
        /// use an iterator because some blocks have multiple bounding boxes.
        pub struct BlockCollidingBoxesIter {
            /// The offset to apply the the colliding box.
            offset: DVec3,
            /// The block id.
            id: u8,
            /// The block metadata.
            metadata: u8,
            /// The index of the bounding box, for example stairs have 2 bounding boxes.
            index: u8,
        }
        impl Iterator for BlockCollidingBoxesIter {
            type Item = BoundingBox;
            fn next(&mut self) -> Option<Self::Item> {
                let metadata = self.metadata;
                let index = self.index;
                self.index += 1;
                let bb = match (index, self.id) {
                    (0, block::CACTUS) => {
                        BoundingBox::new(
                            PIXEL,
                            0.0,
                            PIXEL,
                            1.0 - PIXEL,
                            1.0,
                            1.0 - PIXEL,
                        )
                    }
                    (0, block::CAKE) => {
                        BoundingBox::new(
                            (1 + metadata * 2) as f64 / 16.0,
                            0.0,
                            PIXEL,
                            1.0 - PIXEL,
                            0.5,
                            1.0 - PIXEL,
                        )
                    }
                    (0, block::FENCE) => BoundingBox::new(0.0, 0.0, 0.0, 1.0, 1.5, 1.0),
                    (0, block::SOULSAND) => {
                        BoundingBox::new(0.0, 0.0, 0.0, 1.0, 1.0 - PIXEL_2, 1.0)
                    }
                    (0, block::BED) => {
                        BoundingBox::new(0.0, 0.0, 0.0, 1.0, 9.0 / 16.0, 1.0)
                    }
                    (0, block::REPEATER | block::REPEATER_LIT) => {
                        BoundingBox::new(0.0, 0.0, 0.0, 1.0, PIXEL_2, 1.0)
                    }
                    (0, block::WOOD_DOOR | block::IRON_DOOR) => {
                        block::door::get_actual_face(metadata).extrude(0.0, PIXEL_3)
                    }
                    (0, block::LADDER) => {
                        return block::ladder::get_face(metadata)
                            .map(|face| face.extrude(0.0, PIXEL_2));
                    }
                    (0, block::SNOW) => {
                        let layers = metadata & 7;
                        if layers >= 3 {
                            BoundingBox::new(0.0, 0.0, 0.0, 1.0, 0.5, 1.0)
                        } else {
                            return None
                        }
                    }
                    (0, block::TRAPDOOR) => {
                        if block::trapdoor::is_open(metadata) {
                            block::trapdoor::get_face(metadata).extrude(0.0, PIXEL_3)
                        } else {
                            Face::NegY.extrude(0.0, PIXEL_3)
                        }
                    }
                    (0, block::PISTON_MOVING) => return None,
                    (0, block::PISTON_EXT) => {
                        block::piston::get_face(metadata)?.extrude(0.0, 0.25)
                    }
                    (1, block::PISTON_EXT) => {
                        let face = block::piston::get_face(metadata)?;
                        face.extrude(6.0 / 16.0, 0.75) - face.delta().as_dvec3() * 0.25
                    }
                    (0, block::WOOD_STAIR | block::COBBLESTONE_STAIR | block::SLAB) => {
                        BoundingBox::new(0.0, 0.0, 0.0, 1.0, 0.5, 1.0)
                    }
                    (1, block::WOOD_STAIR | block::COBBLESTONE_STAIR) => {
                        block::stair::get_face(metadata).extrude(0.0, 0.5)
                    }
                    (
                        0,
                        block::AIR
                        | block::FIRE
                        | block::DANDELION
                        | block::POPPY
                        | block::WHEAT
                        | block::DEAD_BUSH
                        | block::RED_MUSHROOM
                        | block::BROWN_MUSHROOM
                        | block::TALL_GRASS
                        | block::SUGAR_CANES
                        | block::WATER_MOVING
                        | block::WATER_STILL
                        | block::LAVA_MOVING
                        | block::LAVA_STILL
                        | block::PORTAL
                        | block::WOOD_PRESSURE_PLATE
                        | block::STONE_PRESSURE_PLATE
                        | block::RAIL
                        | block::POWERED_RAIL
                        | block::DETECTOR_RAIL
                        | block::REDSTONE
                        | block::BUTTON
                        | block::LEVER
                        | block::SIGN
                        | block::WALL_SIGN
                        | block::TORCH
                        | block::REDSTONE_TORCH
                        | block::REDSTONE_TORCH_LIT
                        | block::COBWEB,
                    ) => return None,
                    (0, _) => BoundingBox::CUBE,
                    _ => return None,
                };
                Some(bb + self.offset)
            }
        }
        /// Describe the kind of ray tracing to make, this describe how blocks are collided.
        pub enum RayTraceKind {
            /// The ray trace will be on block colliding boxes.
            Colliding,
            /// The ray trace will be on block overlay boxes.
            Overlay,
            /// The ray trace will be on block overlay boxes including fluid sources.
            OverlayWithFluid,
        }
        /// Result of a ray trace that hit a block.
        pub struct RayTraceHit {
            /// The ray vector that stop on the block.
            pub ray: DVec3,
            /// The position of the block.
            pub pos: IVec3,
            /// The block.
            pub block: u8,
            /// The block metadata.
            pub metadata: u8,
            /// The face of the block.
            pub face: Face,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for RayTraceHit {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "RayTraceHit",
                    "ray",
                    &self.ray,
                    "pos",
                    &self.pos,
                    "block",
                    &self.block,
                    "metadata",
                    &self.metadata,
                    "face",
                    &&self.face,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RayTraceHit {
            #[inline]
            fn clone(&self) -> RayTraceHit {
                RayTraceHit {
                    ray: ::core::clone::Clone::clone(&self.ray),
                    pos: ::core::clone::Clone::clone(&self.pos),
                    block: ::core::clone::Clone::clone(&self.block),
                    metadata: ::core::clone::Clone::clone(&self.metadata),
                    face: ::core::clone::Clone::clone(&self.face),
                }
            }
        }
    }
    pub mod power {
        //! Redstone power calculations. The behavior of each power-producing block is described
        //! in this module.
        use glam::IVec3;
        use crate::geom::{Face, FaceSet};
        use crate::block;
        use super::World;
        /// Methods related to redstone power calculation in the world.
        impl World {
            /// Check if the given block position get any active power from surrounding faces.
            #[inline]
            pub fn has_active_power(&mut self, pos: IVec3) -> bool {
                Face::ALL
                    .into_iter()
                    .any(|face| {
                        self.has_active_power_from(pos + face.delta(), face.opposite())
                    })
            }
            /// Check if the given block position get any passive power from surrounding faces.
            #[inline]
            pub fn has_passive_power(&mut self, pos: IVec3) -> bool {
                Face::ALL
                    .into_iter()
                    .any(|face| {
                        self.has_passive_power_from(pos + face.delta(), face.opposite())
                    })
            }
            /// Return true if the given block's face produces any active power.
            #[inline]
            pub fn has_active_power_from(&mut self, pos: IVec3, face: Face) -> bool {
                self.get_active_power_from(pos, face) > 0
            }
            /// Return true if the given block's face has any passive power.
            #[inline]
            pub fn has_passive_power_from(&mut self, pos: IVec3, face: Face) -> bool {
                self.get_passive_power_from(pos, face) > 0
            }
            /// Get the active power produced by a block's face.
            pub fn get_active_power_from(&mut self, pos: IVec3, face: Face) -> u8 {
                let power = self.get_power_from(pos, face, true);
                if power.indirect || !power.passive { power.level } else { 0 }
            }
            /// Get the passive power of a block's face.
            pub fn get_passive_power_from(&mut self, pos: IVec3, face: Face) -> u8 {
                self.get_power_from(pos, face, true).level
            }
            /// Get the power produced by a block on a given face.
            fn get_power_from(
                &mut self,
                pos: IVec3,
                face: Face,
                test_block: bool,
            ) -> Power {
                let Some((id, metadata)) = self.get_block(pos) else {
                    return Power::OFF
                };
                match id {
                    block::LEVER => self.get_lever_power_from(face, metadata),
                    block::BUTTON => self.get_button_power_from(face, metadata),
                    block::REPEATER_LIT => self.get_repeater_power_from(face, metadata),
                    block::REDSTONE_TORCH_LIT => {
                        self.get_redstone_torch_power_from(face, metadata)
                    }
                    block::REDSTONE => self.get_redstone_power_from(pos, face, metadata),
                    _ if test_block && block::material::is_opaque_cube(id) => {
                        self.get_block_power_from(pos, face)
                    }
                    _ => Power::OFF,
                }
            }
            /// Get the power of a block that would be indirectly powered.
            fn get_block_power_from(&mut self, pos: IVec3, face: Face) -> Power {
                let mut ret = Power {
                    level: 0,
                    indirect: false,
                    passive: true,
                };
                for test_face in [
                    Face::NegY,
                    Face::PosY,
                    Face::NegZ,
                    Face::PosZ,
                    Face::NegX,
                    Face::PosX,
                ] {
                    if test_face != face {
                        let power = self
                            .get_power_from(
                                pos + test_face.delta(),
                                test_face.opposite(),
                                false,
                            );
                        if power.indirect {
                            if !power.passive && ret.passive {
                                ret.level = power.level;
                                ret.passive = false;
                            } else if power.passive == ret.passive
                                && power.level > ret.level
                            {
                                ret.level = power.level;
                            }
                            if !ret.passive && ret.level >= 15 {
                                break;
                            }
                        }
                    }
                }
                ret
            }
            fn get_lever_power_from(&mut self, face: Face, metadata: u8) -> Power {
                if block::lever::is_active(metadata) {
                    if block::lever::get_face(metadata).map(|(f, _)| f) == Some(face) {
                        Power::ON_INDIRECT
                    } else {
                        Power::ON_DIRECT
                    }
                } else {
                    Power::OFF
                }
            }
            fn get_button_power_from(&mut self, face: Face, metadata: u8) -> Power {
                if block::button::is_active(metadata) {
                    if block::button::get_face(metadata) == Some(face) {
                        Power::ON_INDIRECT
                    } else {
                        Power::ON_DIRECT
                    }
                } else {
                    Power::OFF
                }
            }
            fn get_repeater_power_from(&mut self, face: Face, metadata: u8) -> Power {
                if block::repeater::get_face(metadata) == face {
                    Power::ON_INDIRECT
                } else {
                    Power::OFF
                }
            }
            fn get_redstone_torch_power_from(
                &mut self,
                face: Face,
                metadata: u8,
            ) -> Power {
                if block::torch::get_face(metadata) == Some(face) {
                    Power::OFF
                } else if face == Face::PosY {
                    Power::ON_INDIRECT
                } else {
                    Power::ON_DIRECT
                }
            }
            fn get_redstone_power_from(
                &mut self,
                pos: IVec3,
                face: Face,
                metadata: u8,
            ) -> Power {
                if face == Face::PosY || metadata == 0 {
                    Power::OFF
                } else if face == Face::NegY {
                    Power {
                        level: metadata,
                        indirect: true,
                        passive: true,
                    }
                } else {
                    let mut links = FaceSet::new();
                    let opaque_above = self
                        .get_block(pos + IVec3::Y)
                        .map(|(above_id, _)| block::material::is_opaque_cube(above_id))
                        .unwrap_or(true);
                    for face in [Face::NegX, Face::PosX, Face::NegZ, Face::PosZ] {
                        let face_pos = pos + face.delta();
                        if self.is_linkable_from(face_pos, face.opposite()) {
                            links.insert(face);
                        } else {
                            if let Some((id, _)) = self.get_block(face_pos) {
                                if !block::material::is_opaque_cube(id) {
                                    if self.is_linkable_from(face_pos - IVec3::Y, Face::PosY) {
                                        links.insert(face);
                                    }
                                } else if !opaque_above {
                                    if self.is_linkable_from(face_pos + IVec3::Y, Face::NegY) {
                                        links.insert(face);
                                    }
                                }
                            }
                        }
                    }
                    let indirect = if links.is_empty() {
                        true
                    } else {
                        match face {
                            Face::NegZ => {
                                links.contains(Face::PosZ) && !links.contains_x()
                            }
                            Face::PosZ => {
                                links.contains(Face::NegZ) && !links.contains_x()
                            }
                            Face::NegX => {
                                links.contains(Face::PosX) && !links.contains_z()
                            }
                            Face::PosX => {
                                links.contains(Face::NegX) && !links.contains_z()
                            }
                            _ => {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                        }
                    };
                    Power {
                        level: metadata,
                        indirect,
                        passive: true,
                    }
                }
            }
            /// Return true if the block at given position can link to a redstone wire from its
            /// given face.
            fn is_linkable_from(&mut self, pos: IVec3, face: Face) -> bool {
                if let Some((id, metadata)) = self.get_block(pos) {
                    match id {
                        block::LEVER
                        | block::BUTTON
                        | block::DETECTOR_RAIL
                        | block::WOOD_PRESSURE_PLATE
                        | block::STONE_PRESSURE_PLATE
                        | block::REDSTONE_TORCH
                        | block::REDSTONE_TORCH_LIT
                        | block::REDSTONE => true,
                        block::REPEATER | block::REPEATER_LIT => {
                            let repeater_face = block::repeater::get_face(metadata);
                            face == repeater_face.opposite()
                        }
                        _ => false,
                    }
                } else {
                    false
                }
            }
        }
        /// Internal structure describing the properties of a redstone power signal.
        struct Power {
            /// The redstone power level (0..16).
            level: u8,
            /// If this power can be relayed indirectly by opaque blocks.
            indirect: bool,
            /// If this power is passive.
            passive: bool,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Power {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "Power",
                    "level",
                    &self.level,
                    "indirect",
                    &self.indirect,
                    "passive",
                    &&self.passive,
                )
            }
        }
        impl Power {
            const OFF: Self = Self {
                level: 0,
                indirect: false,
                passive: false,
            };
            const ON_INDIRECT: Self = Self {
                level: 15,
                indirect: true,
                passive: false,
            };
            const ON_DIRECT: Self = Self {
                level: 15,
                indirect: false,
                passive: false,
            };
        }
    }
    pub mod loot {
        //! Looting functions to spawn items in a world, also contains the loots for each block.
        use std::ops::{Mul, Sub};
        use glam::{IVec3, DVec3};
        use crate::entity::Item;
        use crate::item::ItemStack;
        use crate::{block, item};
        use super::World;
        /// Methods related to loot spawning in the world and block loot randomization.
        impl World {
            /// Spawn item entity in the world containing the given stack. The velocity of the
            /// spawned item stack is random and the initial position depends on the given spread.
            /// This item entity will be impossible to pickup for 10 ticks.
            pub fn spawn_loot(&mut self, mut pos: DVec3, stack: ItemStack, spread: f32) {
                if spread != 0.0 {
                    pos
                        += self
                            .rand
                            .next_float_vec()
                            .mul(spread)
                            .as_dvec3()
                            .sub(spread as f64 * 0.5);
                }
                let entity = Item::new_with(|base, item| {
                    base.persistent = true;
                    base.pos = pos;
                    base.vel.x = self.rand.next_double() * 0.2 - 0.1;
                    base.vel.y = 0.2;
                    base.vel.z = self.rand.next_double() * 0.2 - 0.1;
                    item.stack = stack;
                    item.frozen_time = 10;
                });
                self.spawn_entity(entity);
            }
            /// Spawn item entities in the world depending on the loot of the given block id and
            /// metadata. Each block has a different random try count and loots, the given chance
            /// if looting is checked on each try, typically used for explosions.
            pub fn spawn_block_loot(
                &mut self,
                pos: IVec3,
                id: u8,
                metadata: u8,
                chance: f32,
            ) {
                let tries = self.get_block_loot_tries(id, metadata);
                for try_num in 0..tries {
                    if self.rand.next_float()
                        <= self.get_block_loot_chance(id, metadata, try_num, chance)
                    {
                        let stack = self.get_block_loot_stack(id, metadata, try_num);
                        if !stack.is_empty() {
                            self.spawn_loot(pos.as_dvec3() + 0.5, stack, 0.7);
                        }
                    }
                }
            }
            /// Get the tries count from a block and metadata.
            fn get_block_loot_tries(&mut self, id: u8, _metadata: u8) -> u8 {
                match id {
                    block::AIR => 0,
                    block::BOOKSHELF => 0,
                    block::CAKE => 0,
                    block::CLAY => 4,
                    block::WHEAT => 4,
                    block::FIRE => 0,
                    block::WATER_MOVING
                    | block::WATER_STILL
                    | block::LAVA_MOVING
                    | block::LAVA_STILL => 0,
                    block::GLASS => 0,
                    block::GLOWSTONE => 2 + self.rand.next_int_bounded(3) as u8,
                    block::ICE => 0,
                    block::LEAVES if self.rand.next_int_bounded(20) != 0 => 0,
                    block::SPAWNER => 0,
                    block::LAPIS_ORE => 4 + self.rand.next_int_bounded(5) as u8,
                    block::PISTON_EXT | block::PISTON_MOVING => 0,
                    block::PORTAL => 0,
                    block::REDSTONE_ORE | block::REDSTONE_ORE_LIT => {
                        4 + self.rand.next_int_bounded(2) as u8
                    }
                    block::SNOW => 0,
                    block::SNOW_BLOCK => 4,
                    block::DOUBLE_SLAB => 2,
                    block::TNT => 0,
                    _ => 1,
                }
            }
            fn get_block_loot_chance(
                &mut self,
                id: u8,
                metadata: u8,
                try_num: u8,
                default_chance: f32,
            ) -> f32 {
                match id {
                    block::WHEAT if try_num != 0 => metadata as f32 / 14.0,
                    _ => default_chance,
                }
            }
            /// Get the drop item stack from a block and metadata. This is called for each try.
            fn get_block_loot_stack(
                &mut self,
                id: u8,
                metadata: u8,
                try_num: u8,
            ) -> ItemStack {
                match id {
                    block::BED if block::bed::is_head(metadata) => ItemStack::EMPTY,
                    block::BED => ItemStack::new_single(item::BED, 0),
                    block::CAKE => ItemStack::EMPTY,
                    block::CLAY => ItemStack::new_single(item::CLAY, 0),
                    block::WHEAT if try_num == 0 && metadata != 7 => {
                        return ItemStack::EMPTY;
                    }
                    block::WHEAT if try_num == 0 => ItemStack::new_single(item::WHEAT, 0),
                    block::WHEAT => ItemStack::new_single(item::WHEAT_SEEDS, 0),
                    block::DEAD_BUSH => ItemStack::EMPTY,
                    block::WOOD_DOOR
                    | block::IRON_DOOR if block::door::is_upper(metadata) => {
                        ItemStack::EMPTY
                    }
                    block::WOOD_DOOR => ItemStack::new_single(item::WOOD_DOOR, 0),
                    block::IRON_DOOR => ItemStack::new_single(item::IRON_DOOR, 0),
                    block::FARMLAND | block::GRASS => {
                        ItemStack::new_block(block::DIRT, 0)
                    }
                    block::WATER_MOVING
                    | block::WATER_STILL
                    | block::LAVA_MOVING
                    | block::LAVA_STILL => ItemStack::EMPTY,
                    block::FURNACE | block::FURNACE_LIT => {
                        ItemStack::new_block(block::FURNACE, 0)
                    }
                    block::GLOWSTONE => ItemStack::new_single(item::GLOWSTONE_DUST, 0),
                    block::GRAVEL if self.rand.next_int_bounded(10) == 0 => {
                        ItemStack::new_single(item::FLINT, 0)
                    }
                    block::LEAVES => ItemStack::new_block(block::SAPLING, metadata & 3),
                    block::SPAWNER => ItemStack::EMPTY,
                    block::COAL_ORE => ItemStack::new_single(item::COAL, 0),
                    block::DIAMOND_ORE => ItemStack::new_single(item::DIAMOND, 0),
                    block::REDSTONE_ORE | block::REDSTONE_ORE_LIT => {
                        ItemStack::new_single(item::REDSTONE, 0)
                    }
                    block::LAPIS_ORE => ItemStack::new_single(item::DYE, 4),
                    block::PISTON_EXT | block::PISTON_MOVING => ItemStack::EMPTY,
                    block::REDSTONE => ItemStack::new_single(item::REDSTONE, 0),
                    block::REPEATER | block::REPEATER_LIT => {
                        ItemStack::new_single(item::REPEATER, 0)
                    }
                    block::REDSTONE_TORCH | block::REDSTONE_TORCH_LIT => {
                        ItemStack::new_block(block::REDSTONE_TORCH_LIT, 0)
                    }
                    block::SUGAR_CANES => ItemStack::new_single(item::SUGAR_CANES, 0),
                    block::SIGN | block::WALL_SIGN => {
                        ItemStack::new_single(item::SIGN, 0)
                    }
                    block::SNOW_BLOCK | block::SNOW => {
                        ItemStack::new_single(item::SNOWBALL, 0)
                    }
                    block::SLAB | block::DOUBLE_SLAB => {
                        ItemStack::new_block(block::SLAB, metadata)
                    }
                    block::STONE => ItemStack::new_block(block::COBBLESTONE, 0),
                    block::TALL_GRASS if self.rand.next_int_bounded(8) == 0 => {
                        ItemStack::new_single(item::WHEAT_SEEDS, 0)
                    }
                    block::TALL_GRASS => ItemStack::EMPTY,
                    block::COBWEB => ItemStack::new_single(item::STRING, 0),
                    block::LOG => ItemStack::new_block(block::LOG, metadata),
                    block::WOOL => ItemStack::new_block(block::WOOL, metadata),
                    block::SAPLING => ItemStack::new_block(block::SAPLING, metadata & 3),
                    _ => ItemStack::new_block(id, 0),
                }
            }
        }
    }
    pub mod interact {
        //! Interaction of players with blocks in the world.
        use glam::IVec3;
        use crate::block_entity::BlockEntity;
        use crate::geom::Face;
        use crate::block;
        use super::World;
        /// Methods related to block interactions when client clicks on a block.
        impl World {
            /// Interact with a block at given position. This function returns true if an
            /// interaction has been handled and some action happened to the world, which should
            /// typically prevent usage of the player's hand item.
            pub fn interact_block(&mut self, pos: IVec3) -> Interaction {
                if let Some((id, metadata)) = self.get_block(pos) {
                    self.interact_block_unchecked(pos, id, metadata)
                } else {
                    Interaction::None
                }
            }
            /// Internal function to handle block interaction at given position and with known
            /// block and metadata. The function returns true if an interaction has been handled.
            pub(super) fn interact_block_unchecked(
                &mut self,
                pos: IVec3,
                id: u8,
                metadata: u8,
            ) -> Interaction {
                match id {
                    block::BUTTON => self.interact_button(pos, metadata),
                    block::LEVER => self.interact_lever(pos, metadata),
                    block::TRAPDOOR => self.interact_trapdoor(pos, metadata),
                    block::IRON_DOOR => true,
                    block::WOOD_DOOR => self.interact_wood_door(pos, metadata),
                    block::REPEATER | block::REPEATER_LIT => {
                        self.interact_repeater(pos, id, metadata)
                    }
                    block::REDSTONE_ORE => self.interact_redstone_ore(pos),
                    block::CRAFTING_TABLE => return Interaction::CraftingTable { pos },
                    block::CHEST => return self.interact_chest(pos),
                    block::FURNACE | block::FURNACE_LIT => {
                        return self.interact_furnace(pos);
                    }
                    block::DISPENSER => return self.interact_dispenser(pos),
                    _ => return Interaction::None,
                }
                    .into()
            }
            /// Interact with a button block.
            fn interact_button(&mut self, pos: IVec3, mut metadata: u8) -> bool {
                if !block::button::is_active(metadata) {
                    block::button::set_active(&mut metadata, true);
                    self.set_block_notify(pos, block::BUTTON, metadata);
                    self.schedule_block_tick(pos, block::BUTTON, 20);
                }
                true
            }
            fn interact_lever(&mut self, pos: IVec3, mut metadata: u8) -> bool {
                let active = block::lever::is_active(metadata);
                block::lever::set_active(&mut metadata, !active);
                self.set_block_notify(pos, block::LEVER, metadata);
                true
            }
            fn interact_trapdoor(&mut self, pos: IVec3, mut metadata: u8) -> bool {
                let active = block::trapdoor::is_open(metadata);
                block::trapdoor::set_open(&mut metadata, !active);
                self.set_block_notify(pos, block::TRAPDOOR, metadata);
                true
            }
            fn interact_wood_door(&mut self, pos: IVec3, mut metadata: u8) -> bool {
                if block::door::is_upper(metadata) {
                    if let Some((block::WOOD_DOOR, metadata)) = self
                        .get_block(pos - IVec3::Y)
                    {
                        self.interact_wood_door(pos - IVec3::Y, metadata);
                    }
                } else {
                    let open = block::door::is_open(metadata);
                    block::door::set_open(&mut metadata, !open);
                    self.set_block_notify(pos, block::WOOD_DOOR, metadata);
                    if let Some((block::WOOD_DOOR, _)) = self.get_block(pos + IVec3::Y) {
                        block::door::set_upper(&mut metadata, true);
                        self.set_block_notify(
                            pos + IVec3::Y,
                            block::WOOD_DOOR,
                            metadata,
                        );
                    }
                }
                true
            }
            fn interact_repeater(
                &mut self,
                pos: IVec3,
                id: u8,
                mut metadata: u8,
            ) -> bool {
                let delay = block::repeater::get_delay(metadata);
                block::repeater::set_delay(&mut metadata, (delay + 1) % 4);
                self.set_block_notify(pos, id, metadata);
                true
            }
            fn interact_redstone_ore(&mut self, pos: IVec3) -> bool {
                self.set_block_notify(pos, block::REDSTONE_ORE_LIT, 0);
                false
            }
            fn interact_chest(&mut self, pos: IVec3) -> Interaction {
                let Some(BlockEntity::Chest(_)) = self.get_block_entity(pos) else {
                    return Interaction::Handled
                };
                if self.is_block_opaque_cube(pos + IVec3::Y) {
                    return Interaction::Handled;
                }
                for face in Face::HORIZONTAL {
                    let face_pos = pos + face.delta();
                    if self.is_block(face_pos, block::CHEST)
                        && self.is_block_opaque_cube(face_pos + IVec3::Y)
                    {
                        return Interaction::Handled;
                    }
                }
                let mut all_pos = <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([pos]),
                );
                for face in [Face::NegX, Face::PosX, Face::NegZ, Face::PosZ] {
                    let face_pos = pos + face.delta();
                    if let Some(BlockEntity::Chest(_)) = self.get_block_entity(face_pos)
                    {
                        if face.is_neg() {
                            all_pos.insert(0, face_pos);
                        } else {
                            all_pos.push(face_pos);
                        }
                    }
                }
                Interaction::Chest { pos: all_pos }
            }
            fn interact_furnace(&mut self, pos: IVec3) -> Interaction {
                if let Some(BlockEntity::Furnace(_)) = self.get_block_entity(pos) {
                    Interaction::Furnace { pos }
                } else {
                    Interaction::None
                }
            }
            fn interact_dispenser(&mut self, pos: IVec3) -> Interaction {
                if let Some(BlockEntity::Dispenser(_)) = self.get_block_entity(pos) {
                    Interaction::Dispenser { pos }
                } else {
                    Interaction::None
                }
            }
        }
        /// The result of an interaction with a block in the world.
        pub enum Interaction {
            /// No interaction has been handled.
            None,
            /// An interaction has been handled by the world.
            Handled,
            /// A crafting table has been interacted, the front-end should interpret this and
            /// open the crafting table window.
            CraftingTable {
                /// Position of the crafting table being interacted.
                pos: IVec3,
            },
            /// A chest has been interacted, the front-end should interpret this and open the
            /// chest window.
            Chest {
                /// Positions of the chest block entities to connect to, from top layer in the
                /// window to bottom one. They have been checked to exists before.
                pos: Vec<IVec3>,
            },
            /// A furnace has been interacted, the front-end should interpret this and open the
            /// furnace window.
            Furnace {
                /// Position of the furnace block entity to connect to, it has been checked to
                /// exists.
                pos: IVec3,
            },
            /// A dispenser has been interacted, the front-end should interpret this and open
            /// the dispenser window.
            Dispenser {
                /// Position of the dispenser block entity to connect to, it has been checked to
                /// exists.
                pos: IVec3,
            },
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Interaction {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Interaction::None => ::core::fmt::Formatter::write_str(f, "None"),
                    Interaction::Handled => {
                        ::core::fmt::Formatter::write_str(f, "Handled")
                    }
                    Interaction::CraftingTable { pos: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "CraftingTable",
                            "pos",
                            &__self_0,
                        )
                    }
                    Interaction::Chest { pos: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "Chest",
                            "pos",
                            &__self_0,
                        )
                    }
                    Interaction::Furnace { pos: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "Furnace",
                            "pos",
                            &__self_0,
                        )
                    }
                    Interaction::Dispenser { pos: __self_0 } => {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "Dispenser",
                            "pos",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Interaction {
            #[inline]
            fn clone(&self) -> Interaction {
                match self {
                    Interaction::None => Interaction::None,
                    Interaction::Handled => Interaction::Handled,
                    Interaction::CraftingTable { pos: __self_0 } => {
                        Interaction::CraftingTable {
                            pos: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Interaction::Chest { pos: __self_0 } => {
                        Interaction::Chest {
                            pos: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Interaction::Furnace { pos: __self_0 } => {
                        Interaction::Furnace {
                            pos: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    Interaction::Dispenser { pos: __self_0 } => {
                        Interaction::Dispenser {
                            pos: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                }
            }
        }
        impl From<bool> for Interaction {
            #[inline]
            fn from(value: bool) -> Self {
                if value { Self::Handled } else { Self::None }
            }
        }
    }
    pub mod place {
        //! Advanced block placing methods.
        use glam::IVec3;
        use crate::block_entity::BlockEntity;
        use crate::block::material::Material;
        use crate::util::default as def;
        use crate::geom::Face;
        use crate::block;
        use super::World;
        /// Methods related to block placing.
        impl World {
            /// This function checks if the given block id can be placed at a particular position in
            /// the world, the given face indicates toward which face this block should be oriented.
            pub fn can_place_block(&mut self, pos: IVec3, face: Face, id: u8) -> bool {
                let base = match id {
                    block::BUTTON if face.is_y() => false,
                    block::BUTTON => self.is_block_opaque_cube(pos + face.delta()),
                    block::LEVER if face == Face::PosY => false,
                    block::LEVER => self.is_block_opaque_cube(pos + face.delta()),
                    block::LADDER => self.is_block_opaque_around(pos),
                    block::TRAPDOOR if face.is_y() => false,
                    block::TRAPDOOR => self.is_block_opaque_cube(pos + face.delta()),
                    block::PISTON_EXT | block::PISTON_MOVING => false,
                    block::DEAD_BUSH => {
                        match self.get_block(pos - IVec3::Y) {
                            Some((block::SAND, _)) => true,
                            _ => false,
                        }
                    }
                    block::DANDELION
                    | block::POPPY
                    | block::SAPLING
                    | block::TALL_GRASS => {
                        match self.get_block(pos - IVec3::Y) {
                            Some((block::GRASS | block::DIRT | block::FARMLAND, _)) => {
                                true
                            }
                            _ => false,
                        }
                    }
                    block::WHEAT => {
                        match self.get_block(pos - IVec3::Y) {
                            Some((block::FARMLAND, _)) => true,
                            _ => false,
                        }
                    }
                    block::CACTUS => self.can_place_cactus(pos),
                    block::SUGAR_CANES => self.can_place_sugar_canes(pos),
                    block::CAKE => self.is_block_solid(pos - IVec3::Y),
                    block::CHEST => self.can_place_chest(pos),
                    block::WOOD_DOOR | block::IRON_DOOR => self.can_place_door(pos),
                    block::FENCE => {
                        (match self.get_block(pos - IVec3::Y) {
                            Some((block::FENCE, _)) => true,
                            _ => false,
                        }) || self.is_block_solid(pos - IVec3::Y)
                    }
                    block::FIRE => self.can_place_fire(pos),
                    block::TORCH | block::REDSTONE_TORCH | block::REDSTONE_TORCH_LIT => {
                        self.is_block_opaque_cube(pos + face.delta())
                    }
                    block::RED_MUSHROOM
                    | block::BROWN_MUSHROOM
                    | block::WOOD_PRESSURE_PLATE
                    | block::STONE_PRESSURE_PLATE
                    | block::PUMPKIN
                    | block::PUMPKIN_LIT
                    | block::RAIL
                    | block::POWERED_RAIL
                    | block::DETECTOR_RAIL
                    | block::REPEATER
                    | block::REPEATER_LIT
                    | block::REDSTONE
                    | block::SNOW => self.is_block_opaque_cube(pos - IVec3::Y),
                    _ => true,
                };
                if let Some(bb) = self.get_block_exclusion_box(pos, id) {
                    if self.has_entity_colliding(bb, true) {
                        return false;
                    }
                }
                base && self.is_block_replaceable(pos)
            }
            fn can_place_cactus(&mut self, pos: IVec3) -> bool {
                for face in Face::HORIZONTAL {
                    if self.is_block_solid(pos + face.delta()) {
                        return false;
                    }
                }
                match self.get_block(pos - IVec3::Y) {
                    Some((block::CACTUS | block::SAND, _)) => true,
                    _ => false,
                }
            }
            fn can_place_sugar_canes(&mut self, pos: IVec3) -> bool {
                let below_pos = pos - IVec3::Y;
                if let Some((block::SUGAR_CANES | block::GRASS | block::DIRT, _)) = self
                    .get_block(below_pos)
                {
                    for face in Face::HORIZONTAL {
                        if self.get_block_material(below_pos + face.delta())
                            == Material::Water
                        {
                            return true;
                        }
                    }
                }
                false
            }
            fn can_place_chest(&mut self, pos: IVec3) -> bool {
                let mut found_single_chest = false;
                for face in Face::HORIZONTAL {
                    let neighbor_pos = pos + face.delta();
                    if match self.get_block(neighbor_pos) {
                        Some((block::CHEST, _)) => true,
                        _ => false,
                    } {
                        if found_single_chest {
                            return false;
                        }
                        for neighbor_face in Face::HORIZONTAL {
                            if face != neighbor_face.opposite() {
                                if match self
                                    .get_block(neighbor_pos + neighbor_face.delta())
                                {
                                    Some((block::CHEST, _)) => true,
                                    _ => false,
                                } {
                                    return false;
                                }
                            }
                        }
                        found_single_chest = true;
                    }
                }
                true
            }
            fn can_place_door(&mut self, pos: IVec3) -> bool {
                self.is_block_opaque_cube(pos - IVec3::Y)
                    && self.is_block_replaceable(pos + IVec3::Y)
            }
            fn can_place_fire(&mut self, pos: IVec3) -> bool {
                if self.is_block_opaque_cube(pos - IVec3::Y) {
                    true
                } else {
                    for face in Face::ALL {
                        if let Some((block, _)) = self.get_block(pos + face.delta()) {
                            if block::material::get_fire_flammability(block) != 0 {
                                return true;
                            }
                        }
                    }
                    false
                }
            }
            /// Place the block at the given position in the world oriented toward given face. Note
            /// that this function do not check if this is legal, it will do what's asked. Also, the
            /// given metadata may be modified to account for the placement.
            pub fn place_block(&mut self, pos: IVec3, face: Face, id: u8, metadata: u8) {
                match id {
                    block::BUTTON => {
                        self.place_faced(
                            pos,
                            face,
                            id,
                            metadata,
                            block::button::set_face,
                        )
                    }
                    block::TRAPDOOR => {
                        self.place_faced(
                            pos,
                            face,
                            id,
                            metadata,
                            block::trapdoor::set_face,
                        )
                    }
                    block::PISTON => {
                        self.place_faced(
                            pos,
                            face,
                            id,
                            metadata,
                            block::piston::set_face,
                        )
                    }
                    block::WOOD_STAIR | block::COBBLESTONE_STAIR => {
                        self.place_faced(pos, face, id, metadata, block::stair::set_face)
                    }
                    block::REPEATER | block::REPEATER_LIT => {
                        self.place_faced(
                            pos,
                            face,
                            id,
                            metadata,
                            block::repeater::set_face,
                        )
                    }
                    block::PUMPKIN | block::PUMPKIN_LIT => {
                        self.place_faced(
                            pos,
                            face,
                            id,
                            metadata,
                            block::pumpkin::set_face,
                        )
                    }
                    block::FURNACE | block::FURNACE_LIT | block::DISPENSER => {
                        self.place_faced(
                            pos,
                            face,
                            id,
                            metadata,
                            block::dispenser::set_face,
                        )
                    }
                    block::TORCH | block::REDSTONE_TORCH | block::REDSTONE_TORCH_LIT => {
                        self.place_faced(pos, face, id, metadata, block::torch::set_face)
                    }
                    block::LEVER => self.place_lever(pos, face, metadata),
                    block::LADDER => self.place_ladder(pos, face, metadata),
                    _ => {
                        self.set_block_notify(pos, id, metadata);
                    }
                }
                match id {
                    block::CHEST => self.set_block_entity(pos, BlockEntity::Chest(def())),
                    block::FURNACE => {
                        self.set_block_entity(pos, BlockEntity::Furnace(def()))
                    }
                    block::DISPENSER => {
                        self.set_block_entity(pos, BlockEntity::Dispenser(def()))
                    }
                    block::SPAWNER => {
                        self.set_block_entity(pos, BlockEntity::Spawner(def()))
                    }
                    block::NOTE_BLOCK => {
                        self.set_block_entity(pos, BlockEntity::NoteBlock(def()))
                    }
                    block::JUKEBOX => {
                        self.set_block_entity(pos, BlockEntity::Jukebox(def()))
                    }
                    _ => {}
                }
            }
            /// Generic function to place a block that has a basic facing function.
            fn place_faced(
                &mut self,
                pos: IVec3,
                face: Face,
                id: u8,
                mut metadata: u8,
                func: impl FnOnce(&mut u8, Face),
            ) {
                func(&mut metadata, face);
                self.set_block_notify(pos, id, metadata);
            }
            fn place_lever(&mut self, pos: IVec3, face: Face, mut metadata: u8) {
                block::lever::set_face(
                    &mut metadata,
                    face,
                    match face {
                        Face::NegY => self.rand.next_choice(&[Face::PosZ, Face::PosX]),
                        _ => Face::PosY,
                    },
                );
                self.set_block_notify(pos, block::LEVER, metadata);
            }
            fn place_ladder(&mut self, pos: IVec3, mut face: Face, mut metadata: u8) {
                if face.is_y() || !self.is_block_opaque_cube(pos + face.delta()) {
                    for around_face in [Face::PosZ, Face::NegZ, Face::PosX, Face::NegX] {
                        if self.is_block_opaque_cube(pos + around_face.delta()) {
                            face = around_face;
                            break;
                        }
                    }
                }
                block::ladder::set_face(&mut metadata, face);
                self.set_block_notify(pos, block::LADDER, metadata);
            }
            /// Check is there are at least one opaque block around horizontally.
            fn is_block_opaque_around(&mut self, pos: IVec3) -> bool {
                for face in Face::HORIZONTAL {
                    if self.is_block_opaque_cube(pos + face.delta()) {
                        return true;
                    }
                }
                false
            }
        }
    }
    pub mod r#break {
        //! Provides methods for breaking blocks with items. Block hardness and break duration
        //! depending on the tool.
        use glam::IVec3;
        use crate::block::material::Material;
        use crate::{block, item};
        use super::World;
        /// Methods related to block breaking.
        impl World {
            /// Break a block naturally and loot its items. This returns true if successful, false
            /// if the chunk/pos was not valid. It also notifies blocks around, this is basically
            /// a wrapper around [`set_block_notify`](Self::set_block_notify) method.
            pub fn break_block(&mut self, pos: IVec3) -> Option<(u8, u8)> {
                let (prev_id, prev_metadata) = self
                    .set_block_notify(pos, block::AIR, 0)?;
                self.spawn_block_loot(pos, prev_id, prev_metadata, 1.0);
                Some((prev_id, prev_metadata))
            }
            /// Get the minimum ticks duration required to break the block given its id.
            pub fn get_break_duration(
                &self,
                item_id: u16,
                block_id: u8,
                in_water: bool,
                on_ground: bool,
            ) -> f32 {
                let hardness = block::material::get_break_hardness(block_id);
                if hardness.is_infinite() {
                    f32::INFINITY
                } else {
                    if self.can_break(item_id, block_id) {
                        let mut env_modifier = self.get_break_speed(item_id, block_id);
                        if in_water {
                            env_modifier /= 5.0;
                        }
                        if !on_ground {
                            env_modifier /= 5.0;
                        }
                        hardness * 30.0 / env_modifier
                    } else {
                        hardness * 100.0
                    }
                }
            }
            /// Check if an item (given its id) can break a block without speed penalties and
            /// loose the items.
            fn can_break(&self, item_id: u16, block_id: u8) -> bool {
                match block_id {
                    block::OBSIDIAN => {
                        match item_id {
                            item::DIAMOND_PICKAXE => true,
                            _ => false,
                        }
                    }
                    block::DIAMOND_ORE
                    | block::DIAMOND_BLOCK
                    | block::GOLD_ORE
                    | block::GOLD_BLOCK
                    | block::REDSTONE_ORE
                    | block::REDSTONE_ORE_LIT => {
                        match item_id {
                            item::DIAMOND_PICKAXE | item::IRON_PICKAXE => true,
                            _ => false,
                        }
                    }
                    block::IRON_ORE
                    | block::IRON_BLOCK
                    | block::LAPIS_ORE
                    | block::LAPIS_BLOCK => {
                        match item_id {
                            item::DIAMOND_PICKAXE
                            | item::IRON_PICKAXE
                            | item::STONE_PICKAXE => true,
                            _ => false,
                        }
                    }
                    block::COBWEB => {
                        match item_id {
                            item::SHEARS
                            | item::DIAMOND_SWORD
                            | item::IRON_SWORD
                            | item::STONE_SWORD
                            | item::GOLD_SWORD
                            | item::WOOD_SWORD => true,
                            _ => false,
                        }
                    }
                    block::SNOW | block::SNOW_BLOCK => {
                        match item_id {
                            item::DIAMOND_SHOVEL
                            | item::IRON_SHOVEL
                            | item::STONE_SHOVEL
                            | item::GOLD_SHOVEL
                            | item::WOOD_SHOVEL => true,
                            _ => false,
                        }
                    }
                    _ => {
                        let material = block::material::get_material(block_id);
                        if material.is_breakable_by_default() {
                            return true;
                        }
                        match item_id {
                            item::DIAMOND_PICKAXE
                            | item::IRON_PICKAXE
                            | item::STONE_PICKAXE
                            | item::GOLD_PICKAXE
                            | item::WOOD_PICKAXE => {
                                match material {
                                    Material::Rock | Material::Iron => true,
                                    _ => false,
                                }
                            }
                            _ => false,
                        }
                    }
                }
            }
            /// Get the speed multiplier for breaking a given block with a given item.
            fn get_break_speed(&self, item_id: u16, block_id: u8) -> f32 {
                const DIAMOND_SPEED: f32 = 8.0;
                const IRON_SPEED: f32 = 6.0;
                const STONE_SPEED: f32 = 4.0;
                const WOOD_SPEED: f32 = 2.0;
                const GOLD_SPEED: f32 = 12.0;
                match block_id {
                    block::WOOD | block::BOOKSHELF | block::LOG | block::CHEST => {
                        match item_id {
                            item::DIAMOND_AXE => DIAMOND_SPEED,
                            item::IRON_AXE => IRON_SPEED,
                            item::STONE_AXE => STONE_SPEED,
                            item::WOOD_AXE => WOOD_SPEED,
                            item::GOLD_AXE => GOLD_SPEED,
                            _ => 1.0,
                        }
                    }
                    block::COBBLESTONE
                    | block::SLAB
                    | block::DOUBLE_SLAB
                    | block::STONE
                    | block::SANDSTONE
                    | block::MOSSY_COBBLESTONE
                    | block::IRON_ORE
                    | block::IRON_BLOCK
                    | block::GOLD_ORE
                    | block::GOLD_BLOCK
                    | block::COAL_ORE
                    | block::DIAMOND_ORE
                    | block::DIAMOND_BLOCK
                    | block::ICE
                    | block::NETHERRACK
                    | block::LAPIS_ORE
                    | block::LAPIS_BLOCK => {
                        match item_id {
                            item::DIAMOND_PICKAXE => DIAMOND_SPEED,
                            item::IRON_PICKAXE => IRON_SPEED,
                            item::STONE_PICKAXE => STONE_SPEED,
                            item::WOOD_PICKAXE => WOOD_SPEED,
                            item::GOLD_PICKAXE => GOLD_SPEED,
                            _ => 1.0,
                        }
                    }
                    block::GRASS
                    | block::DIRT
                    | block::SAND
                    | block::GRAVEL
                    | block::SNOW
                    | block::SNOW_BLOCK
                    | block::CLAY
                    | block::FARMLAND => {
                        match item_id {
                            item::DIAMOND_SHOVEL => DIAMOND_SPEED,
                            item::IRON_SHOVEL => IRON_SPEED,
                            item::STONE_SHOVEL => STONE_SPEED,
                            item::WOOD_SHOVEL => WOOD_SPEED,
                            item::GOLD_SHOVEL => GOLD_SPEED,
                            _ => 1.0,
                        }
                    }
                    block::COBWEB => {
                        match item_id {
                            item::SHEARS
                            | item::DIAMOND_SWORD
                            | item::IRON_SWORD
                            | item::STONE_SWORD
                            | item::GOLD_SWORD
                            | item::WOOD_SWORD => 15.0,
                            _ => 1.0,
                        }
                    }
                    block::LEAVES => {
                        match item_id {
                            item::SHEARS => 15.0,
                            _ => 1.0,
                        }
                    }
                    _ => {
                        match item_id {
                            item::DIAMOND_SWORD
                            | item::IRON_SWORD
                            | item::STONE_SWORD
                            | item::GOLD_SWORD
                            | item::WOOD_SWORD => 1.5,
                            _ => 1.0,
                        }
                    }
                }
            }
        }
    }
    pub mod r#use {
        //! Item use in the world.
        use glam::{IVec3, DVec3, Vec3};
        use crate::entity::{
            Arrow, Entity, Snowball, Tnt, Bobber, BaseKind, ProjectileKind, Item,
        };
        use crate::inventory::InventoryHandle;
        use crate::gen::tree::TreeGenerator;
        use crate::block::sapling::TreeKind;
        use crate::item::{ItemStack, self};
        use crate::geom::Face;
        use crate::block;
        use super::World;
        use super::bound::RayTraceKind;
        /// Methods related to item usage in the world.
        impl World {
            /// Use an item stack on a given block, this is basically the action of left click.
            /// This function returns the item stack after, if used, this may return an item stack
            /// with size of 0. The face is where the click has hit on the target block.
            pub fn use_stack(
                &mut self,
                inv: &mut InventoryHandle,
                index: usize,
                pos: IVec3,
                face: Face,
                entity_id: u32,
            ) {
                let stack = inv.get(index);
                if stack.is_empty() {
                    return;
                }
                let success = match stack.id {
                    0 => false,
                    1..=255 => {
                        self.use_block_stack(
                            stack.id as u8,
                            stack.damage as u8,
                            pos,
                            face,
                            entity_id,
                        )
                    }
                    item::SUGAR_CANES => {
                        self.use_block_stack(block::SUGAR_CANES, 0, pos, face, entity_id)
                    }
                    item::CAKE => {
                        self.use_block_stack(block::CAKE, 0, pos, face, entity_id)
                    }
                    item::REPEATER => {
                        self.use_block_stack(block::REPEATER, 0, pos, face, entity_id)
                    }
                    item::REDSTONE => {
                        self.use_block_stack(block::REDSTONE, 0, pos, face, entity_id)
                    }
                    item::WOOD_DOOR => {
                        self.use_door_stack(block::WOOD_DOOR, pos, face, entity_id)
                    }
                    item::IRON_DOOR => {
                        self.use_door_stack(block::IRON_DOOR, pos, face, entity_id)
                    }
                    item::BED => self.use_bed_stack(pos, face, entity_id),
                    item::DIAMOND_HOE
                    | item::IRON_HOE
                    | item::STONE_HOE
                    | item::GOLD_HOE
                    | item::WOOD_HOE => self.use_hoe_stack(pos, face),
                    item::WHEAT_SEEDS => self.use_wheat_seeds_stack(pos, face),
                    item::DYE if stack.damage == 15 => self.use_bone_meal_stack(pos),
                    item::FLINT_AND_STEEL => self.use_flint_and_steel(pos, face),
                    _ => false,
                };
                if success {
                    inv.set(index, stack.inc_damage(1));
                }
            }
            /// Use an item that is not meant to be used on blocks. Such as buckets, boats, bows or
            /// food items...
            pub fn use_raw_stack(
                &mut self,
                inv: &mut InventoryHandle,
                index: usize,
                entity_id: u32,
            ) {
                let stack = inv.get(index);
                if stack.is_empty() {
                    return;
                }
                match stack.id {
                    item::BUCKET | item::WATER_BUCKET | item::LAVA_BUCKET => {
                        self.use_bucket_stack(inv, index, entity_id)
                    }
                    item::BOW => self.use_bow_stack(inv, index, entity_id),
                    item::SNOWBALL => self.use_snowball_stack(inv, index, entity_id),
                    item::FISHING_ROD => {
                        self.use_fishing_rod_stack(inv, index, entity_id)
                    }
                    _ => {}
                }
            }
            /// Place a block toward the given face. This is used for single blocks, multi blocks
            /// are handled apart by other functions that do not rely on the block placing logic.
            fn use_block_stack(
                &mut self,
                id: u8,
                metadata: u8,
                mut pos: IVec3,
                mut face: Face,
                entity_id: u32,
            ) -> bool {
                let look = self.get_entity(entity_id).unwrap().0.look;
                if let Some((block::SNOW, _)) = self.get_block(pos) {
                    face = Face::NegY;
                } else {
                    pos += face.delta();
                    face = face.opposite();
                }
                match id {
                    block::WOOD_STAIR
                    | block::COBBLESTONE_STAIR
                    | block::REPEATER
                    | block::REPEATER_LIT => {
                        face = Face::from_yaw(look.x);
                    }
                    block::DISPENSER
                    | block::FURNACE
                    | block::FURNACE_LIT
                    | block::PUMPKIN
                    | block::PUMPKIN_LIT => {
                        face = Face::from_yaw(look.x).opposite();
                    }
                    block::PISTON => {
                        face = Face::from_look(look.x, look.y).opposite();
                    }
                    _ => {}
                }
                if pos.y >= 127 && block::material::get_material(id).is_solid() {
                    return false;
                }
                if !self.can_place_block(pos, face, id) {
                    return false;
                }
                self.place_block(pos, face, id, metadata);
                true
            }
            /// Place a door item at given position.
            fn use_door_stack(
                &mut self,
                block_id: u8,
                mut pos: IVec3,
                face: Face,
                entity_id: u32,
            ) -> bool {
                if face != Face::PosY {
                    return false;
                } else {
                    pos += IVec3::Y;
                }
                if pos.y >= 127 {
                    return false;
                } else if !self.can_place_block(pos, face.opposite(), block_id) {
                    return false;
                }
                let look = self.get_entity(entity_id).unwrap().0.look;
                let mut door_face = Face::from_yaw(look.x).opposite();
                let mut flip = false;
                let left_pos = pos + door_face.rotate_left().delta();
                let right_pos = pos + door_face.rotate_right().delta();
                let is_door_block = |pos| {
                    self.get_block(pos).map(|(id, _)| id == block_id).unwrap_or(false)
                };
                let left_door = is_door_block(left_pos)
                    || is_door_block(left_pos + IVec3::Y);
                let right_door = is_door_block(right_pos)
                    || is_door_block(right_pos + IVec3::Y);
                if right_door && !left_door {
                    flip = true;
                } else {
                    let left_count = self.is_block_opaque_cube(left_pos) as u8
                        + self.is_block_opaque_cube(left_pos + IVec3::Y) as u8;
                    let right_count = self.is_block_opaque_cube(right_pos) as u8
                        + self.is_block_opaque_cube(right_pos + IVec3::Y) as u8;
                    if left_count > right_count {
                        flip = true;
                    }
                }
                let mut metadata = 0;
                if flip {
                    block::door::set_open(&mut metadata, true);
                    door_face = door_face.rotate_left();
                }
                block::door::set_face(&mut metadata, door_face);
                self.set_block_notify(pos, block_id, metadata);
                block::door::set_upper(&mut metadata, true);
                self.set_block_notify(pos + IVec3::Y, block_id, metadata);
                true
            }
            fn use_bed_stack(
                &mut self,
                mut pos: IVec3,
                face: Face,
                entity_id: u32,
            ) -> bool {
                if face != Face::PosY {
                    return false;
                } else {
                    pos += IVec3::Y;
                }
                let look = self.get_entity(entity_id).unwrap().0.look;
                let bed_face = Face::from_yaw(look.x);
                let head_pos = pos + bed_face.delta();
                if !match self.get_block(pos) {
                    Some((block::AIR, _)) => true,
                    _ => false,
                } {
                    return false;
                } else if !match self.get_block(head_pos) {
                    Some((block::AIR, _)) => true,
                    _ => false,
                } {
                    return false;
                } else if !self.is_block_opaque_cube(pos - IVec3::Y)
                    || !self.is_block_opaque_cube(head_pos - IVec3::Y)
                {
                    return false;
                }
                let mut metadata = 0;
                block::bed::set_face(&mut metadata, bed_face);
                self.set_block_notify(pos, block::BED, metadata);
                block::bed::set_head(&mut metadata, true);
                self.set_block_notify(head_pos, block::BED, metadata);
                true
            }
            fn use_hoe_stack(&mut self, pos: IVec3, face: Face) -> bool {
                if let Some((id, _)) = self.get_block(pos) {
                    if let Some((above_id, _)) = self.get_block(pos + IVec3::Y) {
                        if (face != Face::NegY && above_id == block::AIR
                            && id == block::GRASS) || id == block::DIRT
                        {
                            self.set_block_notify(pos, block::FARMLAND, 0);
                            return true;
                        }
                    }
                }
                false
            }
            fn use_wheat_seeds_stack(&mut self, pos: IVec3, face: Face) -> bool {
                if face == Face::PosY {
                    if let Some((block::FARMLAND, _)) = self.get_block(pos) {
                        if let Some((block::AIR, _)) = self.get_block(pos + IVec3::Y) {
                            self.set_block_notify(pos + IVec3::Y, block::WHEAT, 0);
                            return true;
                        }
                    }
                }
                false
            }
            fn use_bone_meal_stack(&mut self, pos: IVec3) -> bool {
                let Some((block, metadata)) = self.get_block(pos) else { return false };
                if block == block::SAPLING {
                    let mut gen = match block::sapling::get_kind(metadata) {
                        TreeKind::Oak if self.get_rand_mut().next_int_bounded(10)
                            == 0 => TreeGenerator::new_big(),
                        TreeKind::Oak => TreeGenerator::new_oak(),
                        TreeKind::Birch => TreeGenerator::new_birch(),
                        TreeKind::Spruce => TreeGenerator::new_spruce2(),
                    };
                    gen.generate_from_sapling(self, pos);
                    true
                } else {
                    false
                }
            }
            fn use_flint_and_steel(&mut self, pos: IVec3, face: Face) -> bool {
                if self.is_block(pos, block::TNT) {
                    self.spawn_entity(
                        Tnt::new_with(|new_base, new_tnt| {
                            new_base.pos = pos.as_dvec3() + 0.5;
                            new_tnt.fuse_time = 80;
                        }),
                    );
                    self.set_block_notify(pos, block::AIR, 0);
                } else {
                    let fire_pos = pos + face.delta();
                    if self.is_block_air(fire_pos) {
                        self.set_block_notify(fire_pos, block::FIRE, 0);
                    }
                }
                true
            }
            fn use_bucket_stack(
                &mut self,
                inv: &mut InventoryHandle,
                index: usize,
                entity_id: u32,
            ) {
                let stack = inv.get(index);
                let fluid_id = match stack.id {
                    item::BUCKET => block::AIR,
                    item::WATER_BUCKET => block::WATER_MOVING,
                    item::LAVA_BUCKET => block::LAVA_MOVING,
                    _ => ::core::panicking::panic("not implemented"),
                };
                let entity = self.get_entity(entity_id).unwrap();
                let origin = entity.0.pos + DVec3::new(0.0, 1.62, 0.0);
                let yaw_dx = -entity.0.look.x.sin();
                let yaw_dz = entity.0.look.x.cos();
                let pitch_dy = -entity.0.look.y.sin();
                let pitch_h = entity.0.look.y.cos();
                let ray = Vec3::new(yaw_dx * pitch_h, pitch_dy, yaw_dz * pitch_h)
                    .as_dvec3() * 5.0;
                let kind = if fluid_id == block::AIR {
                    RayTraceKind::OverlayWithFluid
                } else {
                    RayTraceKind::Overlay
                };
                let Some(hit) = self.ray_trace_blocks(origin, ray, kind) else { return };
                let mut new_stack;
                if fluid_id == block::AIR {
                    let Some((id, metadata)) = self.get_block(hit.pos) else { return };
                    if !block::fluid::is_source(metadata) {
                        return;
                    }
                    new_stack = match id {
                        block::WATER_MOVING | block::WATER_STILL => {
                            ItemStack::new_single(item::WATER_BUCKET, 0)
                        }
                        block::LAVA_MOVING | block::LAVA_STILL => {
                            ItemStack::new_single(item::LAVA_BUCKET, 0)
                        }
                        _ => return,
                    };
                    self.set_block_notify(hit.pos, block::AIR, 0);
                } else {
                    let pos = hit.pos + hit.face.delta();
                    let Some((id, _)) = self.get_block(pos) else { return };
                    if id == block::AIR || !block::material::get_material(id).is_solid()
                    {
                        self.set_block_notify(pos, fluid_id, 0);
                    }
                    new_stack = ItemStack::new_single(item::BUCKET, 0);
                }
                if stack.size > 1 {
                    inv.push_front(&mut new_stack);
                    if new_stack.is_empty() {
                        inv.set(index, stack.with_size(stack.size - 1));
                    }
                } else {
                    inv.set(index, new_stack);
                }
            }
            fn use_bow_stack(
                &mut self,
                inv: &mut InventoryHandle,
                _index: usize,
                entity_id: u32,
            ) {
                if !inv.consume(ItemStack::new_single(item::ARROW, 0)) {
                    return;
                }
                let Entity(base, _) = self.get_entity(entity_id).unwrap();
                let arrow = Arrow::new_with(|arrow_base, arrow_projectile, arrow| {
                    arrow_base.pos = base.pos;
                    arrow_base.pos.y += base.eye_height as f64;
                    arrow_base.look = base.look;
                    let (yaw_sin, yaw_cos) = arrow_base.look.x.sin_cos();
                    let (pitch_sin, pitch_cos) = arrow_base.look.y.sin_cos();
                    arrow_base.vel.x = (-yaw_sin * pitch_cos) as f64;
                    arrow_base.vel.z = (yaw_cos * pitch_cos) as f64;
                    arrow_base.vel.y = (-pitch_sin) as f64;
                    arrow_base.vel += arrow_base.rand.next_gaussian_vec() * 0.0075;
                    arrow_base.vel *= 1.5;
                    arrow_projectile.owner_id = Some(entity_id);
                    arrow.from_player = true;
                });
                self.spawn_entity(arrow);
            }
            fn use_snowball_stack(
                &mut self,
                inv: &mut InventoryHandle,
                index: usize,
                entity_id: u32,
            ) {
                let stack = inv.get(index);
                inv.set(index, stack.inc_damage(1));
                let Entity(base, _) = self.get_entity(entity_id).unwrap();
                let snowball = Snowball::new_with(|throw_base, throw_projectile, _| {
                    throw_base.pos = base.pos;
                    throw_base.pos.y += base.eye_height as f64 - 0.1;
                    throw_base.look = base.look;
                    let (yaw_sin, yaw_cos) = throw_base.look.x.sin_cos();
                    let (pitch_sin, pitch_cos) = throw_base.look.y.sin_cos();
                    throw_base.vel.x = (-yaw_sin * pitch_cos) as f64;
                    throw_base.vel.z = (yaw_cos * pitch_cos) as f64;
                    throw_base.vel.y = (-pitch_sin) as f64;
                    throw_base.pos.x += throw_base.vel.x * 0.16;
                    throw_base.pos.z += throw_base.vel.z * 0.16;
                    throw_base.vel += throw_base.rand.next_gaussian_vec() * 0.0075;
                    throw_base.vel *= 1.5;
                    throw_projectile.owner_id = Some(entity_id);
                });
                self.spawn_entity(snowball);
            }
            fn use_fishing_rod_stack(
                &mut self,
                inv: &mut InventoryHandle,
                index: usize,
                entity_id: u32,
            ) {
                let Entity(base, _) = self.get_entity_mut(entity_id).unwrap();
                let base_pos = base.pos;
                let base_look = base.look;
                let mut new_bobber_id = base.bobber_id;
                let mut item_damage = 0;
                if let Some(bobber_id) = new_bobber_id {
                    if let Some(
                        Entity(
                            bobber_base,
                            BaseKind::Projectile(
                                bobber_projectile,
                                ProjectileKind::Bobber(bobber),
                            ),
                        ),
                    ) = self.get_entity(bobber_id)
                    {
                        let bobber_pos = bobber_base.pos;
                        let bobber_delta = base_pos - bobber_pos;
                        let bobber_dist = bobber_delta.length();
                        let mut bobber_accel = bobber_delta * 0.1;
                        bobber_accel.y += bobber_dist.sqrt() * 0.08;
                        if let Some(attached_id) = bobber.attached_id {
                            if let Some(Entity(attached_base, _)) = self
                                .get_entity_mut(attached_id)
                            {
                                attached_base.vel += bobber_accel;
                                item_damage = 3;
                            }
                        } else if bobber.catch_time > 0 {
                            self.spawn_entity(
                                Item::new_with(|item_base, item| {
                                    item_base.persistent = true;
                                    item_base.pos = bobber_pos;
                                    item_base.vel = bobber_accel;
                                    item.stack = ItemStack::new_single(item::RAW_FISH, 0);
                                }),
                            );
                            item_damage = 1;
                        } else if bobber_projectile.state.is_some() {
                            item_damage = 2;
                        }
                    }
                    self.remove_entity(bobber_id, "bobber retracted");
                    new_bobber_id = None;
                } else {
                    let bobber = Bobber::new_with(|throw_base, throw_projectile, _| {
                        throw_base.pos = base_pos;
                        throw_base.pos.y += 1.62 - 0.1;
                        throw_base.look = base_look;
                        let (yaw_sin, yaw_cos) = throw_base.look.x.sin_cos();
                        let (pitch_sin, pitch_cos) = throw_base.look.y.sin_cos();
                        throw_base.vel.x = (-yaw_sin * pitch_cos) as f64;
                        throw_base.vel.z = (yaw_cos * pitch_cos) as f64;
                        throw_base.vel.y = (-pitch_sin) as f64;
                        throw_base.pos.x += throw_base.vel.x * 0.16;
                        throw_base.pos.z += throw_base.vel.z * 0.16;
                        throw_base.vel += throw_base.rand.next_gaussian_vec() * 0.0075;
                        throw_base.vel *= 1.5;
                        throw_projectile.owner_id = Some(entity_id);
                    });
                    new_bobber_id = Some(self.spawn_entity(bobber));
                }
                let Entity(base, _) = self.get_entity_mut(entity_id).unwrap();
                base.bobber_id = new_bobber_id;
                let stack = inv.get(index);
                inv.set(index, stack.inc_damage(item_damage));
            }
        }
    }
    pub mod tick {
        //! Block ticking functions.
        use glam::{IVec3, DVec3};
        use tracing::warn;
        use crate::entity::{Item, FallingBlock};
        use crate::block::material::Material;
        use crate::block_entity::BlockEntity;
        use crate::block::sapling::TreeKind;
        use crate::gen::tree::TreeGenerator;
        use crate::geom::{Face, FaceSet};
        use crate::{block, item};
        use super::{
            World, Dimension, Event, BlockEntityEvent, BlockEntityStorage, Weather,
        };
        /// Methods related to block scheduled ticking and random ticking.
        impl World {
            /// Tick a block in the world. The random boolean indicates if it's a random tick.
            /// This function is unchecked because the caller should ensure that the given id
            /// and metadata is coherent with the given position.
            pub(super) fn tick_block_unchecked(
                &mut self,
                pos: IVec3,
                id: u8,
                metadata: u8,
                random: bool,
            ) {
                match id {
                    block::BUTTON if !random => self.tick_button(pos, metadata),
                    block::REPEATER if !random => {
                        self.tick_repeater(pos, metadata, false)
                    }
                    block::REPEATER_LIT if !random => {
                        self.tick_repeater(pos, metadata, true)
                    }
                    block::REDSTONE_TORCH if !random => {
                        self.tick_redstone_torch(pos, metadata, false)
                    }
                    block::REDSTONE_TORCH_LIT if !random => {
                        self.tick_redstone_torch(pos, metadata, true)
                    }
                    block::DISPENSER if !random => self.tick_dispenser(pos, metadata),
                    block::WATER_MOVING => {
                        self.tick_fluid_moving(pos, block::WATER_MOVING, metadata)
                    }
                    block::LAVA_MOVING => {
                        self.tick_fluid_moving(pos, block::LAVA_MOVING, metadata)
                    }
                    block::SUGAR_CANES | block::CACTUS => {
                        self.tick_cactus_or_sugar_canes(pos, id, metadata)
                    }
                    block::CAKE => {}
                    block::WHEAT => self.tick_wheat(pos, metadata),
                    block::DETECTOR_RAIL => {}
                    block::FARMLAND => {}
                    block::FIRE => self.tick_fire(pos, metadata),
                    block::DANDELION
                    | block::POPPY
                    | block::DEAD_BUSH
                    | block::TALL_GRASS => {}
                    block::RED_MUSHROOM | block::BROWN_MUSHROOM => {
                        self.tick_mushroom(pos, id)
                    }
                    block::SAPLING => self.tick_sapling(pos, metadata),
                    block::SAND | block::GRAVEL if !random => {
                        self.tick_falling_block(pos, id)
                    }
                    block::GRASS => {}
                    block::ICE => {}
                    block::LEAVES => {}
                    block::WOOD_PRESSURE_PLATE | block::STONE_PRESSURE_PLATE => {}
                    block::PUMPKIN | block::PUMPKIN_LIT => {}
                    block::REDSTONE_ORE_LIT => self.tick_redstone_ore_lit(pos),
                    block::SNOW => {}
                    block::SNOW_BLOCK => {}
                    block::LAVA_STILL => {}
                    block::TORCH => {}
                    _ => {}
                }
            }
            /// Tick a button block, this is used to deactivate the button after 20 ticks.
            fn tick_button(&mut self, pos: IVec3, mut metadata: u8) {
                if block::button::is_active(metadata) {
                    block::button::set_active(&mut metadata, false);
                    self.set_block_notify(pos, block::BUTTON, metadata);
                }
            }
            fn tick_repeater(&mut self, pos: IVec3, metadata: u8, lit: bool) {
                let face = block::repeater::get_face(metadata);
                let delay = block::repeater::get_delay_ticks(metadata);
                let back_powered = self.has_passive_power_from(pos - face.delta(), face);
                if lit && !back_powered {
                    self.set_block_notify(pos, block::REPEATER, metadata);
                } else if !lit {
                    if !back_powered {
                        self.schedule_block_tick(pos, block::REPEATER_LIT, delay);
                    }
                    self.set_block_notify(pos, block::REPEATER_LIT, metadata);
                }
            }
            fn tick_redstone_torch(&mut self, pos: IVec3, metadata: u8, lit: bool) {
                let Some(torch_face) = block::torch::get_face(metadata) else { return };
                let powered = self
                    .has_passive_power_from(
                        pos + torch_face.delta(),
                        torch_face.opposite(),
                    );
                if lit {
                    if powered {
                        self.set_block_notify(pos, block::REDSTONE_TORCH, metadata);
                    }
                } else {
                    if !powered {
                        self.set_block_notify(pos, block::REDSTONE_TORCH_LIT, metadata);
                    }
                }
            }
            fn tick_dispenser(&mut self, pos: IVec3, metadata: u8) {
                let Some(face) = block::dispenser::get_face(metadata) else { return };
                if !self.has_passive_power(pos) {
                    return;
                }
                let Some(BlockEntity::Dispenser(dispenser)) = self
                    .get_block_entity_mut(pos) else { return };
                if let Some(index) = dispenser.pick_random_index() {
                    let mut stack = dispenser.inv[index];
                    let dispense_stack = stack.with_size(1);
                    stack.size -= 1;
                    stack = stack.to_non_empty().unwrap_or_default();
                    dispenser.inv[index] = stack;
                    self.push_event(Event::BlockEntity {
                        pos,
                        inner: BlockEntityEvent::Storage {
                            storage: BlockEntityStorage::Standard(index as u8),
                            stack,
                        },
                    });
                    let origin_pos = pos.as_dvec3() + face.delta().as_dvec3() * 0.6
                        + 0.5;
                    if dispense_stack.id == item::ARROW {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event mc173\\src\\world\\tick.rs:147",
                                        "mc173::world::tick",
                                        ::tracing::Level::WARN,
                                        ::core::option::Option::Some("mc173\\src\\world\\tick.rs"),
                                        ::core::option::Option::Some(147u32),
                                        ::core::option::Option::Some("mc173::world::tick"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::WARN
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::WARN
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("TODO: shot arrow from dispenser")
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else if dispense_stack.id == item::EGG {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event mc173\\src\\world\\tick.rs:149",
                                        "mc173::world::tick",
                                        ::tracing::Level::WARN,
                                        ::core::option::Option::Some("mc173\\src\\world\\tick.rs"),
                                        ::core::option::Option::Some(149u32),
                                        ::core::option::Option::Some("mc173::world::tick"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::WARN
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::WARN
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("TODO: shot egg from dispenser") as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else if dispense_stack.id == item::SNOWBALL {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event mc173\\src\\world\\tick.rs:151",
                                        "mc173::world::tick",
                                        ::tracing::Level::WARN,
                                        ::core::option::Option::Some("mc173\\src\\world\\tick.rs"),
                                        ::core::option::Option::Some(151u32),
                                        ::core::option::Option::Some("mc173::world::tick"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::WARN
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::WARN
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("TODO: shot snowball from dispenser")
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        let entity = Item::new_with(|base, item| {
                            base.persistent = true;
                            base.pos = origin_pos - DVec3::Y * 0.3;
                            let rand_vel = self.rand.next_double() * 0.1 + 0.2;
                            base.vel = face.delta().as_dvec3() * rand_vel;
                            base.vel += self.rand.next_gaussian_vec() * 0.0075 * 6.0;
                            item.stack = dispense_stack;
                        });
                        self.spawn_entity(entity);
                    }
                } else {}
            }
            /// Tick a cactus.
            fn tick_cactus_or_sugar_canes(&mut self, pos: IVec3, id: u8, metadata: u8) {
                if self.is_block_air(pos + IVec3::Y) {
                    for dy in 1.. {
                        if !self.is_block(pos - IVec3::new(0, dy, 0), id) {
                            break;
                        } else if dy == 2 {
                            return;
                        }
                    }
                    if metadata == 15 {
                        self.set_block_notify(pos + IVec3::Y, id, 0);
                        self.set_block_notify(pos, id, 0);
                    } else {
                        self.set_block_notify(pos, id, metadata + 1);
                    }
                }
            }
            /// Tick a wheat crop, grow it if possible.
            fn tick_wheat(&mut self, pos: IVec3, metadata: u8) {
                if self.get_light(pos).max_real() < 9 || metadata >= 7 {
                    return;
                }
                let mut rate = 1.0;
                for x in pos.x - 1..=pos.x + 1 {
                    for z in pos.z - 1..=pos.z + 1 {
                        let below_pos = IVec3::new(x, pos.y - 1, z);
                        if let Some((below_id, below_metadata)) = self
                            .get_block(below_pos)
                        {
                            let mut below_rate = match (below_id, below_metadata) {
                                (block::FARMLAND, 0) => 1.0,
                                (block::FARMLAND, _) => 3.0,
                                _ => continue,
                            };
                            if x != pos.x || z != pos.z {
                                below_rate /= 4.0;
                            }
                            rate += below_rate;
                        }
                    }
                }
                let mut same_faces = FaceSet::new();
                let mut same_corner = false;
                for face in Face::HORIZONTAL {
                    let face_pos = pos + face.delta();
                    if match self.get_block(face_pos) {
                        Some((block::WHEAT, _)) => true,
                        _ => false,
                    } {
                        same_faces.insert(face);
                    }
                    let corner_pos = face_pos + face.rotate_right().delta();
                    if match self.get_block(corner_pos) {
                        Some((block::WHEAT, _)) => true,
                        _ => false,
                    } {
                        same_corner = true;
                        break;
                    }
                }
                if same_corner || (same_faces.contains_x() && same_faces.contains_z()) {
                    rate /= 2.0;
                }
                if self.rand.next_int_bounded((100.0 / rate) as i32) == 0 {
                    self.set_block_notify(pos, block::WHEAT, metadata + 1);
                }
            }
            /// Tick a fire and try spreading it.
            fn tick_fire(&mut self, pos: IVec3, metadata: u8) {
                let (below_block, _) = self
                    .get_block(pos - IVec3::Y)
                    .unwrap_or_default();
                let below_netherrack = below_block == block::NETHERRACK;
                let below_opaque = block::material::is_opaque_cube(below_block);
                let can_stay = self.weather == Weather::Clear || false;
                if can_stay {
                    if metadata < 15 {
                        let new_metadata = (metadata
                            + self.rand.next_int_bounded(3) as u8 / 2)
                            .min(15);
                        self.set_block(pos, block::FIRE, new_metadata);
                    }
                    self.schedule_block_tick(pos, block::FIRE, 40);
                    let catch_fire = Face::ALL
                        .into_iter()
                        .filter(|face| {
                            let (block, _) = self
                                .get_block(pos + face.delta())
                                .unwrap_or_default();
                            block::material::get_fire_flammability(block) > 0
                        })
                        .collect::<FaceSet>();
                    if !below_netherrack && !catch_fire.is_empty() {
                        if !below_opaque || metadata > 3 {
                            self.set_block_notify(pos, block::AIR, 0);
                        }
                    } else if !below_netherrack && !catch_fire.contains(Face::NegY)
                        && metadata == 15 && self.rand.next_int_bounded(4) == 0
                    {
                        self.set_block_notify(pos, block::AIR, 0);
                    } else {
                        for face in Face::ALL {
                            let face_pos = pos + face.delta();
                            let (block, _) = self
                                .get_block(face_pos)
                                .unwrap_or_default();
                            let burn = block::material::get_fire_burn(block);
                            let bound = if face.is_y() { 250 } else { 300 };
                            if self.rand.next_int_bounded(bound) < burn as i32 {
                                if self.rand.next_int_bounded(metadata as i32 + 10) < 5
                                    && !false
                                {
                                    let new_metadata = (metadata
                                        + self.rand.next_int_bounded(5) as u8 / 4)
                                        .min(15);
                                    self.set_block_notify(face_pos, block::FIRE, new_metadata);
                                } else {
                                    self.set_block_notify(face_pos, block::AIR, 0);
                                }
                            }
                        }
                        for bx in pos.x - 1..=pos.x + 1 {
                            for bz in pos.z - 1..=pos.z + 1 {
                                for by in pos.y - 1..=pos.y + 4 {
                                    let check_pos = IVec3::new(bx, by, bz);
                                    if check_pos != pos {
                                        let mut bound = 100;
                                        if check_pos.y > pos.y + 1 {
                                            bound += (check_pos.y - (pos.y + 1)) * 100;
                                        }
                                        let flammability = Face::ALL
                                            .into_iter()
                                            .map(|face| {
                                                self.get_block(check_pos + face.delta()).unwrap_or_default()
                                            })
                                            .map(|(block, _)| block::material::get_fire_flammability(
                                                block,
                                            ))
                                            .max()
                                            .unwrap_or(0);
                                        if flammability != 0 {
                                            let catch = (flammability as i32 + 40)
                                                / (metadata as i32 + 30);
                                            if catch > 0 && self.rand.next_int_bounded(bound) <= catch
                                                && self.weather == Weather::Clear
                                            {
                                                let new_metadata = (metadata
                                                    + self.rand.next_int_bounded(5) as u8 / 4)
                                                    .min(15);
                                                self.set_block_notify(check_pos, block::FIRE, new_metadata);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    self.set_block_notify(pos, block::AIR, 0);
                }
            }
            /// Tick a mushroom to try spreading it.
            fn tick_mushroom(&mut self, pos: IVec3, id: u8) {
                if self.rand.next_int_bounded(100) == 0 {
                    let spread_pos = pos
                        + IVec3 {
                            x: self.rand.next_int_bounded(3) - 1,
                            y: self.rand.next_int_bounded(2)
                                - self.rand.next_int_bounded(2),
                            z: self.rand.next_int_bounded(3) - 1,
                        };
                    if self.get_light(spread_pos).max() < 13 {
                        if self.is_block_air(spread_pos) {
                            if self.is_block_opaque_cube(spread_pos - IVec3::Y) {
                                self.set_block_notify(spread_pos, id, 0);
                            }
                        }
                    }
                }
            }
            /// Tick a sapling to grow it.
            fn tick_sapling(&mut self, pos: IVec3, mut metadata: u8) {
                if self.get_light(pos + IVec3::Y).max_real() >= 9
                    && self.rand.next_int_bounded(30) == 0
                {
                    if block::sapling::is_growing(metadata) {
                        let mut gen = match block::sapling::get_kind(metadata) {
                            TreeKind::Oak if self.rand.next_int_bounded(10) == 0 => {
                                TreeGenerator::new_big()
                            }
                            TreeKind::Oak => TreeGenerator::new_oak(),
                            TreeKind::Birch => TreeGenerator::new_birch(),
                            TreeKind::Spruce => TreeGenerator::new_spruce2(),
                        };
                        gen.generate_from_sapling(self, pos);
                    } else {
                        block::sapling::set_growing(&mut metadata, true);
                        self.set_block_notify(pos, block::SAPLING, metadata);
                    }
                }
            }
            fn tick_falling_block(&mut self, pos: IVec3, id: u8) {
                let (below_block, _) = self
                    .get_block(pos - IVec3::Y)
                    .unwrap_or_default();
                if below_block == 0 || below_block == block::FIRE
                    || block::material::is_fluid(below_block)
                {
                    self.spawn_entity(
                        FallingBlock::new_with(|base, falling_block| {
                            base.persistent = true;
                            base.pos = pos.as_dvec3() + 0.5;
                            falling_block.block_id = id;
                        }),
                    );
                    self.set_block_notify(pos, block::AIR, 0);
                }
            }
            fn tick_redstone_ore_lit(&mut self, pos: IVec3) {
                self.set_block_notify(pos, block::REDSTONE_ORE, 0);
            }
            /// Tick a moving fluid block.
            fn tick_fluid_moving(
                &mut self,
                pos: IVec3,
                flowing_id: u8,
                mut metadata: u8,
            ) {
                let still_id = flowing_id + 1;
                let material = block::material::get_material(flowing_id);
                let dist_drop = match flowing_id {
                    block::LAVA_MOVING if self.get_dimension() != Dimension::Nether => 2,
                    _ => 1,
                };
                let below_pos = pos - IVec3::Y;
                let (below_id, below_metadata) = self
                    .get_block(below_pos)
                    .unwrap_or_default();
                if !block::fluid::is_source(metadata) {
                    let mut shortest_dist = 8;
                    let mut sources_around = 0u8;
                    for face in [Face::NegX, Face::PosX, Face::NegZ, Face::PosZ] {
                        if let Some((face_id, face_metadata)) = self
                            .get_block(pos + face.delta())
                        {
                            if face_id == flowing_id || face_id == still_id {
                                let face_dist = block::fluid::get_actual_distance(
                                    face_metadata,
                                );
                                shortest_dist = shortest_dist.min(face_dist);
                                if block::fluid::is_source(face_metadata) {
                                    sources_around += 1;
                                }
                            }
                        }
                    }
                    let mut new_metadata = shortest_dist + dist_drop;
                    if new_metadata > 7 {
                        new_metadata = 0xFF;
                    }
                    if let Some((above_id, above_metadata)) = self
                        .get_block(pos + IVec3::Y)
                    {
                        if above_id == flowing_id || above_id == still_id {
                            new_metadata = above_metadata;
                            block::fluid::set_falling(&mut new_metadata, true);
                        }
                    }
                    if sources_around >= 2 && flowing_id == block::WATER_MOVING {
                        if block::material::get_material(below_id).is_solid() {
                            block::fluid::set_source(&mut new_metadata);
                        } else if below_id == flowing_id || below_id == still_id {
                            if block::fluid::is_source(below_metadata) {
                                block::fluid::set_source(&mut new_metadata);
                            }
                        }
                    }
                    if new_metadata != metadata {
                        metadata = new_metadata;
                        if new_metadata == 0xFF {
                            self.set_block_notify(pos, block::AIR, 0);
                        } else {
                            self.set_block_notify(pos, flowing_id, new_metadata);
                        }
                    } else {
                        self.set_block(pos, still_id, metadata);
                    }
                } else {
                    self.set_block(pos, still_id, metadata);
                }
                if metadata == 0xFF {
                    return;
                }
                let blocked_below = block::material::is_fluid_proof(below_id);
                if !block::material::is_fluid(below_id) && !blocked_below {
                    block::fluid::set_falling(&mut metadata, true);
                    self.set_block_notify(below_pos, flowing_id, metadata);
                } else if block::fluid::is_source(metadata) || blocked_below {
                    let flow_faces = self.calc_fluid_flow_faces(pos, material);
                    let new_dist = block::fluid::get_actual_distance(metadata)
                        + dist_drop;
                    if new_dist > 7 {
                        return;
                    }
                    for face in Face::HORIZONTAL {
                        if flow_faces.contains(face) {
                            let face_pos = pos + face.delta();
                            if let Some((face_id, _)) = self.get_block(face_pos) {
                                if !block::material::is_fluid(face_id)
                                    && !block::material::is_fluid_proof(face_id)
                                {
                                    self.break_block(face_pos);
                                    self.set_block_notify(face_pos, flowing_id, new_dist);
                                }
                            }
                        }
                    }
                }
            }
            fn calc_fluid_flow_faces(
                &mut self,
                pos: IVec3,
                material: Material,
            ) -> FaceSet {
                let mut lowest_cost = u8::MAX;
                let mut set = FaceSet::new();
                for face in Face::HORIZONTAL {
                    let face_pos = pos + face.delta();
                    let (face_block, face_metadata) = self
                        .get_block(face_pos)
                        .unwrap_or_default();
                    if !block::material::is_fluid_proof(face_block) {
                        if block::material::get_material(face_block) != material
                            || !block::fluid::is_source(face_metadata)
                        {
                            let face_below_pos = face_pos - IVec3::Y;
                            let (face_below_block, _) = self
                                .get_block(face_below_pos)
                                .unwrap_or_default();
                            let face_cost;
                            if !block::material::is_fluid_proof(face_below_block) {
                                face_cost = 0;
                            } else {
                                face_cost = self
                                    .calc_fluid_flow_cost(face_pos, material, face, 1);
                            }
                            if face_cost < lowest_cost {
                                set.clear();
                                lowest_cost = face_cost;
                            }
                            if face_cost == lowest_cost {
                                set.insert(face);
                            }
                        }
                    }
                }
                set
            }
            /// Internal function to calculate the flow cost of a fluid toward the given face. If
            /// the face is not given, all faces are checked, and the recursive calls have the
            /// face set to all four horizontal faces.
            fn calc_fluid_flow_cost(
                &mut self,
                pos: IVec3,
                material: Material,
                origin_face: Face,
                cost: u8,
            ) -> u8 {
                let mut lowest_cost = u8::MAX;
                for face in Face::HORIZONTAL {
                    if face != origin_face.opposite() {
                        let face_pos = pos + face.delta();
                        let (face_block, face_metadata) = self
                            .get_block(face_pos)
                            .unwrap_or_default();
                        if !block::material::is_fluid_proof(face_block) {
                            if block::material::get_material(face_block) != material
                                || !block::fluid::is_source(face_metadata)
                            {
                                let face_below_pos = face_pos - IVec3::Y;
                                let (face_below_block, _) = self
                                    .get_block(face_below_pos)
                                    .unwrap_or_default();
                                if !block::material::is_fluid_proof(face_below_block) {
                                    return cost;
                                }
                                if cost < 4 {
                                    lowest_cost = lowest_cost
                                        .min(
                                            self
                                                .calc_fluid_flow_cost(
                                                    face_pos,
                                                    material,
                                                    origin_face,
                                                    cost + 1,
                                                ),
                                        );
                                }
                            }
                        }
                    }
                }
                lowest_cost
            }
        }
    }
    pub mod notify {
        //! Block notification and tick methods for world.
        use std::collections::{HashMap, HashSet};
        use std::collections::hash_map::Entry;
        use glam::IVec3;
        use crate::geom::{Face, FaceSet};
        use crate::block;
        use super::{World, Event, BlockEvent};
        /// Methods related to block self and neighbor notifications.
        impl World {
            /// Notify all blocks around the position, the notification origin block id is given.
            pub fn notify_blocks_around(&mut self, pos: IVec3, origin_id: u8) {
                for face in Face::ALL {
                    self.notify_block(pos + face.delta(), origin_id);
                }
            }
            /// Notify a block a the position, the notification origin block id is given.
            pub fn notify_block(&mut self, pos: IVec3, origin_id: u8) {
                if let Some((id, metadata)) = self.get_block(pos) {
                    self.notify_block_unchecked(pos, id, metadata, origin_id);
                }
            }
            /// Notify a block a the position, the notification origin block id is given.
            pub(super) fn notify_block_unchecked(
                &mut self,
                pos: IVec3,
                id: u8,
                metadata: u8,
                origin_id: u8,
            ) {
                match id {
                    block::REDSTONE if origin_id != block::REDSTONE => {
                        self.notify_redstone(pos)
                    }
                    block::REPEATER | block::REPEATER_LIT => {
                        self.notify_repeater(pos, id, metadata)
                    }
                    block::REDSTONE_TORCH | block::REDSTONE_TORCH_LIT => {
                        self.notify_redstone_torch(pos, id)
                    }
                    block::DISPENSER => self.notify_dispenser(pos, origin_id),
                    block::WATER_MOVING | block::LAVA_MOVING => {
                        self.notify_fluid(pos, id, metadata)
                    }
                    block::WATER_STILL | block::LAVA_STILL => {
                        self.notify_fluid_still(pos, id, metadata)
                    }
                    block::TRAPDOOR => self.notify_trapdoor(pos, metadata, origin_id),
                    block::WOOD_DOOR | block::IRON_DOOR => {
                        self.notify_door(pos, id, metadata, origin_id)
                    }
                    block::DANDELION
                    | block::POPPY
                    | block::SAPLING
                    | block::TALL_GRASS => {
                        self.notify_flower(
                            pos,
                            &[block::GRASS, block::DIRT, block::FARMLAND],
                        )
                    }
                    block::DEAD_BUSH => self.notify_flower(pos, &[block::SAND]),
                    block::WHEAT => self.notify_flower(pos, &[block::FARMLAND]),
                    block::RED_MUSHROOM | block::BROWN_MUSHROOM => {
                        self.notify_mushroom(pos)
                    }
                    block::CACTUS => self.notify_cactus(pos),
                    block::SAND | block::GRAVEL => self.schedule_block_tick(pos, id, 3),
                    _ => {}
                }
            }
            pub(super) fn notify_change_unchecked(
                &mut self,
                pos: IVec3,
                from_id: u8,
                from_metadata: u8,
                to_id: u8,
                to_metadata: u8,
            ) {
                match from_id {
                    block::BUTTON => {
                        if let Some(face) = block::button::get_face(to_metadata) {
                            self.notify_blocks_around(pos + face.delta(), block::BUTTON);
                        }
                    }
                    block::LEVER => {
                        if let Some((face, _)) = block::lever::get_face(to_metadata) {
                            self.notify_blocks_around(pos + face.delta(), block::LEVER);
                        }
                    }
                    block::CHEST if to_id != block::CHEST => {
                        self.remove_block_entity(pos);
                    }
                    block::DISPENSER if to_id != block::DISPENSER => {
                        self.remove_block_entity(pos);
                    }
                    block::FURNACE
                    | block::FURNACE_LIT if to_id != block::FURNACE_LIT
                        && to_id != block::FURNACE => {
                        self.remove_block_entity(pos);
                    }
                    block::SPAWNER if to_id != block::SPAWNER => {
                        self.remove_block_entity(pos);
                    }
                    block::NOTE_BLOCK if to_id != block::NOTE_BLOCK => {
                        self.remove_block_entity(pos);
                    }
                    block::JUKEBOX if to_id != block::JUKEBOX => {
                        self.remove_block_entity(pos);
                    }
                    _ => {}
                }
                match to_id {
                    block::WATER_MOVING => self.schedule_block_tick(pos, to_id, 5),
                    block::LAVA_MOVING => self.schedule_block_tick(pos, to_id, 30),
                    block::REDSTONE => self.notify_redstone(pos),
                    block::REPEATER | block::REPEATER_LIT => {
                        self.notify_repeater(pos, to_id, from_metadata)
                    }
                    block::REDSTONE_TORCH | block::REDSTONE_TORCH_LIT => {
                        self.notify_redstone_torch(pos, to_id)
                    }
                    block::SAND | block::GRAVEL => {
                        self.schedule_block_tick(pos, to_id, 3)
                    }
                    block::CACTUS => self.notify_cactus(pos),
                    block::FIRE => self.schedule_block_tick(pos, to_id, 40),
                    _ => {}
                }
            }
            /// Notification of a moving fluid block.
            fn notify_fluid(&mut self, pos: IVec3, id: u8, metadata: u8) {
                if id == block::LAVA_MOVING {
                    let distance = block::fluid::get_distance(metadata);
                    for face in Face::HORIZONTAL {
                        if let Some((block::WATER_MOVING | block::WATER_STILL, _)) = self
                            .get_block(pos + face.delta())
                        {
                            if distance == 0 {
                                self.set_block_notify(pos, block::OBSIDIAN, 0);
                            } else if distance <= 4 {
                                self.set_block_notify(pos, block::COBBLESTONE, 0);
                            }
                        }
                    }
                }
            }
            /// Notification of a still fluid block.
            fn notify_fluid_still(&mut self, pos: IVec3, id: u8, metadata: u8) {
                let moving_id = id - 1;
                self.notify_fluid(pos, moving_id, metadata);
                self.set_block_self_notify(pos, moving_id, metadata);
            }
            /// Notification of standard flower subclasses.
            fn notify_flower(&mut self, pos: IVec3, stay_blocks: &[u8]) {
                if self.get_light(pos).max() >= 8 || false {
                    let (below_id, _) = self.get_block(pos - IVec3::Y).unwrap_or((0, 0));
                    if stay_blocks.iter().any(|&id| id == below_id) {
                        return;
                    }
                }
                self.break_block(pos);
            }
            /// Notification of a mushroom block.
            fn notify_mushroom(&mut self, pos: IVec3) {
                if self.get_light(pos).max() >= 13
                    || !self.is_block_opaque_cube(pos - IVec3::Y)
                {
                    self.break_block(pos);
                }
            }
            /// Notification of a cactus block. The block is broken if
            fn notify_cactus(&mut self, pos: IVec3) {
                for face in Face::HORIZONTAL {
                    if self.is_block_solid(pos + face.delta()) {
                        self.break_block(pos);
                        return;
                    }
                }
                if !match self.get_block(pos - IVec3::Y) {
                    Some((block::CACTUS | block::SAND, _)) => true,
                    _ => false,
                } {
                    self.break_block(pos);
                }
            }
            /// Notification of a redstone repeater block.
            fn notify_repeater(&mut self, pos: IVec3, id: u8, metadata: u8) {
                let lit = id == block::REPEATER_LIT;
                let face = block::repeater::get_face(metadata);
                let delay = block::repeater::get_delay_ticks(metadata);
                let back_powered = self.has_passive_power_from(pos - face.delta(), face);
                if lit != back_powered {
                    self.schedule_block_tick(pos, id, delay);
                }
            }
            /// Notification of a redstone repeater block.
            fn notify_redstone_torch(&mut self, pos: IVec3, id: u8) {
                self.schedule_block_tick(pos, id, 2);
            }
            fn notify_dispenser(&mut self, pos: IVec3, origin_id: u8) {
                if is_redstone_block(origin_id) {
                    if self.has_passive_power(pos) {
                        self.schedule_block_tick(pos, block::DISPENSER, 4);
                    }
                }
            }
            /// Notification of a trapdoor, breaking it if no longer on its wall, or updating its
            /// state depending on redstone signal.
            fn notify_trapdoor(&mut self, pos: IVec3, mut metadata: u8, origin_id: u8) {
                let face = block::trapdoor::get_face(metadata);
                if !self.is_block_opaque_cube(pos + face.delta()) {
                    self.break_block(pos);
                } else {
                    let open = block::trapdoor::is_open(metadata);
                    if is_redstone_block(origin_id) {
                        let powered = self.has_passive_power(pos);
                        if open != powered {
                            block::trapdoor::set_open(&mut metadata, powered);
                            self.set_block_notify(pos, block::TRAPDOOR, metadata);
                            self.push_event(Event::Block {
                                pos,
                                inner: BlockEvent::Sound {
                                    id: block::TRAPDOOR,
                                    metadata,
                                },
                            });
                        }
                    }
                }
            }
            fn notify_door(
                &mut self,
                pos: IVec3,
                id: u8,
                mut metadata: u8,
                origin_id: u8,
            ) {
                if block::door::is_upper(metadata) {
                    if let Some((below_id, below_metadata)) = self
                        .get_block(pos - IVec3::Y)
                    {
                        if below_id == id {
                            self.notify_door(
                                pos - IVec3::Y,
                                below_id,
                                below_metadata,
                                origin_id,
                            );
                            return;
                        }
                    }
                    self.set_block_notify(pos, block::AIR, 0);
                } else {
                    if let Some((above_id, _)) = self.get_block(pos + IVec3::Y) {
                        if above_id != id {
                            self.break_block(pos);
                            return;
                        }
                    }
                    if !self.is_block_opaque_cube(pos - IVec3::Y) {
                        self.break_block(pos);
                        return;
                    }
                    if is_redstone_block(origin_id) {
                        let mut powered = self
                            .has_passive_power_from(pos - IVec3::Y, Face::PosY)
                            || self
                                .has_passive_power_from(pos + IVec3::Y * 2, Face::NegY);
                        if !powered {
                            for face in Face::ALL {
                                let face_pos = pos + face.delta();
                                powered = self
                                    .has_passive_power_from(face_pos, face.opposite())
                                    || self
                                        .has_passive_power_from(
                                            face_pos + IVec3::Y,
                                            face.opposite(),
                                        );
                                if powered {
                                    break;
                                }
                            }
                        }
                        if block::door::is_open(metadata) != powered {
                            block::door::set_open(&mut metadata, powered);
                            self.set_block_self_notify(pos, id, metadata);
                            block::door::set_upper(&mut metadata, true);
                            self.set_block_self_notify(pos + IVec3::Y, id, metadata);
                            self.notify_block(pos - IVec3::Y, id);
                            self.notify_block(pos + IVec3::Y * 2, id);
                            for face in Face::ALL {
                                self.notify_block(pos + face.delta(), id);
                                self.notify_block(pos + face.delta() + IVec3::Y, id);
                            }
                            self.push_event(Event::Block {
                                pos,
                                inner: BlockEvent::Sound { id, metadata },
                            });
                        }
                    }
                }
            }
            /// Notify a redstone dust block. This function is a bit special because this
            /// notification in itself will trigger other notifications for all updated blocks.
            /// The redstone update in the
            fn notify_redstone(&mut self, pos: IVec3) {
                const FACES: [Face; 4] = [
                    Face::NegX,
                    Face::PosX,
                    Face::NegZ,
                    Face::PosZ,
                ];
                /// Internal structure to keep track of the power and links of a single redstone.
                struct Node {
                    /// The current power of this node.
                    power: u8,
                    /// This bit fields contains, for each face of the redstone node, if it's linked
                    /// to another redstone, that may be on top or bottom or the faced block. So this
                    /// is not an exact indication but rather a hint.
                    links: FaceSet,
                    /// True when there is an opaque block above the node, so it could spread above.
                    opaque_above: bool,
                    /// True when there is an opaque block below the node, so it could spread below.
                    opaque_below: bool,
                }
                #[automatically_derived]
                impl ::core::default::Default for Node {
                    #[inline]
                    fn default() -> Node {
                        Node {
                            power: ::core::default::Default::default(),
                            links: ::core::default::Default::default(),
                            opaque_above: ::core::default::Default::default(),
                            opaque_below: ::core::default::Default::default(),
                        }
                    }
                }
                let mut nodes: HashMap<IVec3, Node> = HashMap::new();
                let mut pending: Vec<(IVec3, Face)> = <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([(pos, Face::NegY)]),
                );
                let mut sources: Vec<IVec3> = Vec::new();
                while let Some((pending_pos, link_face)) = pending.pop() {
                    let node = match nodes.entry(pending_pos) {
                        Entry::Occupied(o) => {
                            o.into_mut().links.insert(link_face);
                            continue;
                        }
                        Entry::Vacant(v) => v.insert(Node::default()),
                    };
                    node.links.insert(link_face);
                    node
                        .opaque_above = self
                        .get_block(pos + IVec3::Y)
                        .map(|(above_id, _)| block::material::is_opaque_cube(above_id))
                        .unwrap_or(true);
                    node
                        .opaque_below = self
                        .get_block(pos - IVec3::Y)
                        .map(|(below_id, _)| block::material::is_opaque_cube(below_id))
                        .unwrap_or(true);
                    for face in FACES {
                        if link_face == face {
                            continue;
                        }
                        let face_pos = pending_pos + face.delta();
                        if let Some((id, _)) = self.get_block(face_pos) {
                            if id == block::REDSTONE {
                                node.links.insert(face);
                                pending.push((face_pos, face.opposite()));
                                continue;
                            }
                            let face_power = self
                                .get_active_power_from(face_pos, face.opposite());
                            node.power = node.power.max(face_power);
                            if block::material::get_material(id).is_opaque() {
                                if !node.opaque_above {
                                    let face_above_pos = face_pos + IVec3::Y;
                                    if let Some((block::REDSTONE, _)) = self
                                        .get_block(face_above_pos)
                                    {
                                        node.links.insert(face);
                                        pending.push((face_above_pos, face.opposite()));
                                    }
                                }
                            } else {
                                let face_below_pos = face_pos - IVec3::Y;
                                if let Some((block::REDSTONE, _)) = self
                                    .get_block(face_below_pos)
                                {
                                    node.links.insert(face);
                                    pending.push((face_below_pos, face.opposite()));
                                }
                            }
                        }
                    }
                    for face in [Face::NegY, Face::PosY] {
                        let face_pos = pending_pos + face.delta();
                        let face_power = self
                            .get_active_power_from(face_pos, face.opposite());
                        node.power = node.power.max(face_power);
                    }
                    if node.power > 0 {
                        sources.push(pending_pos);
                    }
                }
                drop(pending);
                let mut next_sources_index = 0;
                let mut changed_nodes = Vec::new();
                while next_sources_index < sources.len() {
                    let start_index = next_sources_index;
                    let end_index = sources.len();
                    next_sources_index = end_index;
                    for source_index in start_index..end_index {
                        let node_pos = sources[source_index];
                        let Some(node) = nodes.remove(&node_pos) else { continue };
                        if self.set_block(node_pos, block::REDSTONE, node.power)
                            != Some((block::REDSTONE, node.power))
                        {
                            changed_nodes.push(node_pos);
                        }
                        if node.power <= 1 {
                            continue;
                        }
                        let propagated_power = node.power - 1;
                        for face in FACES {
                            if node.links.contains(face) {
                                let face_pos = node_pos + face.delta();
                                if let Some(face_node) = nodes.get_mut(&face_pos) {
                                    face_node.power = face_node.power.max(propagated_power);
                                    sources.push(face_pos);
                                }
                                if !node.opaque_above {
                                    let face_above_pos = face_pos + IVec3::Y;
                                    if let Some(face_above_node) = nodes
                                        .get_mut(&face_above_pos)
                                    {
                                        face_above_node
                                            .power = face_above_node.power.max(propagated_power);
                                        sources.push(face_above_pos);
                                    }
                                }
                                if node.opaque_below {
                                    let face_below_pos = face_pos - IVec3::Y;
                                    if let Some(face_below_node) = nodes
                                        .get_mut(&face_below_pos)
                                    {
                                        face_below_node
                                            .power = face_below_node.power.max(propagated_power);
                                        sources.push(face_below_pos);
                                    }
                                }
                            }
                        }
                    }
                }
                for node_pos in nodes.into_keys() {
                    if self.set_block(node_pos, block::REDSTONE, 0)
                        != Some((block::REDSTONE, 0))
                    {
                        changed_nodes.push(node_pos);
                    }
                }
                let mut notified = HashSet::new();
                let mut inner_notify_at = move |pos: IVec3| {
                    if notified.insert(pos) {
                        self.notify_block(pos, block::REDSTONE);
                    }
                };
                for node_pos in changed_nodes {
                    inner_notify_at(node_pos + IVec3::Y);
                    inner_notify_at(node_pos - IVec3::Y);
                    inner_notify_at(node_pos + IVec3::Y * 2);
                    inner_notify_at(node_pos - IVec3::Y * 2);
                    for face in FACES {
                        let face_pos = node_pos + face.delta();
                        inner_notify_at(face_pos);
                        inner_notify_at(face_pos + face.delta());
                        inner_notify_at(face_pos + IVec3::Y);
                        inner_notify_at(face_pos - IVec3::Y);
                        inner_notify_at(face_pos + face.rotate_right().delta());
                    }
                }
            }
        }
        fn is_redstone_block(id: u8) -> bool {
            match id {
                block::BUTTON
                | block::DETECTOR_RAIL
                | block::LEVER
                | block::WOOD_PRESSURE_PLATE
                | block::STONE_PRESSURE_PLATE
                | block::REPEATER
                | block::REPEATER_LIT
                | block::REDSTONE_TORCH
                | block::REDSTONE_TORCH_LIT
                | block::REDSTONE => true,
                _ => false,
            }
        }
    }
    pub mod explode {
        //! Make explosion in world.
        use glam::{DVec3, IVec3};
        use tracing::trace;
        use crate::geom::BoundingBox;
        use crate::rand::JavaRandom;
        use crate::world::bound::RayTraceKind;
        use crate::entity::{Entity, Hurt};
        use crate::world::Event;
        use crate::block;
        use super::World;
        /// Methods related to explosions.
        impl World {
            /// Make an explosion in the world at the given position and size. The explosion can
            /// optionally propagate flames around.
            pub fn explode(
                &mut self,
                center: DVec3,
                radius: f32,
                set_fire: bool,
                origin_id: Option<u32>,
            ) {
                /// This is the step to advance each explosion ray.
                const STEP: f32 = 0.3;
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event mc173\\src\\world\\explode.rs:28",
                                "mc173::world::explode",
                                ::tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "mc173\\src\\world\\explode.rs",
                                ),
                                ::core::option::Option::Some(28u32),
                                ::core::option::Option::Some("mc173::world::explode"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &format_args!(
                                                    "explode, center: {0}, radius: {1}, set fire: {2}, origin id: {3:?}",
                                                    center,
                                                    radius,
                                                    set_fire,
                                                    origin_id,
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let mut rand = JavaRandom::new_seeded();
                let mut affected_pos = Vec::new();
                for dx in 0..16 {
                    for dy in 0..16 {
                        for dz in 0..16 {
                            if dx == 0 || dx == 15 || dy == 0 || dy == 15 || dz == 0
                                || dz == 15
                            {
                                let dir = (IVec3::new(dx, dy, dz).as_vec3() / 15.0) * 2.0
                                    - 1.0;
                                let dir = dir.normalize() * STEP;
                                let dir = dir.as_dvec3();
                                let mut intensity = radius
                                    * (0.7 + self.rand.next_float() * 0.6);
                                let mut check_pos = center;
                                while intensity > 0.0 {
                                    let block_pos = check_pos.floor().as_ivec3();
                                    let Some((block, _)) = self.get_block(block_pos) else {
                                        break
                                    };
                                    intensity
                                        -= (block::material::get_explosion_resistance(block) + 0.3)
                                            * STEP;
                                    if intensity > 0.0 {
                                        if set_fire && block == block::AIR
                                            && self.is_block_opaque_cube(block_pos - IVec3::Y)
                                            && rand.next_int_bounded(3) == 0
                                        {
                                            self.set_block_notify(block_pos, block::FIRE, 0);
                                        }
                                        affected_pos.push((block_pos, block != block::AIR));
                                    }
                                    check_pos += dir;
                                    intensity -= (12.0 / 16.0) * STEP;
                                }
                            }
                        }
                    }
                }
                let diameter = (radius * 2.0) as f64;
                let bb = BoundingBox {
                    min: (center - diameter - 1.0).floor(),
                    max: (center + diameter + 1.0).floor(),
                };
                let mut damaged_entities = Vec::new();
                for (collided_id, Entity(collided_base, _)) in self
                    .iter_entities_colliding(bb)
                {
                    let delta = collided_base.pos - center;
                    let dist = delta.length();
                    let dist_norm = dist as f32 / radius;
                    if dist_norm <= 1.0 {
                        let dir = delta / dist;
                        let ray = collided_base.bb.min - center;
                        let step = 1.0 / (collided_base.bb.size() * 2.0 + 1.0);
                        let mut ray_offset = DVec3::ZERO;
                        let mut ray_pass = 0usize;
                        let mut ray_count = 0usize;
                        while ray_offset.x <= 1.0 {
                            ray_offset.y = 0.0;
                            while ray_offset.y <= 1.0 {
                                ray_offset.z = 0.0;
                                while ray_offset.z <= 1.0 {
                                    ray_pass
                                        += self
                                            .ray_trace_blocks(
                                                center,
                                                ray + ray_offset,
                                                RayTraceKind::Overlay,
                                            )
                                            .is_none() as usize;
                                    ray_count += 1;
                                    ray_offset.z += step.z;
                                }
                                ray_offset.y += step.y;
                            }
                            ray_offset.x += step.x;
                        }
                        let damage_factor = (1.0 - dist_norm)
                            * (ray_pass as f32 / ray_count as f32);
                        let damage = (damage_factor * damage_factor + damage_factor)
                            / 2.0 * 8.0 * radius + 1.0;
                        let damage = damage as u16;
                        damaged_entities
                            .push((collided_id, damage, dir * damage_factor as f64));
                    }
                }
                for (eid, damage, accel) in damaged_entities {
                    let Entity(base, _) = self.get_entity_mut(eid).unwrap();
                    base.hurt.push(Hurt { damage, origin_id });
                    base.vel += accel;
                }
                for (pos, should_destroy) in affected_pos {
                    if should_destroy {
                        let (prev_block, prev_metadata) = self
                            .set_block_notify(pos, block::AIR, 0)
                            .unwrap();
                        self.spawn_block_loot(pos, prev_block, prev_metadata, 0.3);
                    }
                }
                self.push_event(Event::Explode { center, radius });
            }
        }
    }
    /// This thread local vector is used temporally to stores the random ticks to be
    /// executed. This is mandatory since ticking a block requires full mutable access to
    /// the world, but it's not possible while owning a reference to a chunk.
    const RANDOM_TICKS_PENDING: ::std::thread::LocalKey<Cell<Vec<(IVec3, u8, u8)>>> = {
        #[inline]
        #[deny(unsafe_op_in_unsafe_fn)]
        unsafe fn __getit(
            _init: ::std::option::Option<
                &mut ::std::option::Option<Cell<Vec<(IVec3, u8, u8)>>>,
            >,
        ) -> ::std::option::Option<&'static Cell<Vec<(IVec3, u8, u8)>>> {
            const INIT_EXPR: Cell<Vec<(IVec3, u8, u8)>> = Cell::new(Vec::new());
            #[thread_local]
            static mut VAL: Cell<Vec<(IVec3, u8, u8)>> = INIT_EXPR;
            if !::std::mem::needs_drop::<Cell<Vec<(IVec3, u8, u8)>>>() {
                unsafe { return ::std::option::Option::Some(&VAL) }
            }
            #[thread_local]
            static STATE: ::std::cell::Cell<::std::primitive::u8> = ::std::cell::Cell::new(
                0,
            );
            unsafe extern "C" fn destroy(ptr: *mut ::std::primitive::u8) {
                ::std::thread::local_impl::abort_on_dtor_unwind(|| {
                    let old_state = STATE.replace(2);
                    if true {
                        match (&old_state, &1) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::None,
                                    );
                                }
                            }
                        };
                    }
                    unsafe {
                        ::std::ptr::drop_in_place(
                            ptr.cast::<Cell<Vec<(IVec3, u8, u8)>>>(),
                        );
                    }
                });
            }
            unsafe {
                match STATE.get() {
                    0 => {
                        ::std::thread::local_impl::Key::<
                            Cell<Vec<(IVec3, u8, u8)>>,
                        >::register_dtor(
                            &raw mut VAL as *mut ::std::primitive::u8,
                            destroy,
                        );
                        STATE.set(1);
                        ::std::option::Option::Some(&VAL)
                    }
                    1 => ::std::option::Option::Some(&VAL),
                    _ => ::std::option::Option::None,
                }
            }
        }
        unsafe { ::std::thread::LocalKey::new(__getit) }
    };
    /// A temporary list of loaded chunks positions.
    const LOADED_CHUNKS: ::std::thread::LocalKey<Cell<Vec<(i32, i32)>>> = {
        #[inline]
        #[deny(unsafe_op_in_unsafe_fn)]
        unsafe fn __getit(
            _init: ::std::option::Option<
                &mut ::std::option::Option<Cell<Vec<(i32, i32)>>>,
            >,
        ) -> ::std::option::Option<&'static Cell<Vec<(i32, i32)>>> {
            const INIT_EXPR: Cell<Vec<(i32, i32)>> = Cell::new(Vec::new());
            #[thread_local]
            static mut VAL: Cell<Vec<(i32, i32)>> = INIT_EXPR;
            if !::std::mem::needs_drop::<Cell<Vec<(i32, i32)>>>() {
                unsafe { return ::std::option::Option::Some(&VAL) }
            }
            #[thread_local]
            static STATE: ::std::cell::Cell<::std::primitive::u8> = ::std::cell::Cell::new(
                0,
            );
            unsafe extern "C" fn destroy(ptr: *mut ::std::primitive::u8) {
                ::std::thread::local_impl::abort_on_dtor_unwind(|| {
                    let old_state = STATE.replace(2);
                    if true {
                        match (&old_state, &1) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::None,
                                    );
                                }
                            }
                        };
                    }
                    unsafe {
                        ::std::ptr::drop_in_place(ptr.cast::<Cell<Vec<(i32, i32)>>>());
                    }
                });
            }
            unsafe {
                match STATE.get() {
                    0 => {
                        ::std::thread::local_impl::Key::<
                            Cell<Vec<(i32, i32)>>,
                        >::register_dtor(
                            &raw mut VAL as *mut ::std::primitive::u8,
                            destroy,
                        );
                        STATE.set(1);
                        ::std::option::Option::Some(&VAL)
                    }
                    1 => ::std::option::Option::Some(&VAL),
                    _ => ::std::option::Option::None,
                }
            }
        }
        unsafe { ::std::thread::LocalKey::new(__getit) }
    };
    /// A data-structure that fully describes a Minecraft beta 1.7.3 world, with all its
    /// blocks, lights, biomes, entities and block entities. It also keep the current state
    /// of the world such as time and weather and allows ticking it step by step.
    ///
    /// # Components
    ///
    /// This data structure stores different kind of component:
    /// - Chunks, these are the storage for block, light and height map of a 16x16 column in
    ///   the world with a height of 128. This component has the largest memory footprint
    ///   overall and is stored in shared reference to avoid too much memory copy.
    ///   A chunk must be present in order to set block in the world.
    /// - Entities, basically anything that needs to be ticked with 3 dimensional coordinates.
    ///   They can control their own position, velocity and look for example.
    /// - Block Entities, this is a mix between entities and blocks, they can be ticked but
    ///   are attached to a block position that they cannot control.
    ///
    /// These components are independent, but are internally optimized for access. For example
    /// entities are not directly linked to a chunk, but an iterator over entities within a
    /// chunk can be obtained.
    ///
    /// This data structure is however not designed to handle automatic chunk loading and
    /// saving, every chunk needs to be manually inserted and removed, same for entities and
    /// block entities.
    ///
    /// # Logic
    ///
    /// This data structure is also optimized for actually running the world's logic if
    /// needed. Such as weather, random block ticking, scheduled block ticking, entity
    /// ticking or block notifications.
    ///
    /// # Events
    ///
    /// This structure also allows listening for events within it through a queue of
    /// [`Event`], events listening is disabled by default but can be enabled by swapping
    /// a `Vec<Event>` into the world using the [`swap_events`](Self::swap_events). Events
    /// are generated either by world's ticking logic or by manual changes to the world.
    /// Events are ordered chronologically, for example and entity cannot be removed before
    /// being spawned.
    ///
    /// # Naming convention
    ///
    /// Methods provided on this structure should follow a naming convention depending on the
    /// action that will apply to the world:
    /// - Methods that don't alter the world and return values should be prefixed by `get_`,
    ///   these are getters and should not usually compute too much, getters that returns
    ///   mutable reference should be suffixed with `_mut`;
    /// - Getter methods that return booleans should prefer `can_`, `has_` or `is_` prefixes;
    /// - Methods that alter the world by running a logic tick should start with `tick_`;
    /// - Methods that iterate over some world objects should start with `iter_`, the return
    ///   iterator type should preferably be a new type (not `impl Iterator`);
    /// - Methods that run on internal events can be prefixed by `handle_`;
    /// - All other methods should use a proper verb, preferably composed of one-word to
    ///   reduce possible meanings (e.g. are `schedule_`, `break_`, `spawn_`, `insert_` or
    ///   `remove_`).
    ///
    /// Various suffixes can be added to methods, depending on the world area affected by the
    /// method, for example `_in`, `_in_chunk`, `_in_box` or `_colliding`.
    /// Any mutation prefix `_mut` should be placed at the very end.
    ///
    /// # Roadmap
    ///
    /// - Make a diagram to better explain the world structure with entity caching.
    pub struct World {
        /// When enabled, this contains the list of events that happened in the world since
        /// it was last swapped. This swap behavior is really useful in order to avoid
        /// borrowing issues, by temporarily taking ownership of events, the caller can get
        /// a mutable reference to that world at the same time.
        events: Option<Vec<Event>>,
        /// The dimension
        dimension: Dimension,
        /// The world time, increasing on each tick. This is used for day/night cycle but
        /// also for registering scheduled ticks.
        time: u64,
        /// The world's global random number generator, it is used everywhere to randomize
        /// events in the world, such as plant grow.
        rand: JavaRandom,
        /// The mapping of world chunks, with optional world components linked to them, such
        /// as chunk data, entities and block entities. Every world component must be linked
        /// to a world chunk.
        chunks: HashMap<(i32, i32), ChunkComponent>,
        /// Total entities count spawned since the world is running. Also used to give
        /// entities a unique id.
        entities_count: u32,
        /// The internal list of all loaded entities.
        entities: TickVec<EntityComponent>,
        /// Entities' index mapping from their unique id.
        entities_id_map: HashMap<u32, usize>,
        /// This index map contains a mapping for every player entity.
        entities_player_map: IndexMap<u32, usize>,
        /// Same as entities but for block entities.
        block_entities: TickVec<BlockEntityComponent>,
        /// Mapping of block entities to they block position.
        block_entities_pos_map: HashMap<IVec3, usize>,
        /// Total scheduled ticks count since the world is running.
        block_ticks_count: u64,
        /// Mapping of scheduled ticks in the future.
        block_ticks: BTreeSet<BlockTick>,
        /// A set of all scheduled tick states, used to avoid ticking twice the same position
        /// and block id.
        block_ticks_states: HashSet<BlockTickState>,
        /// Queue of pending light updates to be processed.
        light_updates: VecDeque<LightUpdate>,
        /// This is the wrapping seed used by random ticks to compute random block positions.
        random_ticks_seed: i32,
        /// The current weather in that world, note that the Notchian server do not work like
        /// this, but rather store two independent state for rain and thunder, but we simplify
        /// the logic in this implementation since it is not strictly needed to be on parity.
        weather: Weather,
        /// Next time when the weather should be recomputed.
        weather_next_time: u64,
        /// The current sky light level, depending on the current time. This value is used
        /// when subtracted from a chunk sky light level.
        sky_light_subtracted: u8,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for World {
        #[inline]
        fn clone(&self) -> World {
            World {
                events: ::core::clone::Clone::clone(&self.events),
                dimension: ::core::clone::Clone::clone(&self.dimension),
                time: ::core::clone::Clone::clone(&self.time),
                rand: ::core::clone::Clone::clone(&self.rand),
                chunks: ::core::clone::Clone::clone(&self.chunks),
                entities_count: ::core::clone::Clone::clone(&self.entities_count),
                entities: ::core::clone::Clone::clone(&self.entities),
                entities_id_map: ::core::clone::Clone::clone(&self.entities_id_map),
                entities_player_map: ::core::clone::Clone::clone(
                    &self.entities_player_map,
                ),
                block_entities: ::core::clone::Clone::clone(&self.block_entities),
                block_entities_pos_map: ::core::clone::Clone::clone(
                    &self.block_entities_pos_map,
                ),
                block_ticks_count: ::core::clone::Clone::clone(&self.block_ticks_count),
                block_ticks: ::core::clone::Clone::clone(&self.block_ticks),
                block_ticks_states: ::core::clone::Clone::clone(
                    &self.block_ticks_states,
                ),
                light_updates: ::core::clone::Clone::clone(&self.light_updates),
                random_ticks_seed: ::core::clone::Clone::clone(&self.random_ticks_seed),
                weather: ::core::clone::Clone::clone(&self.weather),
                weather_next_time: ::core::clone::Clone::clone(&self.weather_next_time),
                sky_light_subtracted: ::core::clone::Clone::clone(
                    &self.sky_light_subtracted,
                ),
            }
        }
    }
    /// Core methods for worlds.
    impl World {
        /// Create a new world of the given dimension with no events queue by default, so
        /// events are disabled.
        pub fn new(dimension: Dimension) -> Self {
            Self {
                events: None,
                dimension,
                time: 0,
                rand: JavaRandom::new_seeded(),
                chunks: HashMap::new(),
                entities_count: 0,
                entities: TickVec::new(),
                entities_id_map: HashMap::new(),
                entities_player_map: IndexMap::new(),
                block_entities: TickVec::new(),
                block_entities_pos_map: HashMap::new(),
                block_ticks_count: 0,
                block_ticks: BTreeSet::new(),
                block_ticks_states: HashSet::new(),
                light_updates: VecDeque::new(),
                random_ticks_seed: JavaRandom::new_seeded().next_int(),
                weather: Weather::Clear,
                weather_next_time: 0,
                sky_light_subtracted: 0,
            }
        }
        /// This function can be used to swap in a new events queue and return the previous
        /// one if relevant. Giving *None* events queue disable events registration using
        /// the [`push_event`] method. Swapping out the events is the only way of reading
        /// them afterward without borrowing the world.
        ///
        /// [`push_event`]: Self::push_event
        pub fn swap_events(&mut self, events: Option<Vec<Event>>) -> Option<Vec<Event>> {
            mem::replace(&mut self.events, events)
        }
        /// Return true if this world has an internal events queue that enables usage of the
        /// [`push_event`] method.
        ///
        /// [`push_event`]: Self::push_event
        pub fn has_events(&self) -> bool {
            self.events.is_some()
        }
        /// Push an event in this world. This only actually push the event if events are
        /// enabled. Events queue can be swapped using [`swap_events`](Self::swap_events)
        /// method.
        #[inline]
        pub fn push_event(&mut self, event: Event) {
            if let Some(events) = &mut self.events {
                events.push(event);
            }
        }
        /// Get the dimension of this world, this is basically only for sky color on client
        /// and also for celestial angle on the server side for sky light calculation. This
        /// has not direct relation with the actual world generation that is providing this
        /// world with chunks and entities.
        pub fn get_dimension(&self) -> Dimension {
            self.dimension
        }
        /// Get the world time, in ticks.
        pub fn get_time(&self) -> u64 {
            self.time
        }
        /// Get a mutable access to this world's random number generator.
        pub fn get_rand_mut(&mut self) -> &mut JavaRandom {
            &mut self.rand
        }
        /// Get the current weather in the world.
        pub fn get_weather(&self) -> Weather {
            self.weather
        }
        /// Set the current weather in this world. If the weather has changed an event will
        /// be pushed into the events queue.
        pub fn set_weather(&mut self, weather: Weather) {
            if self.weather != weather {
                self.push_event(Event::Weather {
                    prev: self.weather,
                    new: weather,
                });
                self.weather = weather;
            }
        }
        /// Insert a chunk snapshot into this world at its position with all entities and
        /// block entities attached to it.
        pub fn insert_chunk_snapshot(&mut self, snapshot: ChunkSnapshot) {
            self.set_chunk(snapshot.cx, snapshot.cz, snapshot.chunk);
            for entity in snapshot.entities {
                if true {
                    match (
                        &calc_entity_chunk_pos(entity.0.pos),
                        &(snapshot.cx, snapshot.cz),
                    ) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::Some(
                                        format_args!("incoherent entity in chunk snapshot"),
                                    ),
                                );
                            }
                        }
                    };
                }
                self.spawn_entity_inner(entity);
            }
            for (pos, block_entity) in snapshot.block_entities {
                if true {
                    match (&calc_chunk_pos_unchecked(pos), &(snapshot.cx, snapshot.cz)) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::Some(
                                        format_args!("incoherent block entity in chunk snapshot"),
                                    ),
                                );
                            }
                        }
                    };
                }
                self.set_block_entity_inner(pos, block_entity);
            }
        }
        /// Create a snapshot of a chunk's content, this only works if chunk data is existing.
        /// This operation can be costly depending on the number of entities in the chunk, but
        /// is free regarding the block and light data because it use shared reference.
        pub fn take_chunk_snapshot(&self, cx: i32, cz: i32) -> Option<ChunkSnapshot> {
            let chunk_comp = self.chunks.get(&(cx, cz))?;
            let chunk = chunk_comp.data.as_ref()?;
            Some(ChunkSnapshot {
                cx,
                cz,
                chunk: Arc::clone(&chunk),
                entities: chunk_comp
                    .entities
                    .values()
                    .filter_map(|&index| self.entities.get(index).unwrap().inner.clone())
                    .collect(),
                block_entities: chunk_comp
                    .block_entities
                    .iter()
                    .filter_map(|(&pos, &index)| {
                        self
                            .block_entities
                            .get(index)
                            .unwrap()
                            .inner
                            .clone()
                            .map(|e| (pos, e))
                    })
                    .collect(),
            })
        }
        /// Remove a chunk at given chunk coordinates and return a snapshot of it. If there
        /// is no chunk at the coordinates but entities or block entities are present, None
        /// is returned but entities and block entities are removed from the world.
        pub fn remove_chunk_snapshot(
            &mut self,
            cx: i32,
            cz: i32,
        ) -> Option<ChunkSnapshot> {
            let chunk_comp = self.chunks.remove(&(cx, cz))?;
            let mut ret = None;
            let entities = chunk_comp
                .entities
                .keys()
                .filter_map(|&id| {
                    self
                        .remove_entity_inner(id, false, "remove chunk snapshot")
                        .unwrap()
                        .inner
                })
                .collect();
            let block_entities = chunk_comp
                .block_entities
                .keys()
                .filter_map(|&pos| {
                    self
                        .remove_block_entity_inner(pos, false)
                        .unwrap()
                        .inner
                        .map(|e| (pos, e))
                })
                .collect();
            if let Some(chunk) = chunk_comp.data {
                ret = Some(ChunkSnapshot {
                    cx,
                    cz,
                    chunk,
                    entities,
                    block_entities,
                });
                self.push_event(Event::Chunk {
                    cx,
                    cz,
                    inner: ChunkEvent::Remove,
                });
            }
            ret
        }
        /// Raw function to add a chunk to the world at the given coordinates. Note that the
        /// given chunk only contains block and light data, so no entity or block entity will
        /// be added by this function.
        ///
        /// If any chunk is existing at this coordinate, it's just replaced and all entities
        /// and block entities are not touched.
        ///
        /// Only entities and block entities that are in a chunk will be ticked.
        pub fn set_chunk(&mut self, cx: i32, cz: i32, chunk: Arc<Chunk>) {
            let chunk_comp = self.chunks.entry((cx, cz)).or_default();
            let was_unloaded = chunk_comp.data.replace(chunk).is_none();
            if was_unloaded {
                for &index in chunk_comp.entities.values() {
                    self.entities.get_mut(index).unwrap().loaded = true;
                }
                for &index in chunk_comp.block_entities.values() {
                    self.block_entities.get_mut(index).unwrap().loaded = true;
                }
            }
            self.push_event(Event::Chunk {
                cx,
                cz,
                inner: ChunkEvent::Set,
            });
        }
        /// Return true if a given chunk is present in the world.
        pub fn contains_chunk(&self, cx: i32, cz: i32) -> bool {
            self.chunks.get(&(cx, cz)).is_some_and(|c| c.data.is_some())
        }
        /// Get a reference to a chunk, if existing.
        pub fn get_chunk(&self, cx: i32, cz: i32) -> Option<&Chunk> {
            self.chunks.get(&(cx, cz)).and_then(|c| c.data.as_deref())
        }
        /// Get a mutable reference to a chunk, if existing.
        pub fn get_chunk_mut(&mut self, cx: i32, cz: i32) -> Option<&mut Chunk> {
            self.chunks
                .get_mut(&(cx, cz))
                .and_then(|c| c.data.as_mut().map(Arc::make_mut))
        }
        /// Remove a chunk that may not exists. Note that this only removed the chunk data,
        /// not its entities and block entities.
        pub fn remove_chunk(&mut self, cx: i32, cz: i32) -> Option<Arc<Chunk>> {
            let chunk_comp = self.chunks.get_mut(&(cx, cz))?;
            let ret = chunk_comp.data.take();
            if ret.is_some() {
                for &index in chunk_comp.entities.values() {
                    self.entities.get_mut(index).unwrap().loaded = false;
                }
                for &index in chunk_comp.block_entities.values() {
                    self.block_entities.get_mut(index).unwrap().loaded = false;
                }
                self.push_event(Event::Chunk {
                    cx,
                    cz,
                    inner: ChunkEvent::Remove,
                });
            }
            ret
        }
        /// Set block and metadata at given position in the world, if the chunk is not
        /// loaded, none is returned, but if it is existing the previous block and metadata
        /// is returned. This function also push a block change event and update lights
        /// accordingly.
        pub fn set_block(
            &mut self,
            pos: IVec3,
            id: u8,
            metadata: u8,
        ) -> Option<(u8, u8)> {
            let (cx, cz) = calc_chunk_pos(pos)?;
            let chunk = self.get_chunk_mut(cx, cz)?;
            let (prev_id, prev_metadata) = chunk.get_block(pos);
            if id != prev_id || metadata != prev_metadata {
                chunk.set_block(pos, id, metadata);
                chunk.recompute_height(pos);
                if block::material::get_light_opacity(id)
                    != block::material::get_light_opacity(prev_id)
                    || block::material::get_light_emission(id)
                        != block::material::get_light_emission(prev_id)
                {
                    self.schedule_light_update(pos, LightKind::Block);
                    self.schedule_light_update(pos, LightKind::Sky);
                }
                self.push_event(Event::Block {
                    pos,
                    inner: BlockEvent::Set {
                        id,
                        metadata,
                        prev_id,
                        prev_metadata,
                    },
                });
                self.push_event(Event::Chunk {
                    cx,
                    cz,
                    inner: ChunkEvent::Dirty,
                });
            }
            Some((prev_id, prev_metadata))
        }
        /// Same as the [`set_block`] method, but the previous block and new block are
        /// notified of that removal and addition.
        ///
        /// [`set_block`]: Self::set_block
        pub fn set_block_self_notify(
            &mut self,
            pos: IVec3,
            id: u8,
            metadata: u8,
        ) -> Option<(u8, u8)> {
            let (prev_id, prev_metadata) = self.set_block(pos, id, metadata)?;
            self.notify_change_unchecked(pos, prev_id, prev_metadata, id, metadata);
            Some((prev_id, prev_metadata))
        }
        /// Same as the [`set_block_self_notify`] method, but additionally the blocks around
        /// are notified of that neighbor change.
        ///
        /// [`set_block_self_notify`]: Self::set_block_self_notify
        pub fn set_block_notify(
            &mut self,
            pos: IVec3,
            id: u8,
            metadata: u8,
        ) -> Option<(u8, u8)> {
            let (prev_id, prev_metadata) = self
                .set_block_self_notify(pos, id, metadata)?;
            self.notify_blocks_around(pos, id);
            Some((prev_id, prev_metadata))
        }
        /// Get block and metadata at given position in the world, if the chunk is not
        /// loaded, none is returned.
        pub fn get_block(&self, pos: IVec3) -> Option<(u8, u8)> {
            let (cx, cz) = calc_chunk_pos(pos)?;
            let chunk = self.get_chunk(cx, cz)?;
            Some(chunk.get_block(pos))
        }
        /// Get saved height of a chunk column, Y component is ignored in the position.
        pub fn get_height(&self, pos: IVec3) -> Option<u8> {
            let (cx, cz) = calc_chunk_pos_unchecked(pos);
            let chunk = self.get_chunk(cx, cz)?;
            Some(chunk.get_height(pos))
        }
        /// Get light level at the given position, in range 0..16.
        pub fn get_light(&self, mut pos: IVec3) -> Light {
            if pos.y > 127 {
                pos.y = 127;
            }
            let mut light = Light {
                block: 0,
                sky: 15,
                sky_real: 0,
            };
            if let Some((cx, cz)) = calc_chunk_pos(pos) {
                if let Some(chunk) = self.get_chunk(cx, cz) {
                    light.block = chunk.get_block_light(pos);
                    light.sky = chunk.get_sky_light(pos);
                }
            }
            light.sky_real = light.sky.saturating_sub(self.sky_light_subtracted);
            light
        }
        /// Schedule a light update to be processed in a future tick.
        ///
        /// See [`tick_light`](Self::tick_light).
        pub fn schedule_light_update(&mut self, pos: IVec3, kind: LightKind) {
            self.light_updates
                .push_back(LightUpdate {
                    kind,
                    pos,
                    credit: 15,
                });
        }
        /// Get the number of light updates remaining to process.
        #[inline]
        pub fn get_light_update_count(&self) -> usize {
            self.light_updates.len()
        }
        /// Get the biome at some position (Y component is ignored).
        pub fn get_biome(&self, pos: IVec3) -> Option<Biome> {
            let (cx, cz) = calc_chunk_pos_unchecked(pos);
            let chunk = self.get_chunk(cx, cz)?;
            Some(chunk.get_biome(pos))
        }
        /// Internal function to ensure monomorphization and reduce bloat of the
        /// generic [`spawn_entity`].
        #[inline(never)]
        fn spawn_entity_inner(&mut self, entity: Box<Entity>) -> u32 {
            let id = self.entities_count;
            self
                .entities_count = self
                .entities_count
                .checked_add(1)
                .expect("entity count overflow");
            let kind = entity.kind();
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event mc173\\src\\world.rs:566",
                            "mc173::world",
                            ::tracing::Level::TRACE,
                            ::core::option::Option::Some("mc173\\src\\world.rs"),
                            ::core::option::Option::Some(566u32),
                            ::core::option::Option::Some("mc173::world"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::TRACE
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::core::iter::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::core::option::Option::Some(
                                            &format_args!("spawn entity #{1} ({0:?})", kind, id)
                                                as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                }
            };
            let (cx, cz) = calc_entity_chunk_pos(entity.0.pos);
            let chunk_comp = self.chunks.entry((cx, cz)).or_default();
            let entity_index = self
                .entities
                .push(EntityComponent {
                    inner: Some(entity),
                    id,
                    cx,
                    cz,
                    loaded: chunk_comp.data.is_some(),
                    kind,
                });
            chunk_comp.entities.insert(id, entity_index);
            self.entities_id_map.insert(id, entity_index);
            self.push_event(Event::Entity {
                id,
                inner: EntityEvent::Spawn,
            });
            self.push_event(Event::Chunk {
                cx,
                cz,
                inner: ChunkEvent::Dirty,
            });
            id
        }
        /// Spawn an entity in this world, this function gives it a unique id and ensure
        /// coherency with chunks cache.
        ///
        /// **This function is legal to call from ticking entities, but such entities will be
        /// ticked once in the same cycle as the currently ticking entity.**
        #[inline(always)]
        pub fn spawn_entity(&mut self, entity: impl Into<Box<Entity>>) -> u32 {
            self.spawn_entity_inner(entity.into())
        }
        /// Return true if an entity is present from its id.
        pub fn contains_entity(&self, id: u32) -> bool {
            self.entities_id_map.contains_key(&id)
        }
        /// Return the number of entities in the world, loaded or not.
        #[inline]
        pub fn get_entity_count(&self) -> usize {
            self.entities.len()
        }
        /// Get a generic entity from its unique id. This generic entity can later be checked
        /// for being of a particular type. None can be returned if no entity is existing for
        /// this id or if the entity is the current entity being updated.
        pub fn get_entity(&self, id: u32) -> Option<&Entity> {
            let index = *self.entities_id_map.get(&id)?;
            self.entities.get(index).unwrap().inner.as_deref()
        }
        /// Get a generic entity from its unique id. This generic entity can later be checked
        /// for being of a particular type. None can be returned if no entity is existing for
        /// this id or if the entity is the current entity being updated.
        pub fn get_entity_mut(&mut self, id: u32) -> Option<&mut Entity> {
            let index = *self.entities_id_map.get(&id)?;
            self.entities.get_mut(index).unwrap().inner.as_deref_mut()
        }
        /// Remove an entity with given id, returning some boxed entity is successful. This
        /// returns true if the entity has been successfully removed removal, the entity's
        /// storage is guaranteed to be freed after return, but the entity footprint in the
        /// world will be cleaned only after ticking.
        pub fn remove_entity(&mut self, id: u32, reason: &str) -> bool {
            self.remove_entity_inner(id, true, reason).is_some()
        }
        /// Internal version of [`remove_entity`] that returns the removed component.
        ///
        /// The caller can specify if the entity is known to be in an existing chunk
        /// component, if the caller know that the chunk component is no longer existing,
        /// it avoids panicking.
        ///
        /// The given reason is only used for log tracing.
        fn remove_entity_inner(
            &mut self,
            id: u32,
            has_chunk: bool,
            reason: &str,
        ) -> Option<EntityComponent> {
            let index = self.entities_id_map.remove(&id)?;
            self.entities_player_map.remove(&id);
            let comp = self.entities.remove(index);
            let swapped_index = self.entities.len();
            if true {
                match (&comp.id, &id) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::Some(
                                    format_args!("entity incoherent id"),
                                ),
                            );
                        }
                    }
                };
            }
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event mc173\\src\\world.rs:653",
                            "mc173::world",
                            ::tracing::Level::TRACE,
                            ::core::option::Option::Some("mc173\\src\\world.rs"),
                            ::core::option::Option::Some(653u32),
                            ::core::option::Option::Some("mc173::world"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::TRACE
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::core::iter::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::core::option::Option::Some(
                                            &format_args!(
                                                "remove entity #{1} ({0:?}): {2}",
                                                comp.kind,
                                                id,
                                                reason,
                                            ) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                }
            };
            let (cx, cz) = (comp.cx, comp.cz);
            if has_chunk {
                let removed_index = self
                    .chunks
                    .get_mut(&(cx, cz))
                    .expect("entity chunk is missing")
                    .entities
                    .remove(&id);
                if true {
                    match (&removed_index, &Some(index)) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::Some(
                                        format_args!("entity is incoherent in its chunk"),
                                    ),
                                );
                            }
                        }
                    };
                }
            }
            if let Some(swapped_comp) = self.entities.get(index) {
                let prev_index = self.entities_id_map.insert(swapped_comp.id, index);
                if true {
                    match (&prev_index, &Some(swapped_index)) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::Some(
                                        format_args!("swapped entity is incoherent"),
                                    ),
                                );
                            }
                        }
                    };
                }
                self.entities_player_map
                    .entry(swapped_comp.id)
                    .and_modify(|i| *i = index);
                let (swapped_cx, swapped_cz) = (swapped_comp.cx, swapped_comp.cz);
                if has_chunk || (swapped_cx, swapped_cz) != (cx, cz) {
                    let removed_index = self
                        .chunks
                        .get_mut(&(swapped_cx, swapped_cz))
                        .expect("swapped entity chunk is missing")
                        .entities
                        .insert(swapped_comp.id, index);
                    if true {
                        match (&removed_index, &Some(swapped_index)) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::Some(
                                            format_args!("swapped entity is incoherent in its chunk"),
                                        ),
                                    );
                                }
                            }
                        };
                    }
                }
            }
            self.push_event(Event::Entity {
                id,
                inner: EntityEvent::Remove,
            });
            if has_chunk {
                self.push_event(Event::Chunk {
                    cx,
                    cz,
                    inner: ChunkEvent::Dirty,
                });
            }
            Some(comp)
        }
        /// Set an entity that is already existing to be a player entity. Player entities are
        /// used as dynamic anchors in the world that are used for things like natural entity
        /// despawning when players are too far away, or for looking at players.
        ///
        /// This methods returns true if the property has been successfully set.
        pub fn set_entity_player(&mut self, id: u32, player: bool) -> bool {
            let Some(&index) = self.entities_id_map.get(&id) else { return false };
            if player {
                self.entities_player_map.insert(id, index);
            } else {
                self.entities_player_map.remove(&id);
            }
            true
        }
        /// Returns true if the given entity by its id is a player entity. This also returns
        /// false if the entity isn't existing.
        pub fn is_entity_player(&mut self, id: u32) -> bool {
            self.entities_player_map.contains_key(&id)
        }
        /// Returns the number of player entities in the world, loaded or not.
        #[inline]
        pub fn get_entity_player_count(&self) -> usize {
            self.entities_player_map.len()
        }
        /// Inner function to set block entity at given position, used to elide generics.
        #[inline(never)]
        fn set_block_entity_inner(
            &mut self,
            pos: IVec3,
            block_entity: Box<BlockEntity>,
        ) {
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event mc173\\src\\world.rs:736",
                            "mc173::world",
                            ::tracing::Level::TRACE,
                            ::core::option::Option::Some("mc173\\src\\world.rs"),
                            ::core::option::Option::Some(736u32),
                            ::core::option::Option::Some("mc173::world"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::TRACE
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::core::iter::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::core::option::Option::Some(
                                            &format_args!("set block entity {0}", pos) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                }
            };
            let (cx, cz) = calc_chunk_pos_unchecked(pos);
            match self.block_entities_pos_map.entry(pos) {
                Entry::Occupied(o) => {
                    let index = *o.into_mut();
                    self
                        .block_entities
                        .get_mut(index)
                        .unwrap()
                        .inner = Some(block_entity);
                    self.block_entities.invalidate(index);
                    self.push_event(Event::BlockEntity {
                        pos,
                        inner: BlockEntityEvent::Remove,
                    });
                }
                Entry::Vacant(v) => {
                    let chunk_comp = self.chunks.entry((cx, cz)).or_default();
                    let block_entity_index = self
                        .block_entities
                        .push(BlockEntityComponent {
                            inner: Some(block_entity),
                            loaded: chunk_comp.data.is_some(),
                            pos,
                        });
                    chunk_comp.block_entities.insert(pos, block_entity_index);
                    v.insert(block_entity_index);
                }
            }
            self.push_event(Event::BlockEntity {
                pos,
                inner: BlockEntityEvent::Set,
            });
            self.push_event(Event::Chunk {
                cx,
                cz,
                inner: ChunkEvent::Dirty,
            });
        }
        /// Set the block entity at the given position. If a block entity was already at the
        /// position, it is removed silently.
        #[inline(always)]
        pub fn set_block_entity(
            &mut self,
            pos: IVec3,
            block_entity: impl Into<Box<BlockEntity>>,
        ) {
            self.set_block_entity_inner(pos, block_entity.into());
        }
        /// Returns true if some block entity is present in the world.
        pub fn contains_block_entity(&self, pos: IVec3) -> bool {
            self.block_entities_pos_map.contains_key(&pos)
        }
        /// Return the number of block entities in the world, loaded or not.
        #[inline]
        pub fn get_block_entity_count(&self) -> usize {
            self.block_entities.len()
        }
        /// Get a block entity from its position.
        pub fn get_block_entity(&self, pos: IVec3) -> Option<&BlockEntity> {
            let index = *self.block_entities_pos_map.get(&pos)?;
            self.block_entities.get(index).unwrap().inner.as_deref()
        }
        /// Get a block entity from its position.
        pub fn get_block_entity_mut(&mut self, pos: IVec3) -> Option<&mut BlockEntity> {
            let index = *self.block_entities_pos_map.get(&pos)?;
            self.block_entities.get_mut(index).unwrap().inner.as_deref_mut()
        }
        /// Remove a block entity from a position. Returning true if successful, in this case
        /// the block entity storage is guaranteed to be freed, but the block entity footprint
        /// in this world will be definitely cleaned after ticking.
        pub fn remove_block_entity(&mut self, pos: IVec3) -> bool {
            self.remove_block_entity_inner(pos, true).is_some()
        }
        /// Internal version of `remove_block_entity` that returns the removed component.
        ///
        /// The caller can specify if the block entity is known to be in an existing chunk
        /// component, if the caller know that the chunk component is no longer existing,
        /// it avoids panicking.
        fn remove_block_entity_inner(
            &mut self,
            pos: IVec3,
            has_chunk: bool,
        ) -> Option<BlockEntityComponent> {
            let index = self.block_entities_pos_map.remove(&pos)?;
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event mc173\\src\\world.rs:818",
                            "mc173::world",
                            ::tracing::Level::TRACE,
                            ::core::option::Option::Some("mc173\\src\\world.rs"),
                            ::core::option::Option::Some(818u32),
                            ::core::option::Option::Some("mc173::world"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::TRACE
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::core::iter::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::core::option::Option::Some(
                                            &format_args!("remove block entity {0}", pos) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                }
            };
            let comp = self.block_entities.remove(index);
            let swapped_index = self.block_entities.len();
            if true {
                match (&comp.pos, &pos) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::Some(
                                    format_args!("block entity incoherent position"),
                                ),
                            );
                        }
                    }
                };
            }
            let (cx, cz) = calc_chunk_pos_unchecked(pos);
            if has_chunk {
                let removed_index = self
                    .chunks
                    .get_mut(&(cx, cz))
                    .expect("block entity chunk is missing")
                    .block_entities
                    .remove(&pos);
                if true {
                    match (&removed_index, &Some(index)) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::Some(
                                        format_args!("block entity is incoherent in its chunk"),
                                    ),
                                );
                            }
                        }
                    };
                }
            }
            if let Some(swapped_comp) = self.block_entities.get(index) {
                let prev_index = self
                    .block_entities_pos_map
                    .insert(swapped_comp.pos, index);
                if true {
                    match (&prev_index, &Some(swapped_index)) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::Some(
                                        format_args!("swapped block entity is incoherent"),
                                    ),
                                );
                            }
                        }
                    };
                }
                let (swapped_cx, swapped_cz) = calc_chunk_pos_unchecked(
                    swapped_comp.pos,
                );
                if has_chunk || (swapped_cx, swapped_cz) != (cx, cz) {
                    let removed_index = self
                        .chunks
                        .get_mut(&(swapped_cx, swapped_cz))
                        .expect("swapped block entity chunk is missing")
                        .block_entities
                        .insert(swapped_comp.pos, index);
                    if true {
                        match (&removed_index, &Some(swapped_index)) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::Some(
                                            format_args!(
                                                "swapped block entity is incoherent in its chunk",
                                            ),
                                        ),
                                    );
                                }
                            }
                        };
                    }
                }
            }
            self.push_event(Event::BlockEntity {
                pos,
                inner: BlockEntityEvent::Remove,
            });
            if has_chunk {
                self.push_event(Event::Chunk {
                    cx,
                    cz,
                    inner: ChunkEvent::Dirty,
                });
            }
            Some(comp)
        }
        /// Schedule a tick update to happen at the given position, for the given block id
        /// and with a given delay in ticks. The block tick is not scheduled if a tick was
        /// already scheduled for that exact block id and position.
        pub fn schedule_block_tick(&mut self, pos: IVec3, id: u8, delay: u64) {
            let uid = self.block_ticks_count;
            self
                .block_ticks_count = self
                .block_ticks_count
                .checked_add(1)
                .expect("scheduled ticks count overflow");
            let state = BlockTickState { pos, id };
            if self.block_ticks_states.insert(state) {
                self.block_ticks
                    .insert(BlockTick {
                        time: self.time + delay,
                        state,
                        uid,
                    });
            }
        }
        /// Return the current number of scheduled block ticks waiting.
        #[inline]
        pub fn get_block_tick_count(&self) -> usize {
            self.block_ticks.len()
        }
        /// Iterate over all blocks in the given area where max is excluded.
        #[inline]
        pub fn iter_blocks_in(&self, min: IVec3, max: IVec3) -> BlocksInIter<'_> {
            BlocksInIter::new(self, min, max)
        }
        /// Iterate over all blocks in the chunk at given coordinates.
        #[inline]
        pub fn iter_blocks_in_chunk(&self, cx: i32, cz: i32) -> BlocksInChunkIter<'_> {
            BlocksInChunkIter::new(self, cx, cz)
        }
        /// Iterate over all entities in the world.
        /// *This function can't return the current updated entity.*
        #[inline]
        pub fn iter_entities(&self) -> EntitiesIter<'_> {
            EntitiesIter(self.entities.iter())
        }
        /// Iterator over all entities in the world through mutable references.
        /// *This function can't return the current updated entity.*
        #[inline]
        pub fn iter_entities_mut(&mut self) -> EntitiesIterMut<'_> {
            EntitiesIterMut(self.entities.iter_mut())
        }
        /// Iterate over all player entities in the world.
        /// *This function can't return the current updated entity.*
        #[inline]
        pub fn iter_player_entities(&self) -> PlayerEntitiesIter<'_> {
            PlayerEntitiesIter {
                indices: Some(self.entities_player_map.values()),
                entities: &self.entities,
            }
        }
        /// Iterate over all player entities in the world through mutable references.
        /// *This function can't return the current updated entity.*
        #[inline]
        pub fn iter_player_entities_mut(&mut self) -> PlayerEntitiesIterMut<'_> {
            PlayerEntitiesIterMut {
                indices: Some(self.entities_player_map.values()),
                entities: &mut self.entities,
                #[cfg(debug_assertions)]
                returned_pointers: HashSet::new(),
            }
        }
        /// Iterate over all entities of the given chunk.
        /// *This function can't return the current updated entity.*
        #[inline]
        pub fn iter_entities_in_chunk(
            &self,
            cx: i32,
            cz: i32,
        ) -> EntitiesInChunkIter<'_> {
            EntitiesInChunkIter {
                indices: self.chunks.get(&(cx, cz)).map(|comp| comp.entities.values()),
                entities: &self.entities,
            }
        }
        /// Iterate over all entities of the given chunk through mutable references.
        /// *This function can't return the current updated entity.*
        #[inline]
        pub fn iter_entities_in_chunk_mut(
            &mut self,
            cx: i32,
            cz: i32,
        ) -> EntitiesInChunkIterMut<'_> {
            EntitiesInChunkIterMut {
                indices: self.chunks.get(&(cx, cz)).map(|comp| comp.entities.values()),
                entities: &mut self.entities,
                #[cfg(debug_assertions)]
                returned_pointers: HashSet::new(),
            }
        }
        /// Iterate over all entities colliding with the given bounding box.
        /// *This function can't return the current updated entity.*
        #[inline]
        pub fn iter_entities_colliding(
            &self,
            bb: BoundingBox,
        ) -> EntitiesCollidingIter<'_> {
            let (start_cx, start_cz) = calc_entity_chunk_pos(bb.min - 2.0);
            let (end_cx, end_cz) = calc_entity_chunk_pos(bb.max + 2.0);
            EntitiesCollidingIter {
                chunks: ChunkComponentsIter {
                    chunks: &self.chunks,
                    range: ChunkRange::new(start_cx, start_cz, end_cx, end_cz),
                },
                indices: None,
                entities: &self.entities,
                bb,
            }
        }
        /// Iterate over all entities colliding with the given bounding box through mut ref.
        /// *This function can't return the current updated entity.*
        #[inline]
        pub fn iter_entities_colliding_mut(
            &mut self,
            bb: BoundingBox,
        ) -> EntitiesCollidingIterMut<'_> {
            let (start_cx, start_cz) = calc_entity_chunk_pos(bb.min - 2.0);
            let (end_cx, end_cz) = calc_entity_chunk_pos(bb.max + 2.0);
            EntitiesCollidingIterMut {
                chunks: ChunkComponentsIter {
                    chunks: &self.chunks,
                    range: ChunkRange::new(start_cx, start_cz, end_cx, end_cz),
                },
                indices: None,
                entities: &mut self.entities,
                bb,
                #[cfg(debug_assertions)]
                returned_pointers: HashSet::new(),
            }
        }
        /// Return true if any entity is colliding the given bounding box. The hard argument
        /// can be set to true in order to only check for "hard" entities, hard entities can
        /// prevent block placements and entity spawning.
        pub fn has_entity_colliding(&self, bb: BoundingBox, hard: bool) -> bool {
            self.iter_entities_colliding(bb)
                .any(|(_, entity)| !hard || entity.kind().is_hard())
        }
        /// Tick the world, this ticks all entities.
        /// TODO: Guard this from being called recursively from tick functions.
        pub fn tick(&mut self) {
            if self.time % 20 == 0 {}
            self.tick_weather();
            self.tick_natural_spawn();
            self.tick_sky_light();
            self.time += 1;
            self.tick_blocks();
            self.tick_entities();
            self.tick_block_entities();
            self.tick_light(1000);
        }
        /// Update current weather in the world.
        fn tick_weather(&mut self) {
            if self.dimension == Dimension::Nether {
                return;
            }
            if self.time >= self.weather_next_time {
                if self.time != 0 {
                    let new_weather = match self.weather {
                        Weather::Clear => {
                            self.rand.next_choice(&[Weather::Rain, Weather::Thunder])
                        }
                        _ => self.rand.next_choice(&[self.weather, Weather::Clear]),
                    };
                    self.set_weather(new_weather);
                }
                let bound = if self.weather == Weather::Clear { 168000 } else { 12000 };
                let delay = self.rand.next_int_bounded(bound) as u64 + 12000;
                self.weather_next_time = self.time + delay;
            }
        }
        /// Do natural animal and mob spawning in the world.
        fn tick_natural_spawn(&mut self) {
            /// The maximum manhattan distance a chunk can be loaded.
            const CHUNK_MAX_DIST: u32 = 8;
            /// The minimum distance required from any player entity to spawn.
            const SPAWN_MIN_DIST_SQUARED: f64 = 24.0 * 24.0;
            let mut categories_count = [0; EntityCategory::ALL.len()];
            for comp in self.entities.iter() {
                if comp.loaded {
                    if let Some(entity) = comp.inner.as_deref() {
                        categories_count[entity.category() as usize] += 1;
                    }
                }
            }
            let mut loaded_chunks = LOADED_CHUNKS.take();
            loaded_chunks.clear();
            loaded_chunks
                .extend(
                    self
                        .chunks
                        .iter()
                        .filter_map(|(&pos, comp)| comp.data.is_some().then_some(pos)),
                );
            loaded_chunks
                .retain(|&(cx, cz)| {
                    self.entities_player_map
                        .values()
                        .map(|&index| self.entities.get(index).unwrap())
                        .any(|comp| {
                            comp.cx.abs_diff(cx) <= CHUNK_MAX_DIST
                                && comp.cz.abs_diff(cz) <= CHUNK_MAX_DIST
                        })
                });
            for category in EntityCategory::ALL {
                let max_world_count = category.natural_spawn_max_world_count();
                if max_world_count == 0 {
                    continue;
                }
                if categories_count[category as usize]
                    > max_world_count * self.chunks.len() / 256
                {
                    continue;
                }
                for &(cx, cz) in &loaded_chunks {
                    let chunk = self.chunks.get(&(cx, cz)).unwrap();
                    let chunk_data = chunk.data.as_deref().unwrap();
                    let biome = chunk_data.get_biome(IVec3::ZERO);
                    let kinds = biome.natural_entity_kinds(category);
                    if kinds.is_empty() {
                        continue;
                    }
                    let center_pos = IVec3 {
                        x: cx * 16 + self.rand.next_int_bounded(16),
                        y: self.rand.next_int_bounded(128),
                        z: cz * 16 + self.rand.next_int_bounded(16),
                    };
                    let (block, _) = chunk_data.get_block(center_pos);
                    if block::material::get_material(block)
                        != category.natural_spawn_material()
                    {
                        continue;
                    }
                    let chance_sum = kinds.iter().map(|kind| kind.chance).sum::<u16>();
                    let index = self.rand.next_int_bounded(chance_sum as i32) as u16;
                    let mut chance_acc = 0;
                    let mut kind = kinds[0].kind;
                    for test_kind in kinds {
                        chance_acc += test_kind.chance;
                        if index < chance_acc {
                            kind = test_kind.kind;
                            break;
                        }
                    }
                    let max_chunk_count = kind.natural_spawn_max_chunk_count();
                    let mut spawn_count = 0usize;
                    'pack: for _ in 0..3 {
                        let mut spawn_pos = center_pos;
                        'chain: for _ in 0..4 {
                            spawn_pos
                                += IVec3 {
                                    x: self.rand.next_int_bounded(6)
                                        - self.rand.next_int_bounded(6),
                                    y: self.rand.next_int_bounded(1)
                                        - self.rand.next_int_bounded(1),
                                    z: self.rand.next_int_bounded(6)
                                        - self.rand.next_int_bounded(6),
                                };
                            if category == EntityCategory::WaterAnimal {
                                if !self.get_block_material(spawn_pos).is_fluid() {
                                    continue;
                                }
                                if self.is_block_opaque_cube(spawn_pos + IVec3::Y) {
                                    continue;
                                }
                            } else {
                                if self.is_block_opaque_cube(spawn_pos)
                                    || self.is_block_opaque_cube(spawn_pos + IVec3::Y)
                                {
                                    continue;
                                }
                                if !self.is_block_opaque_cube(spawn_pos - IVec3::Y) {
                                    continue;
                                }
                            }
                            let spawn_pos = spawn_pos.as_dvec3()
                                + DVec3::new(0.5, 0.0, 0.5);
                            let mut close_player = false;
                            for (_, Entity(player_base, _)) in self
                                .iter_player_entities()
                            {
                                let player_dist_sq = player_base
                                    .pos
                                    .distance_squared(spawn_pos);
                                if player_dist_sq < SPAWN_MIN_DIST_SQUARED {
                                    continue 'chain;
                                } else if player_dist_sq <= 128.0 * 128.0 {
                                    close_player = true;
                                }
                            }
                            if !close_player {
                                continue;
                            }
                            let mut entity = kind.new_default(spawn_pos);
                            entity.0.persistent = true;
                            entity
                                .0
                                .look
                                .x = self.rand.next_float() * std::f32::consts::TAU;
                            entity.init_natural_spawn(self);
                            if !entity.can_natural_spawn(self) {
                                continue;
                            }
                            self.spawn_entity(entity);
                            spawn_count += 1;
                            if spawn_count >= max_chunk_count {
                                break 'pack;
                            }
                        }
                    }
                }
            }
            LOADED_CHUNKS.set(loaded_chunks);
        }
        /// Update the sky light value depending on the current time, it is then used to get
        /// the real light value of blocks.
        fn tick_sky_light(&mut self) {
            let time_wrapped = self.time % 24000;
            let mut half_turn = (time_wrapped as f32 + 1.0) / 24000.0 - 0.25;
            if half_turn < 0.0 {
                half_turn += 1.0;
            } else if half_turn > 1.0 {
                half_turn -= 1.0;
            }
            let celestial_angle = match self.dimension {
                Dimension::Nether => 0.5,
                _ => {
                    half_turn
                        + (1.0 - ((half_turn * std::f32::consts::PI).cos() + 1.0) / 2.0
                            - half_turn) / 3.0
                }
            };
            let factor = (celestial_angle * std::f32::consts::TAU).cos() * 2.0 + 0.5;
            let factor = factor.clamp(0.0, 1.0);
            let factor = (match self.weather {
                Weather::Clear => 1.0,
                Weather::Rain => 0.6875,
                Weather::Thunder => 0.47265625,
            }) * factor;
            self.sky_light_subtracted = ((1.0 - factor) * 11.0) as u8;
        }
        /// Internal function to tick the internal scheduler.
        fn tick_blocks(&mut self) {
            if true {
                match (&self.block_ticks.len(), &self.block_ticks_states.len()) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
            }
            while let Some(tick) = self.block_ticks.first() {
                if self.time > tick.time {
                    let tick = self.block_ticks.pop_first().unwrap();
                    if !self.block_ticks_states.remove(&tick.state) {
                        ::core::panicking::panic(
                            "assertion failed: self.block_ticks_states.remove(&tick.state)",
                        )
                    }
                    if let Some((id, metadata)) = self.get_block(tick.state.pos) {
                        if id == tick.state.id {
                            self.tick_block_unchecked(
                                tick.state.pos,
                                id,
                                metadata,
                                false,
                            );
                        }
                    }
                } else {
                    break;
                }
            }
            let mut pending_random_ticks = RANDOM_TICKS_PENDING.take();
            if true {
                if !pending_random_ticks.is_empty() {
                    ::core::panicking::panic(
                        "assertion failed: pending_random_ticks.is_empty()",
                    )
                }
            }
            for (&(cx, cz), chunk) in &mut self.chunks {
                if let Some(chunk_data) = &chunk.data {
                    let chunk_pos = IVec3::new(
                        cx * CHUNK_WIDTH as i32,
                        0,
                        cz * CHUNK_WIDTH as i32,
                    );
                    for _ in 0..80 {
                        self
                            .random_ticks_seed = self
                            .random_ticks_seed
                            .wrapping_mul(3)
                            .wrapping_add(1013904223);
                        let rand = self.random_ticks_seed >> 2;
                        let pos = IVec3::new(
                            (rand >> 0) & 15,
                            (rand >> 16) & 127,
                            (rand >> 8) & 15,
                        );
                        let (id, metadata) = chunk_data.get_block(pos);
                        pending_random_ticks.push((chunk_pos + pos, id, metadata));
                    }
                }
            }
            for (pos, id, metadata) in pending_random_ticks.drain(..) {
                self.tick_block_unchecked(pos, id, metadata, true);
            }
            RANDOM_TICKS_PENDING.set(pending_random_ticks);
        }
        /// Internal function to tick all entities.
        fn tick_entities(&mut self) {
            self.entities.reset();
            while let Some((_, comp)) = self.entities.current_mut() {
                if !comp.loaded {
                    self.entities.advance();
                    continue;
                }
                let mut entity = comp
                    .inner
                    .take()
                    .expect("entity was already being updated");
                let id = comp.id;
                let (prev_cx, prev_cz) = (comp.cx, comp.cz);
                entity.tick(&mut *self, id);
                if let Some((index, comp)) = self.entities.current_mut() {
                    if true {
                        match (&comp.id, &id) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::Some(
                                            format_args!("entity id incoherent"),
                                        ),
                                    );
                                }
                            }
                        };
                    }
                    let (new_cx, new_cz) = calc_entity_chunk_pos(entity.0.pos);
                    comp.inner = Some(entity);
                    if (prev_cx, prev_cz) != (new_cx, new_cz) {
                        let removed_index = self
                            .chunks
                            .get_mut(&(prev_cx, prev_cz))
                            .expect("entity previous chunk is missing")
                            .entities
                            .remove(&id);
                        if true {
                            match (&removed_index, &Some(index)) {
                                (left_val, right_val) => {
                                    if !(*left_val == *right_val) {
                                        let kind = ::core::panicking::AssertKind::Eq;
                                        ::core::panicking::assert_failed(
                                            kind,
                                            &*left_val,
                                            &*right_val,
                                            ::core::option::Option::Some(
                                                format_args!("entity is incoherent in its previous chunk"),
                                            ),
                                        );
                                    }
                                }
                            };
                        }
                        comp.cx = new_cx;
                        comp.cz = new_cz;
                        let new_chunk_comp = self
                            .chunks
                            .entry((new_cx, new_cz))
                            .or_default();
                        let insert_success = new_chunk_comp
                            .entities
                            .insert(id, index)
                            .is_none();
                        if true {
                            if !insert_success {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!("entity was already present in its new chunk"),
                                    );
                                }
                            }
                        }
                        comp.loaded = new_chunk_comp.data.is_some();
                        self.push_event(Event::Chunk {
                            cx: prev_cx,
                            cz: prev_cz,
                            inner: ChunkEvent::Dirty,
                        });
                        self.push_event(Event::Chunk {
                            cx: new_cx,
                            cz: new_cz,
                            inner: ChunkEvent::Dirty,
                        });
                    }
                }
                self.entities.advance();
            }
        }
        fn tick_block_entities(&mut self) {
            self.block_entities.reset();
            while let Some((_, comp)) = self.block_entities.current_mut() {
                if !comp.loaded {
                    self.block_entities.advance();
                    continue;
                }
                let mut block_entity = comp
                    .inner
                    .take()
                    .expect("block entity was already being updated");
                let pos = comp.pos;
                block_entity.tick(self, pos);
                if let Some((_, comp)) = self.block_entities.current_mut() {
                    comp.inner = Some(block_entity);
                }
                self.block_entities.advance();
            }
        }
        /// Tick pending light updates for a maximum number of light updates. This function
        /// returns true only if all light updates have been processed.
        pub fn tick_light(&mut self, limit: usize) {
            for _ in 0..limit {
                let Some(update) = self.light_updates.pop_front() else { break };
                let mut max_face_emission = 0;
                for face in Face::ALL {
                    let face_pos = update.pos + face.delta();
                    let Some((cx, cz)) = calc_chunk_pos(face_pos) else { continue };
                    let Some(chunk) = self.get_chunk_mut(cx, cz) else { continue };
                    let face_emission = match update.kind {
                        LightKind::Block => chunk.get_block_light(face_pos),
                        LightKind::Sky => chunk.get_sky_light(face_pos),
                    };
                    max_face_emission = max_face_emission.max(face_emission);
                    if max_face_emission == 15 {
                        break;
                    }
                }
                let Some((cx, cz)) = calc_chunk_pos(update.pos) else { continue };
                let Some(chunk) = self.get_chunk_mut(cx, cz) else { continue };
                let (id, _) = chunk.get_block(update.pos);
                let opacity = block::material::get_light_opacity(id).max(1);
                let emission = match update.kind {
                    LightKind::Block => block::material::get_light_emission(id),
                    LightKind::Sky => {
                        let column_height = chunk.get_height(update.pos) as i32;
                        if update.pos.y >= column_height { 15 } else { 0 }
                    }
                };
                let new_light = emission.max(max_face_emission.saturating_sub(opacity));
                let mut changed = false;
                let mut sky_exposed = false;
                match update.kind {
                    LightKind::Block => {
                        if chunk.get_block_light(update.pos) != new_light {
                            chunk.set_block_light(update.pos, new_light);
                            changed = true;
                        }
                    }
                    LightKind::Sky => {
                        if chunk.get_sky_light(update.pos) != new_light {
                            chunk.set_sky_light(update.pos, new_light);
                            changed = true;
                            sky_exposed = emission == 15;
                        }
                    }
                }
                if changed {
                    self.push_event(Event::Chunk {
                        cx,
                        cz,
                        inner: ChunkEvent::Dirty,
                    });
                }
                if changed && update.credit >= 1 {
                    for face in Face::ALL {
                        if face == Face::PosY && sky_exposed {
                            continue;
                        }
                        self.light_updates
                            .push_back(LightUpdate {
                                kind: update.kind,
                                pos: update.pos + face.delta(),
                                credit: update.credit - 1,
                            });
                    }
                }
            }
        }
    }
    /// Types of dimensions, used for ambient effects in the world.
    pub enum Dimension {
        /// The overworld dimension with a blue sky and day cycles.
        Overworld,
        /// The creepy nether dimension.
        Nether,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Dimension {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Dimension::Overworld => "Overworld",
                    Dimension::Nether => "Nether",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Dimension {
        #[inline]
        fn clone(&self) -> Dimension {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Dimension {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Dimension {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Dimension {
        #[inline]
        fn eq(&self, other: &Dimension) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Dimension {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Dimension {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Dimension {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    /// Type of weather currently in the world.
    pub enum Weather {
        /// The weather is clear.
        Clear,
        /// It is raining.
        Rain,
        /// It is thundering.
        Thunder,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Weather {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Weather::Clear => "Clear",
                    Weather::Rain => "Rain",
                    Weather::Thunder => "Thunder",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Weather {
        #[inline]
        fn clone(&self) -> Weather {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Weather {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Weather {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Weather {
        #[inline]
        fn eq(&self, other: &Weather) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Weather {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Weather {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Weather {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    /// Light values of a position in the world.
    pub struct Light {
        /// Block light level.
        pub block: u8,
        /// Sky light level.
        pub sky: u8,
        /// The real sky light level, depending on the time and weather.
        pub sky_real: u8,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Light {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Light",
                "block",
                &self.block,
                "sky",
                &self.sky,
                "sky_real",
                &&self.sky_real,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Light {
        #[inline]
        fn clone(&self) -> Light {
            let _: ::core::clone::AssertParamIsClone<u8>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Light {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Light {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Light {
        #[inline]
        fn eq(&self, other: &Light) -> bool {
            self.block == other.block && self.sky == other.sky
                && self.sky_real == other.sky_real
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Light {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Light {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u8>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Light {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.block, state);
            ::core::hash::Hash::hash(&self.sky, state);
            ::core::hash::Hash::hash(&self.sky_real, state)
        }
    }
    impl Light {
        /// Calculate the maximum static light level (without time/weather attenuation).
        #[inline]
        pub fn max(self) -> u8 {
            u8::max(self.block, self.sky)
        }
        /// Calculate the maximum real light level (with time/weather attenuation).
        #[inline]
        pub fn max_real(self) -> u8 {
            u8::max(self.block, self.sky_real)
        }
        /// Calculate the block brightness from its light levels.
        #[inline]
        pub fn brightness(self) -> f32 {
            const OFFSET: f32 = 0.05;
            let base = 1.0 - self.max_real() as f32 / 15.0;
            (1.0 - base) * (base * 3.0 + 1.0) * (1.0 - OFFSET) + OFFSET
        }
    }
    /// Different kind of lights in the word.
    pub enum LightKind {
        /// Block light level, the light spread in all directions and blocks have a minimum
        /// opacity of 1 in all directions, each block has its own light emission.
        Block,
        /// Sky light level, same as block light but light do not decrease when going down
        /// and every block above height have is has an emission of 15.
        Sky,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LightKind {
        #[inline]
        fn clone(&self) -> LightKind {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for LightKind {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LightKind {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LightKind {
        #[inline]
        fn eq(&self, other: &LightKind) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for LightKind {}
    #[automatically_derived]
    impl ::core::cmp::Eq for LightKind {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    /// An event that happened in the world.
    pub enum Event {
        /// An event with a block.
        Block {
            /// The position of the block.
            pos: IVec3,
            /// Inner block event.
            inner: BlockEvent,
        },
        /// An event with an entity given its id.
        Entity {
            /// The unique id of the entity.
            id: u32,
            /// Inner entity event.
            inner: EntityEvent,
        },
        /// A block entity has been set at this position.
        BlockEntity {
            /// The block entity position.
            pos: IVec3,
            /// Inner block entity event.
            inner: BlockEntityEvent,
        },
        /// A chunk event.
        Chunk {
            /// The chunk X position.
            cx: i32,
            /// The chunk Z position.
            cz: i32,
            /// Inner chunk event.
            inner: ChunkEvent,
        },
        /// The weather in the world has changed.
        Weather {
            /// Previous weather in the world.
            prev: Weather,
            /// New weather in the world.
            new: Weather,
        },
        /// Explode blocks.
        Explode {
            /// Center position of the explosion.
            center: DVec3,
            /// Radius of the explosion around center.
            radius: f32,
        },
        /// An event to debug and spawn block break particles at the given position.
        DebugParticle {
            /// The block position to spawn particles at.
            pos: IVec3,
            /// The block to break at this position.
            block: u8,
        },
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Event {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Event::Block { pos: __self_0, inner: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Block",
                        "pos",
                        __self_0,
                        "inner",
                        &__self_1,
                    )
                }
                Event::Entity { id: __self_0, inner: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Entity",
                        "id",
                        __self_0,
                        "inner",
                        &__self_1,
                    )
                }
                Event::BlockEntity { pos: __self_0, inner: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "BlockEntity",
                        "pos",
                        __self_0,
                        "inner",
                        &__self_1,
                    )
                }
                Event::Chunk { cx: __self_0, cz: __self_1, inner: __self_2 } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "Chunk",
                        "cx",
                        __self_0,
                        "cz",
                        __self_1,
                        "inner",
                        &__self_2,
                    )
                }
                Event::Weather { prev: __self_0, new: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Weather",
                        "prev",
                        __self_0,
                        "new",
                        &__self_1,
                    )
                }
                Event::Explode { center: __self_0, radius: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Explode",
                        "center",
                        __self_0,
                        "radius",
                        &__self_1,
                    )
                }
                Event::DebugParticle { pos: __self_0, block: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "DebugParticle",
                        "pos",
                        __self_0,
                        "block",
                        &__self_1,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Event {
        #[inline]
        fn clone(&self) -> Event {
            match self {
                Event::Block { pos: __self_0, inner: __self_1 } => {
                    Event::Block {
                        pos: ::core::clone::Clone::clone(__self_0),
                        inner: ::core::clone::Clone::clone(__self_1),
                    }
                }
                Event::Entity { id: __self_0, inner: __self_1 } => {
                    Event::Entity {
                        id: ::core::clone::Clone::clone(__self_0),
                        inner: ::core::clone::Clone::clone(__self_1),
                    }
                }
                Event::BlockEntity { pos: __self_0, inner: __self_1 } => {
                    Event::BlockEntity {
                        pos: ::core::clone::Clone::clone(__self_0),
                        inner: ::core::clone::Clone::clone(__self_1),
                    }
                }
                Event::Chunk { cx: __self_0, cz: __self_1, inner: __self_2 } => {
                    Event::Chunk {
                        cx: ::core::clone::Clone::clone(__self_0),
                        cz: ::core::clone::Clone::clone(__self_1),
                        inner: ::core::clone::Clone::clone(__self_2),
                    }
                }
                Event::Weather { prev: __self_0, new: __self_1 } => {
                    Event::Weather {
                        prev: ::core::clone::Clone::clone(__self_0),
                        new: ::core::clone::Clone::clone(__self_1),
                    }
                }
                Event::Explode { center: __self_0, radius: __self_1 } => {
                    Event::Explode {
                        center: ::core::clone::Clone::clone(__self_0),
                        radius: ::core::clone::Clone::clone(__self_1),
                    }
                }
                Event::DebugParticle { pos: __self_0, block: __self_1 } => {
                    Event::DebugParticle {
                        pos: ::core::clone::Clone::clone(__self_0),
                        block: ::core::clone::Clone::clone(__self_1),
                    }
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Event {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Event {
        #[inline]
        fn eq(&self, other: &Event) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        Event::Block { pos: __self_0, inner: __self_1 },
                        Event::Block { pos: __arg1_0, inner: __arg1_1 },
                    ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                    (
                        Event::Entity { id: __self_0, inner: __self_1 },
                        Event::Entity { id: __arg1_0, inner: __arg1_1 },
                    ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                    (
                        Event::BlockEntity { pos: __self_0, inner: __self_1 },
                        Event::BlockEntity { pos: __arg1_0, inner: __arg1_1 },
                    ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                    (
                        Event::Chunk { cx: __self_0, cz: __self_1, inner: __self_2 },
                        Event::Chunk { cx: __arg1_0, cz: __arg1_1, inner: __arg1_2 },
                    ) => {
                        *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1
                            && *__self_2 == *__arg1_2
                    }
                    (
                        Event::Weather { prev: __self_0, new: __self_1 },
                        Event::Weather { prev: __arg1_0, new: __arg1_1 },
                    ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                    (
                        Event::Explode { center: __self_0, radius: __self_1 },
                        Event::Explode { center: __arg1_0, radius: __arg1_1 },
                    ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                    (
                        Event::DebugParticle { pos: __self_0, block: __self_1 },
                        Event::DebugParticle { pos: __arg1_0, block: __arg1_1 },
                    ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    /// An event with a block.
    pub enum BlockEvent {
        /// A block has been changed in the world.
        Set {
            /// The new block id.
            id: u8,
            /// The new block metadata.
            metadata: u8,
            /// Previous block id.
            prev_id: u8,
            /// Previous block metadata.
            prev_metadata: u8,
        },
        /// Play the block activation sound at given position and id/metadata.
        Sound {
            /// Current id of the block.
            id: u8,
            /// Current metadata of the block.
            metadata: u8,
        },
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for BlockEvent {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                BlockEvent::Set {
                    id: __self_0,
                    metadata: __self_1,
                    prev_id: __self_2,
                    prev_metadata: __self_3,
                } => {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Set",
                        "id",
                        __self_0,
                        "metadata",
                        __self_1,
                        "prev_id",
                        __self_2,
                        "prev_metadata",
                        &__self_3,
                    )
                }
                BlockEvent::Sound { id: __self_0, metadata: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Sound",
                        "id",
                        __self_0,
                        "metadata",
                        &__self_1,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BlockEvent {
        #[inline]
        fn clone(&self) -> BlockEvent {
            match self {
                BlockEvent::Set {
                    id: __self_0,
                    metadata: __self_1,
                    prev_id: __self_2,
                    prev_metadata: __self_3,
                } => {
                    BlockEvent::Set {
                        id: ::core::clone::Clone::clone(__self_0),
                        metadata: ::core::clone::Clone::clone(__self_1),
                        prev_id: ::core::clone::Clone::clone(__self_2),
                        prev_metadata: ::core::clone::Clone::clone(__self_3),
                    }
                }
                BlockEvent::Sound { id: __self_0, metadata: __self_1 } => {
                    BlockEvent::Sound {
                        id: ::core::clone::Clone::clone(__self_0),
                        metadata: ::core::clone::Clone::clone(__self_1),
                    }
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for BlockEvent {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for BlockEvent {
        #[inline]
        fn eq(&self, other: &BlockEvent) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        BlockEvent::Set {
                            id: __self_0,
                            metadata: __self_1,
                            prev_id: __self_2,
                            prev_metadata: __self_3,
                        },
                        BlockEvent::Set {
                            id: __arg1_0,
                            metadata: __arg1_1,
                            prev_id: __arg1_2,
                            prev_metadata: __arg1_3,
                        },
                    ) => {
                        *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1
                            && *__self_2 == *__arg1_2 && *__self_3 == *__arg1_3
                    }
                    (
                        BlockEvent::Sound { id: __self_0, metadata: __self_1 },
                        BlockEvent::Sound { id: __arg1_0, metadata: __arg1_1 },
                    ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    /// An event with an entity.
    pub enum EntityEvent {
        /// The entity has been spawned. The initial chunk position is given.
        Spawn,
        /// The entity has been removed. The last chunk position is given.
        Remove,
        /// The entity changed its position.
        Position { pos: DVec3 },
        /// The entity changed its look.
        Look { look: Vec2 },
        /// The entity changed its velocity.
        Velocity { vel: DVec3 },
        /// The entity has picked up another entity, such as arrow or item. Note that the
        /// target entity is not removed by this event, it's only a hint that this happened
        /// just before the entity may be removed.
        Pickup {
            /// The id of the picked up entity.
            target_id: u32,
        },
        /// The entity is damaged and the damage animation should be played by frontend.
        Damage,
        /// The entity is dead and the dead animation should be played by frontend.
        Dead,
        /// Some unspecified entity metadata has changed.
        Metadata,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EntityEvent {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                EntityEvent::Spawn => ::core::fmt::Formatter::write_str(f, "Spawn"),
                EntityEvent::Remove => ::core::fmt::Formatter::write_str(f, "Remove"),
                EntityEvent::Position { pos: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Position",
                        "pos",
                        &__self_0,
                    )
                }
                EntityEvent::Look { look: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Look",
                        "look",
                        &__self_0,
                    )
                }
                EntityEvent::Velocity { vel: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Velocity",
                        "vel",
                        &__self_0,
                    )
                }
                EntityEvent::Pickup { target_id: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Pickup",
                        "target_id",
                        &__self_0,
                    )
                }
                EntityEvent::Damage => ::core::fmt::Formatter::write_str(f, "Damage"),
                EntityEvent::Dead => ::core::fmt::Formatter::write_str(f, "Dead"),
                EntityEvent::Metadata => ::core::fmt::Formatter::write_str(f, "Metadata"),
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EntityEvent {
        #[inline]
        fn clone(&self) -> EntityEvent {
            match self {
                EntityEvent::Spawn => EntityEvent::Spawn,
                EntityEvent::Remove => EntityEvent::Remove,
                EntityEvent::Position { pos: __self_0 } => {
                    EntityEvent::Position {
                        pos: ::core::clone::Clone::clone(__self_0),
                    }
                }
                EntityEvent::Look { look: __self_0 } => {
                    EntityEvent::Look {
                        look: ::core::clone::Clone::clone(__self_0),
                    }
                }
                EntityEvent::Velocity { vel: __self_0 } => {
                    EntityEvent::Velocity {
                        vel: ::core::clone::Clone::clone(__self_0),
                    }
                }
                EntityEvent::Pickup { target_id: __self_0 } => {
                    EntityEvent::Pickup {
                        target_id: ::core::clone::Clone::clone(__self_0),
                    }
                }
                EntityEvent::Damage => EntityEvent::Damage,
                EntityEvent::Dead => EntityEvent::Dead,
                EntityEvent::Metadata => EntityEvent::Metadata,
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EntityEvent {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EntityEvent {
        #[inline]
        fn eq(&self, other: &EntityEvent) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        EntityEvent::Position { pos: __self_0 },
                        EntityEvent::Position { pos: __arg1_0 },
                    ) => *__self_0 == *__arg1_0,
                    (
                        EntityEvent::Look { look: __self_0 },
                        EntityEvent::Look { look: __arg1_0 },
                    ) => *__self_0 == *__arg1_0,
                    (
                        EntityEvent::Velocity { vel: __self_0 },
                        EntityEvent::Velocity { vel: __arg1_0 },
                    ) => *__self_0 == *__arg1_0,
                    (
                        EntityEvent::Pickup { target_id: __self_0 },
                        EntityEvent::Pickup { target_id: __arg1_0 },
                    ) => *__self_0 == *__arg1_0,
                    _ => true,
                }
        }
    }
    /// An event with a block entity.
    pub enum BlockEntityEvent {
        /// The block entity has been set at its position.
        Set,
        /// The block entity has been removed at its position.
        Remove,
        /// A block entity have seen some of its stored item stack changed.
        Storage {
            /// The storage targeted by this event.
            storage: BlockEntityStorage,
            /// The next item stack at this index.
            stack: ItemStack,
        },
        /// A block entity has made some progress.
        Progress {
            /// The kind of progress targeted by this event.
            progress: BlockEntityProgress,
            /// Progress value.
            value: u16,
        },
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for BlockEntityEvent {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                BlockEntityEvent::Set => ::core::fmt::Formatter::write_str(f, "Set"),
                BlockEntityEvent::Remove => {
                    ::core::fmt::Formatter::write_str(f, "Remove")
                }
                BlockEntityEvent::Storage { storage: __self_0, stack: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Storage",
                        "storage",
                        __self_0,
                        "stack",
                        &__self_1,
                    )
                }
                BlockEntityEvent::Progress { progress: __self_0, value: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Progress",
                        "progress",
                        __self_0,
                        "value",
                        &__self_1,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BlockEntityEvent {
        #[inline]
        fn clone(&self) -> BlockEntityEvent {
            match self {
                BlockEntityEvent::Set => BlockEntityEvent::Set,
                BlockEntityEvent::Remove => BlockEntityEvent::Remove,
                BlockEntityEvent::Storage { storage: __self_0, stack: __self_1 } => {
                    BlockEntityEvent::Storage {
                        storage: ::core::clone::Clone::clone(__self_0),
                        stack: ::core::clone::Clone::clone(__self_1),
                    }
                }
                BlockEntityEvent::Progress { progress: __self_0, value: __self_1 } => {
                    BlockEntityEvent::Progress {
                        progress: ::core::clone::Clone::clone(__self_0),
                        value: ::core::clone::Clone::clone(__self_1),
                    }
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for BlockEntityEvent {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for BlockEntityEvent {
        #[inline]
        fn eq(&self, other: &BlockEntityEvent) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        BlockEntityEvent::Storage { storage: __self_0, stack: __self_1 },
                        BlockEntityEvent::Storage { storage: __arg1_0, stack: __arg1_1 },
                    ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                    (
                        BlockEntityEvent::Progress {
                            progress: __self_0,
                            value: __self_1,
                        },
                        BlockEntityEvent::Progress {
                            progress: __arg1_0,
                            value: __arg1_1,
                        },
                    ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                    _ => true,
                }
        }
    }
    /// Represent the storage slot for a block entity.
    pub enum BlockEntityStorage {
        /// The storage slot is referencing a classic linear inventory at given index.
        Standard(u8),
        FurnaceInput,
        FurnaceOutput,
        FurnaceFuel,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for BlockEntityStorage {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                BlockEntityStorage::Standard(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Standard",
                        &__self_0,
                    )
                }
                BlockEntityStorage::FurnaceInput => {
                    ::core::fmt::Formatter::write_str(f, "FurnaceInput")
                }
                BlockEntityStorage::FurnaceOutput => {
                    ::core::fmt::Formatter::write_str(f, "FurnaceOutput")
                }
                BlockEntityStorage::FurnaceFuel => {
                    ::core::fmt::Formatter::write_str(f, "FurnaceFuel")
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BlockEntityStorage {
        #[inline]
        fn clone(&self) -> BlockEntityStorage {
            let _: ::core::clone::AssertParamIsClone<u8>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for BlockEntityStorage {}
    #[automatically_derived]
    impl ::core::marker::StructuralEq for BlockEntityStorage {}
    #[automatically_derived]
    impl ::core::cmp::Eq for BlockEntityStorage {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u8>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for BlockEntityStorage {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for BlockEntityStorage {
        #[inline]
        fn eq(&self, other: &BlockEntityStorage) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        BlockEntityStorage::Standard(__self_0),
                        BlockEntityStorage::Standard(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => true,
                }
        }
    }
    /// Represent the progress update for a block entity.
    pub enum BlockEntityProgress {
        FurnaceSmeltTime,
        FurnaceBurnMaxTime,
        FurnaceBurnRemainingTime,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for BlockEntityProgress {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    BlockEntityProgress::FurnaceSmeltTime => "FurnaceSmeltTime",
                    BlockEntityProgress::FurnaceBurnMaxTime => "FurnaceBurnMaxTime",
                    BlockEntityProgress::FurnaceBurnRemainingTime => {
                        "FurnaceBurnRemainingTime"
                    }
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BlockEntityProgress {
        #[inline]
        fn clone(&self) -> BlockEntityProgress {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for BlockEntityProgress {}
    #[automatically_derived]
    impl ::core::marker::StructuralEq for BlockEntityProgress {}
    #[automatically_derived]
    impl ::core::cmp::Eq for BlockEntityProgress {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for BlockEntityProgress {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for BlockEntityProgress {
        #[inline]
        fn eq(&self, other: &BlockEntityProgress) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    /// An event with a chunk.
    pub enum ChunkEvent {
        /// The chunk has been set at its position. A chunk may have been replaced at that
        /// position.
        Set,
        /// The chunk has been removed from its position.
        Remove,
        /// Any chunk component (block, light, entity, block entity) has been modified in the
        /// chunk so it's marked dirty.
        Dirty,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ChunkEvent {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    ChunkEvent::Set => "Set",
                    ChunkEvent::Remove => "Remove",
                    ChunkEvent::Dirty => "Dirty",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ChunkEvent {
        #[inline]
        fn clone(&self) -> ChunkEvent {
            match self {
                ChunkEvent::Set => ChunkEvent::Set,
                ChunkEvent::Remove => ChunkEvent::Remove,
                ChunkEvent::Dirty => ChunkEvent::Dirty,
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ChunkEvent {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ChunkEvent {
        #[inline]
        fn eq(&self, other: &ChunkEvent) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    /// A snapshot contains all of the content within a chunk, block, light, height map,
    /// entities and block entities are all included. This structure can be considered as
    /// a "view" because the chunk data (around 80 KB) is referenced to with a [`Arc`], that
    /// allows either uniquely owning it, or sharing it with a world, which is the case when
    /// saving a chunk.
    pub struct ChunkSnapshot {
        /// The X chunk coordinate.
        pub cx: i32,
        /// The Z chunk coordinate.
        pub cz: i32,
        /// The block, light and height map data of the chunk.
        pub chunk: Arc<Chunk>,
        /// The entities in that chunk, note that entities are not guaranteed to have a
        /// position that is within chunk boundaries.
        pub entities: Vec<Box<Entity>>,
        /// Block entities in that chunk, all block entities are mapped to their absolute
        /// coordinates in the world.
        pub block_entities: HashMap<IVec3, Box<BlockEntity>>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ChunkSnapshot {
        #[inline]
        fn clone(&self) -> ChunkSnapshot {
            ChunkSnapshot {
                cx: ::core::clone::Clone::clone(&self.cx),
                cz: ::core::clone::Clone::clone(&self.cz),
                chunk: ::core::clone::Clone::clone(&self.chunk),
                entities: ::core::clone::Clone::clone(&self.entities),
                block_entities: ::core::clone::Clone::clone(&self.block_entities),
            }
        }
    }
    impl ChunkSnapshot {
        /// Create a new empty chunk view of the given coordinates.
        pub fn new(cx: i32, cz: i32) -> Self {
            Self {
                cx,
                cz,
                chunk: Chunk::new(),
                entities: Vec::new(),
                block_entities: HashMap::new(),
            }
        }
    }
    /// This internal structure is used to keep data associated to a chunk coordinate X/Z.
    /// It could store chunk data, entities and block entities when present. If a world chunk
    /// does not contain data, it is considered **unloaded**. It is also impossible to get
    /// a snapshot of an unloaded chunk.
    ///
    /// Entities and block entities in **unloaded** chunks are no longer updated as soon as
    /// they enter that unloaded chunk.
    ///
    /// Note: cloning a chunk component will also clone the chunk's Arc, therefore the whole
    /// chunk content is actually cloned only when written to.
    struct ChunkComponent {
        /// Underlying chunk. This is important to understand why the data chunk is stored
        /// in an Atomically Reference-Counted container: first the chunk structure is large
        /// (around 80 KB) so we want it be stored in heap while the Arc container allows us
        /// to work with the chunk in a Clone-On-Write manner.
        ///
        /// In normal conditions, this chunk will not be shared and so it could be mutated
        /// using the [`Arc::get_mut`] method that allows mutating the Arc's value if only
        /// one reference exists. But there are situations when we want to have more
        /// references to that chunk data, for example when saving the chunk we'll temporarily
        /// create a Arc referencing this chunk and pass it to the threaded loader/saver.
        /// If the chunk is mutated while being saved, we'll just clone it and replace this
        /// Arc with a new one that, by definition, has only one reference, all of this based
        /// on the [`Arc::make_mut`] method. Depending on save being fast or not, this clone
        /// will be more or less likely to happen.
        data: Option<Arc<Chunk>>,
        /// Entities belonging to this chunk.
        entities: IndexMap<u32, usize>,
        /// Block entities belonging to this chunk.
        block_entities: HashMap<IVec3, usize>,
    }
    #[automatically_derived]
    impl ::core::default::Default for ChunkComponent {
        #[inline]
        fn default() -> ChunkComponent {
            ChunkComponent {
                data: ::core::default::Default::default(),
                entities: ::core::default::Default::default(),
                block_entities: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ChunkComponent {
        #[inline]
        fn clone(&self) -> ChunkComponent {
            ChunkComponent {
                data: ::core::clone::Clone::clone(&self.data),
                entities: ::core::clone::Clone::clone(&self.entities),
                block_entities: ::core::clone::Clone::clone(&self.block_entities),
            }
        }
    }
    /// Internal type for storing a world entity and keep track of its current chunk.
    struct EntityComponent {
        /// The entity storage.
        inner: Option<Box<Entity>>,
        /// Unique entity id is duplicated here to allow us to access it event when entity
        /// is updating.
        id: u32,
        /// The chunk X coordinate where this component is cached.
        cx: i32,
        /// The chunk Z coordinate where this component is cached.
        cz: i32,
        /// True when the chunk this entity is in is loaded with data.
        loaded: bool,
        /// This field describes the initial entity kind of the entity when spawned, it should
        /// not be changed afterward by ticking functions.
        kind: EntityKind,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EntityComponent {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &["inner", "id", "cx", "cz", "loaded", "kind"];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.inner,
                &self.id,
                &self.cx,
                &self.cz,
                &self.loaded,
                &&self.kind,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "EntityComponent",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EntityComponent {
        #[inline]
        fn clone(&self) -> EntityComponent {
            EntityComponent {
                inner: ::core::clone::Clone::clone(&self.inner),
                id: ::core::clone::Clone::clone(&self.id),
                cx: ::core::clone::Clone::clone(&self.cx),
                cz: ::core::clone::Clone::clone(&self.cz),
                loaded: ::core::clone::Clone::clone(&self.loaded),
                kind: ::core::clone::Clone::clone(&self.kind),
            }
        }
    }
    /// Internal type for storing a world block entity.
    struct BlockEntityComponent {
        /// The block entity storage.
        inner: Option<Box<BlockEntity>>,
        /// True when the chunk this block entity is in is loaded with data.
        loaded: bool,
        /// Position of that block entity.
        pos: IVec3,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for BlockEntityComponent {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "BlockEntityComponent",
                "inner",
                &self.inner,
                "loaded",
                &self.loaded,
                "pos",
                &&self.pos,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BlockEntityComponent {
        #[inline]
        fn clone(&self) -> BlockEntityComponent {
            BlockEntityComponent {
                inner: ::core::clone::Clone::clone(&self.inner),
                loaded: ::core::clone::Clone::clone(&self.loaded),
                pos: ::core::clone::Clone::clone(&self.pos),
            }
        }
    }
    /// A block tick position, this is always linked to a [`ScheduledTick`] being added to
    /// the tree map, this structure is also stored appart in order to check that two ticks
    /// are not scheduled for the same position and block id.
    struct BlockTickState {
        /// Position of the block to tick.
        pos: IVec3,
        /// The expected id of the block, if the block has no longer this id, this tick is
        /// ignored.
        id: u8,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BlockTickState {
        #[inline]
        fn clone(&self) -> BlockTickState {
            let _: ::core::clone::AssertParamIsClone<IVec3>;
            let _: ::core::clone::AssertParamIsClone<u8>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for BlockTickState {}
    #[automatically_derived]
    impl ::core::hash::Hash for BlockTickState {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.pos, state);
            ::core::hash::Hash::hash(&self.id, state)
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for BlockTickState {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for BlockTickState {
        #[inline]
        fn eq(&self, other: &BlockTickState) -> bool {
            self.pos == other.pos && self.id == other.id
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for BlockTickState {}
    #[automatically_derived]
    impl ::core::cmp::Eq for BlockTickState {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<IVec3>;
            let _: ::core::cmp::AssertParamIsEq<u8>;
        }
    }
    /// A block tick scheduled in the future, it's associated to a world time in a tree map.
    /// This structure is ordered by time and then by position, this allows to have multiple
    /// block update at the same time but for different positions.
    struct BlockTick {
        /// This tick unique id within the world.
        uid: u64,
        /// The time to tick the block.
        time: u64,
        /// State of that scheduled tick.
        state: BlockTickState,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BlockTick {
        #[inline]
        fn clone(&self) -> BlockTick {
            BlockTick {
                uid: ::core::clone::Clone::clone(&self.uid),
                time: ::core::clone::Clone::clone(&self.time),
                state: ::core::clone::Clone::clone(&self.state),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for BlockTick {}
    #[automatically_derived]
    impl ::core::cmp::Eq for BlockTick {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
            let _: ::core::cmp::AssertParamIsEq<BlockTickState>;
        }
    }
    impl PartialEq for BlockTick {
        fn eq(&self, other: &Self) -> bool {
            self.uid == other.uid && self.time == other.time
        }
    }
    impl PartialOrd for BlockTick {
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            Some(Ord::cmp(self, other))
        }
    }
    impl Ord for BlockTick {
        fn cmp(&self, other: &Self) -> Ordering {
            self.time.cmp(&other.time).then(self.uid.cmp(&other.uid))
        }
    }
    /// A light update to apply to the world.
    struct LightUpdate {
        /// Light kind targeted by this update, the update only applies to one of the kind.
        kind: LightKind,
        /// The position of the light update.
        pos: IVec3,
        /// Credit remaining to update light, this is used to limit the number of updates
        /// produced by a block chance initial update. Initial value is something like 15
        /// and decrease for each propagation, when it reaches 0 the light update stops
        /// propagating.
        credit: u8,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LightUpdate {
        #[inline]
        fn clone(&self) -> LightUpdate {
            LightUpdate {
                kind: ::core::clone::Clone::clone(&self.kind),
                pos: ::core::clone::Clone::clone(&self.pos),
                credit: ::core::clone::Clone::clone(&self.credit),
            }
        }
    }
    /// A tick vector is an internal structure used for both entities and block entities,
    /// it acts as a dynamically linked list where where the iteration order is defined before
    /// ticking and where insertion and removal of elements doesn't not affect the ordering.
    ///
    /// We use this complex data structure because we want to avoid most of the overhead when
    /// ticking entities and block entities, so we want to avoid moving entities (even the
    /// pointers) from/to stack too much. We also want to keep cache efficiency, this is why
    /// we recompute the linked list upon modifications in order to have a ascending pointer
    /// iteration by default, that may be invalidated if any value is removed.
    struct TickVec<T> {
        /// The inner vector containing all cells with inserted values.
        inner: Vec<TickCell<T>>,
        /// This boolean indicate if the any value has been insert or removed from the vector.
        /// This avoids recomputing the tick linked list on every tick reset.
        modified: bool,
        /// The index of the cell currently ticked.
        index: usize,
        /// Set to true if the cell currently ticked has been invalidated.
        invalidated: bool,
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone> ::core::clone::Clone for TickVec<T> {
        #[inline]
        fn clone(&self) -> TickVec<T> {
            TickVec {
                inner: ::core::clone::Clone::clone(&self.inner),
                modified: ::core::clone::Clone::clone(&self.modified),
                index: ::core::clone::Clone::clone(&self.index),
                invalidated: ::core::clone::Clone::clone(&self.invalidated),
            }
        }
    }
    /// A cell in the tick vector, its contains previous and next index of the cell to tick.
    struct TickCell<T> {
        /// The actual value stored.
        value: T,
        /// The index of the previous value to tick.
        /// Set to the cell index itself it there is no previous cell to tick.
        prev: usize,
        /// The index of the next value to tick.
        /// Set to the cell index itself it there is no previous cell to tick.
        next: usize,
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone> ::core::clone::Clone for TickCell<T> {
        #[inline]
        fn clone(&self) -> TickCell<T> {
            TickCell {
                value: ::core::clone::Clone::clone(&self.value),
                prev: ::core::clone::Clone::clone(&self.prev),
                next: ::core::clone::Clone::clone(&self.next),
            }
        }
    }
    /// A borrowed version of the tick vector, this is better than referencing the vector
    /// because it avoid one level of indirection.
    #[repr(transparent)]
    struct TickSlice<T>([TickCell<T>]);
    impl<T> TickVec<T> {
        /// This is our end of list sentinel.
        const END: usize = usize::MAX;
        /// Construct a new empty tick vector, this doesn't not allocate.
        #[inline]
        const fn new() -> Self {
            Self {
                inner: Vec::new(),
                modified: false,
                index: Self::END,
                invalidated: false,
            }
        }
        /// Push a new element at the end of this vector, the value index is also returned.
        #[inline]
        fn push(&mut self, value: T) -> usize {
            let index = self.inner.len();
            self.inner
                .push(TickCell {
                    value,
                    prev: Self::END,
                    next: Self::END,
                });
            self.modified = true;
            index
        }
        /// Invalid the value at the given index, therefore removing it from any tick linked
        /// list. If it is currently being updated
        fn invalidate(&mut self, index: usize) {
            let cell = &mut self.inner[index];
            let prev = mem::replace(&mut cell.prev, Self::END);
            let next = mem::replace(&mut cell.next, Self::END);
            if prev != Self::END {
                self.inner[prev].next = next;
            }
            if next != Self::END {
                self.inner[next].prev = prev;
            }
            if self.index == index {
                self.invalidated = true;
                self.index = next;
            }
        }
        /// Remove an element in this vector at the given index, the element is swapped with
        /// the last element of the vector.
        fn remove(&mut self, index: usize) -> T {
            self.invalidate(index);
            let cell = self.inner.swap_remove(index);
            let swapped_index = self.inner.len();
            if let Some(&TickCell { prev, next, .. }) = self.inner.get(index) {
                if prev != Self::END {
                    self.inner[prev].next = index;
                }
                if next != Self::END {
                    self.inner[next].prev = index;
                }
            }
            if self.index == swapped_index {
                self.index = index;
            }
            self.modified = true;
            cell.value
        }
        /// Reset the current tick index.
        fn reset(&mut self) {
            if self.inner.is_empty() {
                self.index = Self::END;
                return;
            }
            self.index = 0;
            if mem::take(&mut self.modified) {
                for i in 1..self.inner.len() {
                    self.inner[i - 1].next = i;
                    self.inner[i].prev = i - 1;
                }
                if let Some(cell) = self.inner.first_mut() {
                    cell.prev = Self::END;
                }
                if let Some(cell) = self.inner.last_mut() {
                    cell.next = Self::END;
                }
            }
        }
        /// Go to the next entity to tick.
        fn advance(&mut self) {
            if self.invalidated {
                self.invalidated = false;
            } else {
                if let Some(cell) = self.inner.get(self.index) {
                    self.index = cell.next;
                } else {
                    if true {
                        match (&self.index, &Self::END) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::None,
                                    );
                                }
                            }
                        };
                    }
                }
            }
        }
        /// Get the current value being ticked.
        #[inline]
        #[allow(unused)]
        fn current(&self) -> Option<(usize, &T)> {
            if self.invalidated {
                return None;
            }
            self.inner.get(self.index).map(|cell| (self.index, &cell.value))
        }
        /// Get the current value being ticked through as mutable reference.
        #[inline]
        fn current_mut(&mut self) -> Option<(usize, &mut T)> {
            if self.invalidated {
                return None;
            }
            self.inner.get_mut(self.index).map(|cell| (self.index, &mut cell.value))
        }
    }
    impl<T> TickSlice<T> {
        #[inline]
        fn len(&self) -> usize {
            self.0.len()
        }
        #[inline]
        #[allow(unused)]
        fn is_empty(&self) -> bool {
            self.0.is_empty()
        }
        #[inline]
        fn get(&self, index: usize) -> Option<&T> {
            self.0.get(index).map(|cell| &cell.value)
        }
        #[inline]
        fn get_mut(&mut self, index: usize) -> Option<&mut T> {
            self.0.get_mut(index).map(|cell| &mut cell.value)
        }
        #[inline]
        fn iter(&self) -> TickIter<'_, T> {
            TickIter { inner: self.0.iter() }
        }
        #[inline]
        fn iter_mut(&mut self) -> TickIterMut<'_, T> {
            TickIterMut {
                inner: self.0.iter_mut(),
            }
        }
    }
    impl<T> Deref for TickVec<T> {
        type Target = TickSlice<T>;
        #[inline]
        fn deref(&self) -> &Self::Target {
            let slice = &self.inner[..];
            unsafe { &*(slice as *const [TickCell<T>] as *const TickSlice<T>) }
        }
    }
    impl<T> DerefMut for TickVec<T> {
        #[inline]
        fn deref_mut(&mut self) -> &mut Self::Target {
            let slice = &mut self.inner[..];
            unsafe { &mut *(slice as *mut [TickCell<T>] as *mut TickSlice<T>) }
        }
    }
    struct TickIter<'a, T> {
        inner: slice::Iter<'a, TickCell<T>>,
    }
    impl<T> FusedIterator for TickIter<'_, T> {}
    impl<'a, T> Iterator for TickIter<'a, T> {
        type Item = &'a T;
        #[inline]
        fn next(&mut self) -> Option<Self::Item> {
            self.inner.next().map(|cell| &cell.value)
        }
    }
    struct TickIterMut<'a, T> {
        inner: slice::IterMut<'a, TickCell<T>>,
    }
    impl<T> FusedIterator for TickIterMut<'_, T> {}
    impl<'a, T> Iterator for TickIterMut<'a, T> {
        type Item = &'a mut T;
        #[inline]
        fn next(&mut self) -> Option<Self::Item> {
            self.inner.next().map(|cell| &mut cell.value)
        }
    }
    /// An iterator for blocks in a world area.
    /// This yields the block position, id and metadata.
    pub struct BlocksInIter<'a> {
        /// Back-reference to the containing world.
        world: &'a World,
        /// This contains a temporary reference to the chunk being analyzed. This is used to
        /// avoid repeatedly fetching chunks' map.
        chunk: Option<(i32, i32, Option<&'a Chunk>)>,
        /// Minimum coordinate to fetch.
        start: IVec3,
        /// Maximum coordinate to fetch (exclusive).
        end: IVec3,
        /// Next block to fetch.
        cursor: IVec3,
    }
    impl<'a> BlocksInIter<'a> {
        #[inline]
        fn new(world: &'a World, mut start: IVec3, mut end: IVec3) -> Self {
            if true {
                if !(start.x <= end.x && start.y <= end.y && start.z <= end.z) {
                    ::core::panicking::panic(
                        "assertion failed: start.x <= end.x && start.y <= end.y && start.z <= end.z",
                    )
                }
            }
            start.y = start.y.clamp(0, CHUNK_HEIGHT as i32 - 1);
            end.y = end.y.clamp(0, CHUNK_HEIGHT as i32 - 1);
            if start.x == end.x || start.y == end.y || start.z == end.z {
                end = start;
            }
            Self {
                world,
                chunk: None,
                start,
                end,
                cursor: start,
            }
        }
    }
    impl FusedIterator for BlocksInIter<'_> {}
    impl Iterator for BlocksInIter<'_> {
        type Item = (IVec3, u8, u8);
        fn next(&mut self) -> Option<Self::Item> {
            if self.cursor.x == self.end.x {
                return None;
            }
            if self.cursor.y == self.start.y {
                let (cx, cz) = calc_chunk_pos_unchecked(self.cursor);
                if !match self.chunk {
                    Some((ccx, ccz, _)) if (ccx, ccz) == (cx, cz) => true,
                    _ => false,
                } {
                    self.chunk = Some((cx, cz, self.world.get_chunk(cx, cz)));
                }
            }
            let mut ret = (self.cursor, 0, 0);
            if let Some((_, _, Some(chunk))) = self.chunk {
                let (block, metadata) = chunk.get_block(self.cursor);
                ret.1 = block;
                ret.2 = metadata;
            }
            self.cursor.y += 1;
            if self.cursor.y == self.end.y {
                self.cursor.y = self.start.y;
                self.cursor.z += 1;
                if self.cursor.z == self.end.z {
                    self.cursor.z = self.start.z;
                    self.cursor.x += 1;
                }
            }
            Some(ret)
        }
    }
    /// An iterator for blocks in a world chunk.
    pub struct BlocksInChunkIter<'a> {
        /// Back-reference to the containing world. None if the chunk doesn't exists or the
        /// iterator is exhausted.
        chunk: Option<&'a Chunk>,
        /// Current position that is iterated in the chunk.
        cursor: IVec3,
    }
    impl<'a> BlocksInChunkIter<'a> {
        #[inline]
        fn new(world: &'a World, cx: i32, cz: i32) -> Self {
            Self {
                chunk: world.get_chunk(cx, cz),
                cursor: IVec3::new(cx * CHUNK_WIDTH as i32, 0, cz * CHUNK_WIDTH as i32),
            }
        }
    }
    impl FusedIterator for BlocksInChunkIter<'_> {}
    impl Iterator for BlocksInChunkIter<'_> {
        type Item = (IVec3, u8, u8);
        #[inline]
        fn next(&mut self) -> Option<Self::Item> {
            let (block, metadata) = self.chunk?.get_block(self.cursor);
            let ret = (self.cursor, block, metadata);
            self.cursor.y += 1;
            if self.cursor.y >= CHUNK_HEIGHT as i32 {
                self.cursor.y = 0;
                self.cursor.z += 1;
                if self.cursor.z & 0b1111 == 0 {
                    self.cursor.z -= 16;
                    self.cursor.x += 1;
                    if self.cursor.x & 0b1111 == 0 {
                        self.chunk = None;
                    }
                }
            }
            Some(ret)
        }
    }
    /// An iterator over all entities in the world.
    pub struct EntitiesIter<'a>(TickIter<'a, EntityComponent>);
    impl FusedIterator for EntitiesIter<'_> {}
    impl ExactSizeIterator for EntitiesIter<'_> {}
    impl<'a> Iterator for EntitiesIter<'a> {
        type Item = (u32, &'a Entity);
        #[inline]
        fn next(&mut self) -> Option<Self::Item> {
            while let Some(comp) = self.0.next() {
                if let Some(ret) = comp.inner.as_deref() {
                    return Some((comp.id, ret));
                }
            }
            None
        }
        #[inline]
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.0.size_hint()
        }
    }
    /// An iterator over all entities in the world through mutable references.
    pub struct EntitiesIterMut<'a>(TickIterMut<'a, EntityComponent>);
    impl FusedIterator for EntitiesIterMut<'_> {}
    impl ExactSizeIterator for EntitiesIterMut<'_> {}
    impl<'a> Iterator for EntitiesIterMut<'a> {
        type Item = (u32, &'a mut Entity);
        #[inline]
        fn next(&mut self) -> Option<Self::Item> {
            while let Some(comp) = self.0.next() {
                if let Some(ret) = comp.inner.as_deref_mut() {
                    return Some((comp.id, ret));
                }
            }
            None
        }
        #[inline]
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.0.size_hint()
        }
    }
    /// An iterator of player entities in the world.
    pub type PlayerEntitiesIter<'a> = EntitiesInChunkIter<'a>;
    /// An iterator of player entities in the world through mutable references.
    pub type PlayerEntitiesIterMut<'a> = EntitiesInChunkIterMut<'a>;
    /// An iterator of entities within a chunk.
    pub struct EntitiesInChunkIter<'a> {
        /// The entities indices, returned indices are unique within the iterator.
        indices: Option<indexmap::map::Values<'a, u32, usize>>,
        /// The entities.
        entities: &'a TickSlice<EntityComponent>,
    }
    impl FusedIterator for EntitiesInChunkIter<'_> {}
    impl<'a> Iterator for EntitiesInChunkIter<'a> {
        type Item = (u32, &'a Entity);
        #[inline]
        fn next(&mut self) -> Option<Self::Item> {
            while let Some(&index) = self.indices.as_mut()?.next() {
                let comp = self.entities.get(index).unwrap();
                if let Some(entity) = comp.inner.as_deref() {
                    return Some((comp.id, entity));
                }
            }
            None
        }
        #[inline]
        fn size_hint(&self) -> (usize, Option<usize>) {
            if let Some(indices) = &self.indices {
                indices.size_hint()
            } else {
                (0, Some(0))
            }
        }
    }
    /// An iterator of entities within a chunk through mutable references.
    pub struct EntitiesInChunkIterMut<'a> {
        /// The entities indices, returned indices are unique within the iterator.
        indices: Option<indexmap::map::Values<'a, u32, usize>>,
        /// The entities.
        entities: &'a mut TickSlice<EntityComponent>,
        /// Only used when debug assertions are enabled in order to ensure the safety
        /// of the lifetime transmutation.
        #[cfg(debug_assertions)]
        returned_pointers: HashSet<*mut Entity>,
    }
    impl FusedIterator for EntitiesInChunkIterMut<'_> {}
    impl<'a> Iterator for EntitiesInChunkIterMut<'a> {
        type Item = (u32, &'a mut Entity);
        #[inline]
        fn next(&mut self) -> Option<Self::Item> {
            while let Some(&index) = self.indices.as_mut()?.next() {
                let comp = self.entities.get_mut(index).unwrap();
                if let Some(entity) = comp.inner.as_deref_mut() {
                    #[cfg(debug_assertions)]
                    {
                        if !self.returned_pointers.insert(entity) {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!("wrong unsafe contract"),
                                );
                            }
                        }
                    }
                    let entity = unsafe { &mut *(entity as *mut Entity) };
                    return Some((comp.id, entity));
                }
            }
            None
        }
        #[inline]
        fn size_hint(&self) -> (usize, Option<usize>) {
            if let Some(indices) = &self.indices {
                indices.size_hint()
            } else {
                (0, Some(0))
            }
        }
    }
    /// An iterator of entities that collide with a bounding box.
    pub struct EntitiesCollidingIter<'a> {
        /// Chunk components iter whens indices is exhausted.
        chunks: ChunkComponentsIter<'a>,
        /// The entities indices, returned indices are unique within the iterator.
        indices: Option<indexmap::map::Values<'a, u32, usize>>,
        /// The entities.
        entities: &'a TickSlice<EntityComponent>,
        /// Bounding box to check.
        bb: BoundingBox,
    }
    impl FusedIterator for EntitiesCollidingIter<'_> {}
    impl<'a> Iterator for EntitiesCollidingIter<'a> {
        type Item = (u32, &'a Entity);
        #[inline]
        fn next(&mut self) -> Option<Self::Item> {
            loop {
                if self.indices.is_none() {
                    self.indices = Some(self.chunks.next()?.entities.values());
                }
                if let Some(&index) = self.indices.as_mut().unwrap().next() {
                    let comp = self.entities.get(index).unwrap();
                    if let Some(entity) = comp.inner.as_deref() {
                        if entity.0.bb.intersects(self.bb) {
                            return Some((comp.id, entity));
                        }
                    }
                } else {
                    self.indices = None;
                }
            }
        }
    }
    /// An iterator of entities that collide with a bounding box through mutable references.
    pub struct EntitiesCollidingIterMut<'a> {
        /// Chunk components iter whens indices is exhausted.
        chunks: ChunkComponentsIter<'a>,
        /// The entities indices, returned indices are unique within the iterator.
        indices: Option<indexmap::map::Values<'a, u32, usize>>,
        /// The entities.
        entities: &'a mut TickSlice<EntityComponent>,
        /// Bounding box to check.
        bb: BoundingBox,
        /// Only used when debug assertions are enabled in order to ensure the safety
        /// of the lifetime transmutation.
        #[cfg(debug_assertions)]
        returned_pointers: HashSet<*mut Entity>,
    }
    impl FusedIterator for EntitiesCollidingIterMut<'_> {}
    impl<'a> Iterator for EntitiesCollidingIterMut<'a> {
        type Item = (u32, &'a mut Entity);
        #[inline]
        fn next(&mut self) -> Option<Self::Item> {
            loop {
                if self.indices.is_none() {
                    self.indices = Some(self.chunks.next()?.entities.values());
                }
                if let Some(&index) = self.indices.as_mut().unwrap().next() {
                    let comp = self.entities.get_mut(index).unwrap();
                    if let Some(entity) = comp.inner.as_deref_mut() {
                        if entity.0.bb.intersects(self.bb) {
                            #[cfg(debug_assertions)]
                            {
                                if !self.returned_pointers.insert(entity) {
                                    {
                                        ::core::panicking::panic_fmt(
                                            format_args!("wrong unsafe contract"),
                                        );
                                    }
                                }
                            }
                            let entity = unsafe { &mut *(entity as *mut Entity) };
                            return Some((comp.id, entity));
                        }
                    }
                } else {
                    self.indices = None;
                }
            }
        }
    }
    /// Internal iterator chunk components in a range.
    struct ChunkComponentsIter<'a> {
        /// Map of chunk components that we
        chunks: &'a HashMap<(i32, i32), ChunkComponent>,
        /// The range of chunks to iterate on.
        range: ChunkRange,
    }
    impl FusedIterator for ChunkComponentsIter<'_> {}
    impl<'a> Iterator for ChunkComponentsIter<'a> {
        type Item = &'a ChunkComponent;
        #[inline]
        fn next(&mut self) -> Option<Self::Item> {
            while let Some((cx, cz)) = self.range.next() {
                if let Some(comp) = self.chunks.get(&(cx, cz)) {
                    return Some(comp);
                }
            }
            None
        }
    }
    /// Internal iterator of chunk coordinates, both start and end are inclusive.
    struct ChunkRange {
        cx: i32,
        cz: i32,
        start_cx: i32,
        end_cx: i32,
        end_cz: i32,
    }
    impl ChunkRange {
        #[inline]
        fn new(start_cx: i32, start_cz: i32, end_cx: i32, end_cz: i32) -> Self {
            Self {
                cx: start_cx,
                cz: start_cz,
                start_cx,
                end_cx,
                end_cz,
            }
        }
    }
    impl FusedIterator for ChunkRange {}
    impl Iterator for ChunkRange {
        type Item = (i32, i32);
        #[inline]
        fn next(&mut self) -> Option<Self::Item> {
            if self.cx > self.end_cx || self.cz > self.end_cz {
                return None;
            }
            let ret = (self.cx, self.cz);
            self.cx += 1;
            if self.cx > self.end_cx {
                self.cx = self.start_cx;
                self.cz += 1;
            }
            Some(ret)
        }
    }
}
pub mod storage {
    //! A thread-based world storage manager with chunk generation support for non-existing
    //! chunks. The current implementation use a single worker for region or features
    //! generation and many workers for terrain generation.
    use std::collections::HashSet;
    use std::collections::hash_map::Entry;
    use std::sync::atomic::AtomicU64;
    use std::sync::atomic::Ordering;
    use std::collections::HashMap;
    use std::path::PathBuf;
    use std::time::Instant;
    use std::sync::Arc;
    use std::thread;
    use std::io;
    use crossbeam_channel::TryRecvError;
    use crossbeam_channel::unbounded;
    use crossbeam_channel::{select, bounded, Sender, Receiver, RecvError};
    use crate::serde::nbt::NbtError;
    use crate::serde::nbt::NbtParseError;
    use crate::serde::region::{RegionDir, RegionError};
    use crate::world::{ChunkSnapshot, World};
    use crate::gen::ChunkGenerator;
    use crate::world::Dimension;
    use crate::chunk::Chunk;
    const POPULATED_NEG_NEG: u8 = 0b0001;
    const POPULATED_POS_NEG: u8 = 0b0010;
    const POPULATED_NEG_POS: u8 = 0b0100;
    const POPULATED_POS_POS: u8 = 0b1000;
    const POPULATED_ALL: u8 = 0b1111;
    const POPULATED_NEG_X: u8 = POPULATED_NEG_NEG | POPULATED_NEG_POS;
    const POPULATED_POS_X: u8 = POPULATED_POS_POS | POPULATED_POS_NEG;
    const POPULATED_NEG_Z: u8 = POPULATED_NEG_NEG | POPULATED_POS_NEG;
    const POPULATED_POS_Z: u8 = POPULATED_POS_POS | POPULATED_NEG_POS;
    /// This structure is a handle around a chunk storage.
    pub struct ChunkStorage {
        /// Request sender to storage worker.
        storage_request_sender: Sender<StorageRequest>,
        /// Reply receiver from storage worker.
        storage_reply_receiver: Receiver<ChunkStorageReply>,
        /// Set of requested chunk loads.
        request_load: HashSet<(i32, i32)>,
        /// Set of requested chunk saves.
        request_save: HashSet<(i32, i32)>,
    }
    /// The storage worker is the entry point where commands arrives, it dispatch terrain
    /// generation if needed in order to later
    struct StorageWorker<G: ChunkGenerator> {
        /// The shared generator.
        generator: Arc<G>,
        /// The non-shared state of the generator.
        state: G::State,
        /// An internal world used to generate features after terrain generation of chunks.
        world: World,
        /// Populated status of chunks.
        chunks_populated: HashMap<(i32, i32), u8>,
        /// The region directory to try loading required chunks.
        region_dir: RegionDir,
        /// Request receiver from the handle.
        storage_request_receiver: Receiver<StorageRequest>,
        /// Reply sender to the handle.
        storage_reply_sender: Sender<ChunkStorageReply>,
        /// Request sender to the terrain worker.
        terrain_request_sender: Sender<TerrainRequest>,
        /// Reply receiver from the handle.
        terrain_reply_receiver: Receiver<TerrainReply>,
        /// Internal statistics tracker.
        stats: Arc<Stats>,
    }
    /// The chunk worker is responsible of generating the biomes and terrain.
    struct TerrainWorker<G: ChunkGenerator> {
        /// The shared generator.
        generator: Arc<G>,
        /// The non-shared state of the generator.
        state: G::State,
        /// Request receiver from storage worker.
        terrain_request_receiver: Receiver<TerrainRequest>,
        /// Reply sender to storage worker.
        terrain_reply_sender: Sender<TerrainReply>,
        /// Internal statistics tracker.
        stats: Arc<Stats>,
    }
    /// Internal statistics about performance of chunk generation and request to load times.
    struct Stats {
        /// Total duration of gen_terrain, in s.
        gen_terrain_duration: AtomicU64,
        /// Number of samples added to 'gen_terrain_duration'.
        gen_terrain_count: AtomicU64,
        /// Total duration of gen_features, in s.
        gen_features_duration: AtomicU64,
        /// Number of samples added to 'gen_features_duration'.
        gen_features_count: AtomicU64,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Stats {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Stats",
                "gen_terrain_duration",
                &self.gen_terrain_duration,
                "gen_terrain_count",
                &self.gen_terrain_count,
                "gen_features_duration",
                &self.gen_features_duration,
                "gen_features_count",
                &&self.gen_features_count,
            )
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Stats {
        #[inline]
        fn default() -> Stats {
            Stats {
                gen_terrain_duration: ::core::default::Default::default(),
                gen_terrain_count: ::core::default::Default::default(),
                gen_features_duration: ::core::default::Default::default(),
                gen_features_count: ::core::default::Default::default(),
            }
        }
    }
    impl ChunkStorage {
        /// Create a new chunk storage backed by the given terrain workers count.
        pub fn new<P, G>(region_dir: P, generator: G, terrain_workers: usize) -> Self
        where
            P: Into<PathBuf>,
            G: ChunkGenerator + Sync + Send + 'static,
        {
            let (storage_request_sender, storage_request_receiver) = unbounded();
            let (storage_reply_sender, storage_reply_receiver) = bounded(100);
            let (terrain_request_sender, terrain_request_receiver) = unbounded();
            let (terrain_reply_sender, terrain_reply_receiver) = bounded(
                100 * terrain_workers,
            );
            let region_dir: PathBuf = region_dir.into();
            let generator = Arc::new(generator);
            let stats = Arc::new(Stats::default());
            for i in 0..terrain_workers {
                let worker_generator = Arc::clone(&generator);
                let terrain_request_receiver = terrain_request_receiver.clone();
                let terrain_reply_sender = terrain_reply_sender.clone();
                let worker_stats = Arc::clone(&stats);
                thread::Builder::new()
                    .name({
                        let res = ::alloc::fmt::format(
                            format_args!("Chunk Terrain Worker #{0}", i),
                        );
                        res
                    })
                    .spawn(move || {
                        TerrainWorker {
                            generator: worker_generator,
                            state: G::State::default(),
                            terrain_request_receiver,
                            terrain_reply_sender,
                            stats: worker_stats,
                        }
                            .run()
                    })
                    .unwrap();
            }
            thread::Builder::new()
                .name({
                    let res = ::alloc::fmt::format(format_args!("Chunk Storage Worker"));
                    res
                })
                .spawn(move || {
                    StorageWorker {
                        generator,
                        state: G::State::default(),
                        world: World::new(Dimension::Overworld),
                        chunks_populated: HashMap::new(),
                        region_dir: RegionDir::new(region_dir),
                        storage_request_receiver,
                        storage_reply_sender,
                        terrain_request_sender,
                        terrain_reply_receiver,
                        stats,
                    }
                        .run()
                })
                .unwrap();
            Self {
                storage_request_sender,
                storage_reply_receiver,
                request_load: HashSet::new(),
                request_save: HashSet::new(),
            }
        }
        /// Request loading of a chunk, that will later be returned by polling this storage.
        pub fn request_load(&mut self, cx: i32, cz: i32) {
            self.request_load.insert((cx, cz));
            self.storage_request_sender
                .send(StorageRequest::Load { cx, cz })
                .expect("worker should not disconnect while this handle exists");
        }
        /// Request saving of the given chunk snapshot.
        pub fn request_save(&mut self, snapshot: ChunkSnapshot) {
            self.request_save.insert((snapshot.cx, snapshot.cz));
            self.storage_request_sender
                .send(StorageRequest::Save { snapshot })
                .expect("worker should not disconnect while this handle exists");
        }
        /// Poll without blocking this storage for new reply to requested load and save.
        /// This function returns none if there is not new reply to poll.
        pub fn poll(&mut self) -> Option<ChunkStorageReply> {
            match self.storage_reply_receiver.try_recv() {
                Ok(reply) => {
                    match reply {
                        ChunkStorageReply::Load { cx, cz, .. } => {
                            self.request_load.remove(&(cx, cz))
                        }
                        ChunkStorageReply::Save { cx, cz, .. } => {
                            self.request_save.remove(&(cx, cz))
                        }
                    };
                    Some(reply)
                }
                Err(TryRecvError::Empty) => None,
                Err(TryRecvError::Disconnected) => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "worker should not disconnect while this handle exists",
                        ),
                    );
                }
            }
        }
        /// Number of requested chunk loads pending.
        #[inline]
        pub fn request_load_count(&self) -> usize {
            self.request_load.len()
        }
        /// Number of requested chunk saves pending.
        #[inline]
        pub fn request_save_count(&self) -> usize {
            self.request_save.len()
        }
    }
    impl<G: ChunkGenerator> StorageWorker<G> {
        fn run(mut self) {
            while let Ok(true) = self.handle() {}
        }
        /// Handle a channel message, return Ok(true) to continue and Ok(false) to stop
        /// thread, this is used to stop if any channel error happens.
        fn handle(&mut self) -> Result<bool, RecvError> {
            Ok({
                const _LEN: usize = 1 + (1 + 0);
                let _handle: &::crossbeam_channel::internal::SelectHandle = &::crossbeam_channel::never::<
                    (),
                >();
                #[allow(unused_mut)]
                let mut _sel = [(_handle, 0, ::std::ptr::null()); _LEN];
                {
                    match self.storage_request_receiver {
                        ref _r => {
                            let _oper0: &::crossbeam_channel::Receiver<_> = unsafe {
                                let _r: &::crossbeam_channel::Receiver<_> = _r;
                                unsafe fn unbind<'a, T>(x: &T) -> &'a T {
                                    ::std::mem::transmute(x)
                                }
                                unbind(_r)
                            };
                            _sel[0usize] = (
                                _oper0,
                                0usize,
                                _oper0 as *const ::crossbeam_channel::Receiver<_>
                                    as *const u8,
                            );
                            {
                                match self.terrain_reply_receiver {
                                    ref _r => {
                                        let _oper1: &::crossbeam_channel::Receiver<_> = unsafe {
                                            let _r: &::crossbeam_channel::Receiver<_> = _r;
                                            unsafe fn unbind<'a, T>(x: &T) -> &'a T {
                                                ::std::mem::transmute(x)
                                            }
                                            unbind(_r)
                                        };
                                        _sel[1usize] = (
                                            _oper1,
                                            1usize,
                                            _oper1 as *const ::crossbeam_channel::Receiver<_>
                                                as *const u8,
                                        );
                                        {
                                            let _oper: ::crossbeam_channel::SelectedOperation<'_> = {
                                                let _oper = ::crossbeam_channel::internal::select(
                                                    &mut _sel,
                                                );
                                                unsafe { ::std::mem::transmute(_oper) }
                                            };
                                            {
                                                if _oper.index() == 0usize {
                                                    let _res = _oper.recv(_oper0);
                                                    { _sel };
                                                    let request = _res;
                                                    { self.handle_storage_request(request?) }
                                                } else {
                                                    {
                                                        if _oper.index() == 1usize {
                                                            let _res = _oper.recv(_oper1);
                                                            { _sel };
                                                            let reply = _res;
                                                            { self.receive_terrain_reply(reply?) }
                                                        } else {
                                                            {
                                                                {
                                                                    ::core::panicking::unreachable_display(
                                                                        &"internal error in crossbeam-channel: invalid case",
                                                                    );
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            })
        }
        fn handle_storage_request(&mut self, request: StorageRequest) -> bool {
            match request {
                StorageRequest::Load { cx, cz } => self.load_or_gen(cx, cz),
                StorageRequest::Save { snapshot } => self.save(&snapshot),
            }
        }
        fn receive_terrain_reply(&mut self, reply: TerrainReply) -> bool {
            match reply {
                TerrainReply::Load { cx, cz, chunk } => {
                    self.insert_terrain(cx, cz, chunk)
                }
            }
        }
        /// Internal function to try loading a chunk from region file, if the chunk is not
        /// found, its generation is requested to terrain workers. But if a critical error
        /// is returned by the region file then an error is returned. This avoid overwriting
        /// the chunk later and ruining a possibly recoverable error.
        fn load_or_gen(&mut self, cx: i32, cz: i32) -> bool {
            match self.try_load(cx, cz) {
                Err(err) => {
                    self.storage_reply_sender
                        .send(ChunkStorageReply::Load {
                            cx,
                            cz,
                            res: Err(err),
                        })
                        .is_ok()
                }
                Ok(Some(snapshot)) => {
                    self.storage_reply_sender
                        .send(ChunkStorageReply::Load {
                            cx,
                            cz,
                            res: Ok(snapshot),
                        })
                        .is_ok()
                }
                Ok(None) => {
                    self.request_full(cx, cz);
                    true
                }
            }
        }
        /// Try loading a chunk from region file.
        fn try_load(
            &mut self,
            cx: i32,
            cz: i32,
        ) -> Result<Option<ChunkSnapshot>, StorageError> {
            let region = match self.region_dir.ensure_region(cx, cz, false) {
                Ok(region) => region,
                Err(RegionError::Io(err)) if err.kind() == io::ErrorKind::NotFound => {
                    return Ok(None);
                }
                Err(err) => return Err(StorageError::Region(err)),
            };
            let reader = match region.read_chunk(cx, cz) {
                Ok(chunk) => chunk,
                Err(RegionError::EmptyChunk) => return Ok(None),
                Err(err) => return Err(StorageError::Region(err)),
            };
            let root_tag = crate::serde::nbt::from_reader(reader)?;
            let mut snapshot = crate::serde::chunk::from_nbt(&root_tag)?;
            let chunk = Arc::get_mut(&mut snapshot.chunk).unwrap();
            self.generator.gen_biomes(cx, cz, chunk, &mut self.state);
            Ok(Some(snapshot))
        }
        /// Request full generation of a chunk to terrain workers, in order to fully generate
        /// a chunk, its terrain must be generated along with all of its corner being
        /// populated by features.
        fn request_full(&mut self, cx: i32, cz: i32) {
            let populated = self.chunks_populated.get(&(cx, cz)).copied().unwrap_or(0);
            match (&populated, &POPULATED_ALL) {
                (left_val, right_val) => {
                    if *left_val == *right_val {
                        let kind = ::core::panicking::AssertKind::Ne;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            };
            let mut min_cx = cx;
            let mut min_cz = cz;
            let mut max_cx = cx;
            let mut max_cz = cz;
            if populated & POPULATED_NEG_X != POPULATED_NEG_X {
                min_cx -= 1;
            }
            if populated & POPULATED_POS_X != POPULATED_POS_X {
                max_cx += 1;
            }
            if populated & POPULATED_NEG_Z != POPULATED_NEG_Z {
                min_cz -= 1;
            }
            if populated & POPULATED_POS_Z != POPULATED_POS_Z {
                max_cz += 1;
            }
            for terrain_cx in min_cx..=max_cx {
                for terrain_cz in min_cz..=max_cz {
                    if let Entry::Vacant(v) = self
                        .chunks_populated
                        .entry((terrain_cx, terrain_cz))
                    {
                        self.terrain_request_sender
                            .send(TerrainRequest::Load {
                                cx: terrain_cx,
                                cz: terrain_cz,
                            })
                            .expect(
                                "terrain worker should not disconnect while this worker exists",
                            );
                        v.insert(0);
                    }
                }
            }
        }
        /// Insert a terrain chunk that have just been returned by a terrain worker.
        fn insert_terrain(&mut self, cx: i32, cz: i32, chunk: Arc<Chunk>) -> bool {
            let populated = self
                .chunks_populated
                .get_mut(&(cx, cz))
                .expect("chunk state should be present if terrain has been requested");
            match (&*populated, &0) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::Some(
                                format_args!(
                                    "requested terrain chunk should have no populated corner",
                                ),
                            ),
                        );
                    }
                }
            };
            if !!self.world.contains_chunk(cx, cz) {
                {
                    ::core::panicking::panic_fmt(
                        format_args!("requested terrain chunk is already present"),
                    );
                }
            }
            self.world.set_chunk(cx, cz, chunk);
            let mut contains = [[false; 3]; 3];
            contains[1][1] = true;
            for dcx in 0..3 {
                for dcz in 0..3 {
                    if (dcx, dcz) != (1, 1) {
                        if self
                            .world
                            .contains_chunk(cx + dcx as i32 - 1, cz + dcz as i32 - 1)
                        {
                            contains[dcx][dcz] = true;
                        }
                    }
                }
            }
            let mut new_populated = [[0u8; 3]; 3];
            for dcx in 0..2 {
                for dcz in 0..2 {
                    let mut neighbor_count = 0;
                    for neighbor_dcx in 0..2 {
                        for neighbor_dcz in 0..2 {
                            if contains[dcx + neighbor_dcx][dcz + neighbor_dcz] {
                                neighbor_count += 1;
                            }
                        }
                    }
                    if neighbor_count != 4 {
                        continue;
                    }
                    let current_cx = cx + dcx as i32 - 1;
                    let current_cz = cz + dcz as i32 - 1;
                    let start = Instant::now();
                    self.generator
                        .gen_features(
                            current_cx,
                            current_cz,
                            &mut self.world,
                            &mut self.state,
                        );
                    let duration = start.elapsed();
                    self.stats
                        .gen_features_duration
                        .fetch_add(duration.as_micros() as u64, Ordering::Relaxed);
                    self.stats.gen_features_count.fetch_add(1, Ordering::Relaxed);
                    new_populated[dcx][dcz] |= POPULATED_POS_POS;
                    new_populated[dcx + 1][dcz] |= POPULATED_NEG_POS;
                    new_populated[dcx][dcz + 1] |= POPULATED_POS_NEG;
                    new_populated[dcx + 1][dcz + 1] |= POPULATED_NEG_NEG;
                }
            }
            for dcx in 0..3 {
                for dcz in 0..3 {
                    let populated_mask = new_populated[dcx][dcz];
                    if populated_mask != 0 {
                        let current_cx = cx + dcx as i32 - 1;
                        let current_cz = cz + dcz as i32 - 1;
                        let populated = self
                            .chunks_populated
                            .get_mut(&(current_cx, current_cz))
                            .expect("chunk should be existing at this point");
                        *populated |= populated_mask;
                        if *populated & POPULATED_ALL == POPULATED_ALL {
                            self.chunks_populated.remove(&(current_cx, current_cz));
                            let snapshot = self
                                .world
                                .remove_chunk_snapshot(current_cx, current_cz)
                                .expect("chunk should be existing and snapshot possible");
                            if !self.save(&snapshot) {
                                return false;
                            }
                            if self
                                .storage_reply_sender
                                .send(ChunkStorageReply::Load {
                                    cx,
                                    cz,
                                    res: Ok(snapshot),
                                })
                                .is_err()
                            {
                                return false;
                            }
                        }
                    }
                }
            }
            true
        }
        /// Save a chunk snapshot. Returning false if the reply channel is broken.
        fn save(&mut self, snapshot: &ChunkSnapshot) -> bool {
            let (cx, cz) = (snapshot.cx, snapshot.cz);
            match self.try_save(snapshot) {
                Err(err) => {
                    self.storage_reply_sender
                        .send(ChunkStorageReply::Save {
                            cx,
                            cz,
                            res: Err(err),
                        })
                        .is_ok()
                }
                Ok(()) => {
                    self.storage_reply_sender
                        .send(ChunkStorageReply::Save {
                            cx,
                            cz,
                            res: Ok(()),
                        })
                        .is_ok()
                }
            }
        }
        /// Save a chunk snapshot and return result about success.
        fn try_save(&mut self, snapshot: &ChunkSnapshot) -> Result<(), StorageError> {
            let (cx, cz) = (snapshot.cx, snapshot.cz);
            let region = self.region_dir.ensure_region(cx, cz, true)?;
            let mut writer = region.write_chunk(cx, cz);
            let root_tag = crate::serde::chunk::to_nbt(snapshot);
            crate::serde::nbt::to_writer(&mut writer, &root_tag)?;
            writer.flush_chunk()?;
            Ok(())
        }
    }
    impl<G: ChunkGenerator> TerrainWorker<G> {
        fn run(mut self) {
            while let Ok(request) = self.terrain_request_receiver.recv() {
                match request {
                    TerrainRequest::Load { cx, cz } => {
                        let mut chunk = Chunk::new();
                        let chunk_access = Arc::get_mut(&mut chunk).unwrap();
                        let start = Instant::now();
                        self.generator
                            .gen_terrain(cx, cz, chunk_access, &mut self.state);
                        let duration = start.elapsed();
                        self.stats
                            .gen_terrain_duration
                            .fetch_add(duration.as_micros() as u64, Ordering::Relaxed);
                        self.stats.gen_terrain_count.fetch_add(1, Ordering::Relaxed);
                        if self
                            .terrain_reply_sender
                            .send(TerrainReply::Load {
                                cx,
                                cz,
                                chunk,
                            })
                            .is_err()
                        {
                            break;
                        }
                    }
                }
            }
        }
    }
    enum StorageRequest {
        Load { cx: i32, cz: i32 },
        Save { snapshot: ChunkSnapshot },
    }
    /// A reply from the storage for a previously requested chunk loading or saving.
    pub enum ChunkStorageReply {
        Load { cx: i32, cz: i32, res: Result<ChunkSnapshot, StorageError> },
        Save { cx: i32, cz: i32, res: Result<(), StorageError> },
    }
    enum TerrainRequest {
        Load { cx: i32, cz: i32 },
    }
    enum TerrainReply {
        Load { cx: i32, cz: i32, chunk: Arc<Chunk> },
    }
    /// Error type used together with `RegionResult` for every call on region file methods.
    pub enum StorageError {
        #[error("region: {0}")]
        Region(#[from] RegionError),
        #[error("nbt: {0}")]
        Nbt(#[from] NbtError),
        #[error("nbt parse: {0}")]
        NbtParse(#[from] NbtParseError),
    }
    #[allow(unused_qualifications)]
    impl std::error::Error for StorageError {
        fn source(&self) -> ::core::option::Option<&(dyn std::error::Error + 'static)> {
            use thiserror::__private::AsDynError;
            #[allow(deprecated)]
            match self {
                StorageError::Region { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                StorageError::Nbt { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                StorageError::NbtParse { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::fmt::Display for StorageError {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            use thiserror::__private::AsDisplay as _;
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                StorageError::Region(_0) => {
                    __formatter.write_fmt(format_args!("region: {0}", _0.as_display()))
                }
                StorageError::Nbt(_0) => {
                    __formatter.write_fmt(format_args!("nbt: {0}", _0.as_display()))
                }
                StorageError::NbtParse(_0) => {
                    __formatter
                        .write_fmt(format_args!("nbt parse: {0}", _0.as_display()))
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<RegionError> for StorageError {
        #[allow(deprecated)]
        fn from(source: RegionError) -> Self {
            StorageError::Region { 0: source }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<NbtError> for StorageError {
        #[allow(deprecated)]
        fn from(source: NbtError) -> Self {
            StorageError::Nbt { 0: source }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<NbtParseError> for StorageError {
        #[allow(deprecated)]
        fn from(source: NbtParseError) -> Self {
            StorageError::NbtParse {
                0: source,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StorageError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                StorageError::Region(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Region",
                        &__self_0,
                    )
                }
                StorageError::Nbt(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Nbt",
                        &__self_0,
                    )
                }
                StorageError::NbtParse(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NbtParse",
                        &__self_0,
                    )
                }
            }
        }
    }
}
pub mod serde {
    //! Serialization and deserialization utilities for worlds, chunks and entities.
    pub mod region {
        //! Minecraft region file format storing 32x32 chunks inside a single file.
        use std::collections::HashMap;
        use std::collections::hash_map::Entry;
        use std::io::{self, Seek, SeekFrom, Write, Read};
        use std::path::{Path, PathBuf};
        use std::fs::File;
        use std::io::Take;
        use byteorder::{ReadBytesExt, WriteBytesExt};
        use flate2::read::{GzDecoder, ZlibDecoder};
        use flate2::write::ZlibEncoder;
        use flate2::Compression;
        use crate::io::{ReadJavaExt, WriteJavaExt};
        /// Internal function to calculate the index of a chunk metadata depending on its
        /// position, this is the same calculation as Notchian server.
        #[inline]
        fn calc_chunk_meta_index(cx: i32, cz: i32) -> usize {
            (cx & 31) as usize | (((cz & 31) as usize) << 5)
        }
        /// Internal constant empty array of 4K to write an empty sector.
        const EMPTY_SECTOR: &'static [u8; 4096] = &[0; 4096];
        /// A handle to a region directory storing all region files.
        pub struct RegionDir {
            /// Path of the region directory.
            path: PathBuf,
            /// Cache of already loaded region files.
            cache: HashMap<(i32, i32), Region<File>>,
        }
        impl RegionDir {
            pub fn new(path: impl Into<PathBuf>) -> Self {
                Self {
                    path: path.into(),
                    cache: HashMap::new(),
                }
            }
            /// Ensure that a region file exists for the given chunk coordinates. If false is
            /// given as the 'create' argument, then the file will not be created and initialized
            /// if not existing.
            pub fn ensure_region(
                &mut self,
                cx: i32,
                cz: i32,
                create: bool,
            ) -> Result<&mut Region<File>, RegionError> {
                let (rx, rz) = (cx >> 5, cz >> 5);
                match self.cache.entry((rx, rz)) {
                    Entry::Occupied(o) => Ok(o.into_mut()),
                    Entry::Vacant(v) => {
                        Ok(
                            v
                                .insert(
                                    Region::open(
                                        self
                                            .path
                                            .join({
                                                let res = ::alloc::fmt::format(
                                                    format_args!("r.{0}.{1}.mcr", rx, rz),
                                                );
                                                res
                                            }),
                                        create,
                                    )?,
                                ),
                        )
                    }
                }
            }
        }
        /// A handle to a region file. This is an implementation of ".mcr" region files following
        /// the same algorithms as the Notchian server, first developed by Scaevolus (legend!).
        ///
        /// Being generic over `I` allows us to use a mockup inner for tests.
        pub struct Region<I> {
            /// Underlying read/writer with seek.
            inner: I,
            /// Stores the metadata of each chunks
            chunks: Box<[ChunkMeta; 1024]>,
            /// Bit mapping of sectors that are allocated.
            sectors: Vec<u64>,
        }
        impl Region<File> {
            /// Open a region file, this constructor report every possible error with the region
            /// file without altering it in such case, it's up to the caller to delete the file
            /// and retry is wanted.
            pub fn open<P: AsRef<Path>>(
                path: P,
                create: bool,
            ) -> Result<Self, RegionError> {
                let path: &Path = path.as_ref();
                if create {
                    if let Some(parent) = path.parent() {
                        std::fs::create_dir_all(parent)?;
                    }
                }
                let file = File::options()
                    .read(true)
                    .write(true)
                    .create(create)
                    .open(path)?;
                Self::new(file, create)
            }
        }
        impl<I> Region<I>
        where
            I: Read + Write + Seek,
        {
            /// Create a new region around a inner reader/writer with seek. This constructor
            /// also reads initial data and also check for file integrity.
            pub fn new(mut inner: I, create: bool) -> Result<Self, RegionError> {
                let mut file_len = inner.seek(SeekFrom::End(0))?;
                if file_len == 0 && create {
                    for _ in 0..2 {
                        inner.write_all(EMPTY_SECTOR)?;
                    }
                    file_len = 8192;
                } else if file_len < 8192 {
                    return Err(RegionError::FileTooSmall(file_len));
                } else if file_len % 4096 != 0 {
                    return Err(RegionError::FileNotPadded(file_len));
                }
                let mut chunks: Box<[ChunkMeta; 1024]> = Box::new(
                    [ChunkMeta::INIT; 1024],
                );
                let mut sectors = ::alloc::vec::from_elem(
                    0u64,
                    file_len as usize / 4096,
                );
                sectors[0] |= 0b11;
                inner.seek(SeekFrom::Start(0))?;
                for i in 0..1024 {
                    let range_raw = inner.read_java_int()? as u32;
                    let range = SectorRange {
                        offset: range_raw >> 8,
                        count: range_raw & 0xFF,
                    };
                    chunks[i].range = range;
                    for offset in range.offset..range.offset + range.count {
                        if let Some(slot) = sectors.get_mut(offset as usize / 64) {
                            *slot |= 1u64 << (offset % 64);
                        } else {
                            return Err(RegionError::IllegalRange);
                        }
                    }
                }
                for i in 0..1024 {
                    chunks[i].timestamp = inner.read_java_int()? as u32;
                }
                Ok(Self { inner, chunks, sectors })
            }
            /// Internal function to get the chunk metadata associated with a chunk.
            fn get_chunk_meta(&self, cx: i32, cz: i32) -> ChunkMeta {
                self.chunks[calc_chunk_meta_index(cx, cz)]
            }
            /// Internal function to set the chunk metadata and synchronize
            fn set_chunk_meta_and_sync(
                &mut self,
                cx: i32,
                cz: i32,
                chunk: ChunkMeta,
            ) -> io::Result<()> {
                let index = calc_chunk_meta_index(cx, cz);
                let range_raw = chunk.range.offset << 8 | chunk.range.count & 0xFF;
                let header_offset = index as u64 * 4;
                self.inner.seek(SeekFrom::Start(header_offset))?;
                self.inner.write_java_int(range_raw as i32)?;
                self.chunks[index] = chunk;
                self.inner.seek(SeekFrom::Start(header_offset + 4096))?;
                self.inner.write_java_int(chunk.timestamp as i32)?;
                Ok(())
            }
            /// Read the chunk at the given position, the chunk position is at modulo 32 in order
            /// to respect the limitations of the region size, caller don't have to do it.
            pub fn read_chunk(
                &mut self,
                cx: i32,
                cz: i32,
            ) -> Result<ChunkReader<'_, I>, RegionError> {
                let chunk = self.get_chunk_meta(cx, cz);
                if chunk.is_empty() {
                    return Err(RegionError::EmptyChunk);
                }
                if chunk.range.offset < 2 {
                    return Err(RegionError::IllegalRange);
                }
                self.inner.seek(SeekFrom::Start(chunk.range.offset as u64 * 4096))?;
                let chunk_size = self.inner.read_java_int()?;
                if chunk_size <= 0 || chunk_size as u32 + 4 > chunk.range.count * 4096 {
                    return Err(RegionError::IllegalRange);
                }
                let compression_id = self.inner.read_u8()?;
                let chunk_size = chunk_size as u64 - 1;
                let chunk_data = Read::take(&mut self.inner, chunk_size);
                let inner = match compression_id {
                    1 => ChunkReaderInner::Gz(GzDecoder::new(chunk_data)),
                    2 => ChunkReaderInner::Zlib(ZlibDecoder::new(chunk_data)),
                    _ => return Err(RegionError::IllegalCompression),
                };
                Ok(ChunkReader { inner })
            }
            /// Write a chunk at the given position, the chunk position is at modulo 32 in order
            /// to respect the limitations of the region size, caller don't have to do it.
            pub fn write_chunk(&mut self, cx: i32, cz: i32) -> ChunkWriter<'_, I> {
                ChunkWriter {
                    cx,
                    cz,
                    encoder: ZlibEncoder::new(Vec::new(), Compression::best()),
                    region: self,
                }
            }
            fn write_chunk_data(
                &mut self,
                cx: i32,
                cz: i32,
                compression_id: u8,
                data: &[u8],
            ) -> Result<(), RegionError> {
                let sector_count = (data.len() + 5 - 1) as u32 / 4096 + 1;
                if sector_count > 0xFF {
                    return Err(RegionError::OutOfSector);
                }
                let mut chunk = self.get_chunk_meta(cx, cz);
                if !(chunk.range.count == 0 || chunk.range.offset >= 2) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("previous chunk metadata uses reserved sectors"),
                        );
                    }
                }
                if true {
                    if !(sector_count != 0) {
                        ::core::panicking::panic("assertion failed: sector_count != 0")
                    }
                }
                if sector_count != chunk.range.count {
                    let mut clear_range = chunk.range;
                    if sector_count < chunk.range.count {
                        clear_range.offset += sector_count;
                        clear_range.count -= sector_count;
                        chunk.range.count = sector_count;
                    }
                    if clear_range.count != 0 {
                        self.inner
                            .seek(SeekFrom::Start(clear_range.offset as u64 * 4096))?;
                        for offset in clear_range
                            .offset..clear_range.offset + clear_range.count
                        {
                            let slot = &mut self.sectors[offset as usize / 64];
                            *slot &= !(1u64 << (offset % 64));
                            self.inner.write_all(EMPTY_SECTOR)?;
                        }
                    }
                    if sector_count > chunk.range.count {
                        if true {
                            match (&(self.sectors[0] & 0b11), &0b11) {
                                (left_val, right_val) => {
                                    if !(*left_val == *right_val) {
                                        let kind = ::core::panicking::AssertKind::Eq;
                                        ::core::panicking::assert_failed(
                                            kind,
                                            &*left_val,
                                            &*right_val,
                                            ::core::option::Option::None,
                                        );
                                    }
                                }
                            };
                        }
                        let mut new_range = SectorRange::default();
                        'out: for (slot_index, mut slot) in self
                            .sectors
                            .iter()
                            .copied()
                            .enumerate()
                        {
                            if slot != u64::MAX {
                                for bit_index in 0usize..64 {
                                    if slot & 1 == 0 {
                                        new_range.count += 1;
                                        if new_range.count == sector_count {
                                            break 'out;
                                        }
                                    } else {
                                        new_range
                                            .offset = slot_index as u32 * 64 + bit_index as u32 + 1;
                                        new_range.count = 0;
                                    }
                                    slot >>= 1;
                                }
                            } else {
                                new_range.offset = slot_index as u32 * 64 + 64;
                                new_range.count = 0;
                            }
                        }
                        if !(new_range.offset >= 2) {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!("allocating reserved sectors"),
                                );
                            }
                        }
                        new_range.count = sector_count;
                        for offset in new_range
                            .offset..new_range.offset + new_range.count
                        {
                            let slot_index = offset as usize / 64;
                            if let Some(slot) = self.sectors.get_mut(slot_index) {
                                *slot |= 1u64 << (offset % 64);
                            } else {
                                if true {
                                    match (&slot_index, &self.sectors.len()) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::None,
                                                );
                                            }
                                        }
                                    };
                                }
                                self.sectors.push(1u64 << (offset % 64));
                            }
                        }
                        chunk.range = new_range;
                    }
                }
                if !(chunk.range.offset >= 2) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("allocating reserved sectors"),
                        );
                    }
                }
                if !(chunk.range.count != 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("allocating zero sector"),
                        );
                    }
                }
                self.set_chunk_meta_and_sync(cx, cz, chunk)?;
                self.inner.seek(SeekFrom::Start(chunk.range.offset as u64 * 4096))?;
                self.inner.write_java_int(data.len() as i32 + 1)?;
                self.inner.write_u8(compression_id)?;
                self.inner.write_all(data)?;
                let total_len = data.len() + 4 + 1;
                let padding_len = 4096 - total_len % 4096;
                self.inner.write_all(&EMPTY_SECTOR[..padding_len])?;
                self.inner.flush()?;
                Ok(())
            }
        }
        /// A handle for reading a chunk from a region file.
        pub struct ChunkReader<'region, I> {
            /// Inner implementation depending on compression.
            inner: ChunkReaderInner<'region, I>,
        }
        /// The actual implementation of the chunk reader depending on the compression type.
        enum ChunkReaderInner<'region, I> {
            Gz(GzDecoder<Take<&'region mut I>>),
            Zlib(ZlibDecoder<Take<&'region mut I>>),
        }
        impl<I> Read for ChunkReader<'_, I>
        where
            I: Read + Write + Seek,
        {
            #[inline]
            fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
                match &mut self.inner {
                    ChunkReaderInner::Gz(gz) => gz.read(buf),
                    ChunkReaderInner::Zlib(zlib) => zlib.read(buf),
                }
            }
            #[inline]
            fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {
                match &mut self.inner {
                    ChunkReaderInner::Gz(gz) => gz.read_exact(buf),
                    ChunkReaderInner::Zlib(zlib) => zlib.read_exact(buf),
                }
            }
        }
        /// A handle for writing a chunk in a region file.
        pub struct ChunkWriter<'region, I> {
            /// The chunk X coordinate.
            cx: i32,
            /// The chunk Z coordinate.
            cz: i32,
            /// The internal zlib encoder, we force using zlib when writing (id 2).
            encoder: ZlibEncoder<Vec<u8>>,
            /// The underlying region file used to finally write chunk data.
            region: &'region mut Region<I>,
        }
        impl<I> ChunkWriter<'_, I>
        where
            I: Read + Write + Seek,
        {
            /// A more costly variant of the regular IO's flush function, because this one also
            /// flush the inner encoded buffer to the region file, therefore searching available
            /// sectors and writing data.
            pub fn flush_chunk(self) -> Result<(), RegionError> {
                let inner = self.encoder.flush_finish()?;
                self.region.write_chunk_data(self.cx, self.cz, 2, &inner)
            }
        }
        impl<I> Write for ChunkWriter<'_, I> {
            #[inline]
            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
                self.encoder.write(buf)
            }
            #[inline]
            fn flush(&mut self) -> io::Result<()> {
                Ok(())
            }
        }
        /// Internal cached chunk metadata, it is kept in-sync with the region file.
        struct ChunkMeta {
            /// The offset of the chunk in sectors within the region file. The least significant
            /// byte is used for counting the number of sectors used (can be zero), and the
            /// remaining 3 bytes are storing the offset in sectors (should not be 0 or 1).
            range: SectorRange,
            /// Timestamp when the chunk was last saved in the region file.
            timestamp: u32,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ChunkMeta {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "ChunkMeta",
                    "range",
                    &self.range,
                    "timestamp",
                    &&self.timestamp,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ChunkMeta {
            #[inline]
            fn clone(&self) -> ChunkMeta {
                let _: ::core::clone::AssertParamIsClone<SectorRange>;
                let _: ::core::clone::AssertParamIsClone<u32>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ChunkMeta {}
        impl ChunkMeta {
            const INIT: Self = Self {
                range: SectorRange { offset: 0, count: 0 },
                timestamp: 0,
            };
            fn is_empty(self) -> bool {
                self.range.is_empty()
            }
        }
        /// Indicate a free range of sector.
        struct SectorRange {
            /// Offset of the first sector in that range.
            offset: u32,
            /// The number of sectors in the ranges, this should not be zero.
            count: u32,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SectorRange {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "SectorRange",
                    "offset",
                    &self.offset,
                    "count",
                    &&self.count,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SectorRange {
            #[inline]
            fn clone(&self) -> SectorRange {
                let _: ::core::clone::AssertParamIsClone<u32>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for SectorRange {}
        #[automatically_derived]
        impl ::core::default::Default for SectorRange {
            #[inline]
            fn default() -> SectorRange {
                SectorRange {
                    offset: ::core::default::Default::default(),
                    count: ::core::default::Default::default(),
                }
            }
        }
        impl SectorRange {
            fn is_empty(self) -> bool {
                self.count == 0
            }
        }
        /// Error type used together with `RegionResult` for every call on region file methods.
        pub enum RegionError {
            #[error("io: {0}")]
            Io(#[from] io::Error),
            #[error(
                "the region file size ({0}) is too short to store the two 4K header sectors"
            )]
            FileTooSmall(u64),
            #[error("the region file size ({0}) is not a multiple of 4K")]
            FileNotPadded(u64),
            #[error(
                "the region file has an invalid chunk range, likely out of range or colliding with another one"
            )]
            IllegalRange,
            #[error(
                "the required chunk is empty, it has no sector allocated in the region file"
            )]
            EmptyChunk,
            #[error("the compression method in the chunk header is illegal")]
            IllegalCompression,
            #[error(
                "no more sectors are available in the region file, really unlikely to happen"
            )]
            OutOfSector,
        }
        #[allow(unused_qualifications)]
        impl std::error::Error for RegionError {
            fn source(
                &self,
            ) -> ::core::option::Option<&(dyn std::error::Error + 'static)> {
                use thiserror::__private::AsDynError;
                #[allow(deprecated)]
                match self {
                    RegionError::Io { 0: source, .. } => {
                        ::core::option::Option::Some(source.as_dyn_error())
                    }
                    RegionError::FileTooSmall { .. } => ::core::option::Option::None,
                    RegionError::FileNotPadded { .. } => ::core::option::Option::None,
                    RegionError::IllegalRange { .. } => ::core::option::Option::None,
                    RegionError::EmptyChunk { .. } => ::core::option::Option::None,
                    RegionError::IllegalCompression { .. } => {
                        ::core::option::Option::None
                    }
                    RegionError::OutOfSector { .. } => ::core::option::Option::None,
                }
            }
        }
        #[allow(unused_qualifications)]
        impl ::core::fmt::Display for RegionError {
            fn fmt(
                &self,
                __formatter: &mut ::core::fmt::Formatter,
            ) -> ::core::fmt::Result {
                use thiserror::__private::AsDisplay as _;
                #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
                match self {
                    RegionError::Io(_0) => {
                        __formatter.write_fmt(format_args!("io: {0}", _0.as_display()))
                    }
                    RegionError::FileTooSmall(_0) => {
                        __formatter
                            .write_fmt(
                                format_args!(
                                    "the region file size ({0}) is too short to store the two 4K header sectors",
                                    _0.as_display(),
                                ),
                            )
                    }
                    RegionError::FileNotPadded(_0) => {
                        __formatter
                            .write_fmt(
                                format_args!(
                                    "the region file size ({0}) is not a multiple of 4K",
                                    _0.as_display(),
                                ),
                            )
                    }
                    RegionError::IllegalRange {} => {
                        __formatter
                            .write_fmt(
                                format_args!(
                                    "the region file has an invalid chunk range, likely out of range or colliding with another one",
                                ),
                            )
                    }
                    RegionError::EmptyChunk {} => {
                        __formatter
                            .write_fmt(
                                format_args!(
                                    "the required chunk is empty, it has no sector allocated in the region file",
                                ),
                            )
                    }
                    RegionError::IllegalCompression {} => {
                        __formatter
                            .write_fmt(
                                format_args!(
                                    "the compression method in the chunk header is illegal",
                                ),
                            )
                    }
                    RegionError::OutOfSector {} => {
                        __formatter
                            .write_fmt(
                                format_args!(
                                    "no more sectors are available in the region file, really unlikely to happen",
                                ),
                            )
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        impl ::core::convert::From<io::Error> for RegionError {
            #[allow(deprecated)]
            fn from(source: io::Error) -> Self {
                RegionError::Io { 0: source }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for RegionError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    RegionError::Io(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Io",
                            &__self_0,
                        )
                    }
                    RegionError::FileTooSmall(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "FileTooSmall",
                            &__self_0,
                        )
                    }
                    RegionError::FileNotPadded(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "FileNotPadded",
                            &__self_0,
                        )
                    }
                    RegionError::IllegalRange => {
                        ::core::fmt::Formatter::write_str(f, "IllegalRange")
                    }
                    RegionError::EmptyChunk => {
                        ::core::fmt::Formatter::write_str(f, "EmptyChunk")
                    }
                    RegionError::IllegalCompression => {
                        ::core::fmt::Formatter::write_str(f, "IllegalCompression")
                    }
                    RegionError::OutOfSector => {
                        ::core::fmt::Formatter::write_str(f, "OutOfSector")
                    }
                }
            }
        }
    }
    pub mod chunk {
        //! Chunk serialization and deserialization from NBT compound.
        use crate::world::ChunkSnapshot;
        use super::nbt::{Nbt, NbtParseError, NbtCompound};
        pub mod block_entity_nbt {
            //! NBT serialization and deserialization for [`BlockEntity`] type.
            use glam::IVec3;
            use crate::block_entity::note_block::NoteBlockBlockEntity;
            use crate::block_entity::dispenser::DispenserBlockEntity;
            use crate::block_entity::furnace::FurnaceBlockEntity;
            use crate::block_entity::jukebox::JukeboxBlockEntity;
            use crate::block_entity::spawner::SpawnerBlockEntity;
            use crate::block_entity::piston::PistonBlockEntity;
            use crate::block_entity::chest::ChestBlockEntity;
            use crate::block_entity::sign::SignBlockEntity;
            use crate::block_entity::BlockEntity;
            use crate::entity::EntityKind;
            use crate::item::ItemStack;
            use crate::geom::Face;
            use crate::serde::nbt::{NbtParseError, NbtCompound, NbtCompoundParse};
            use super::entity_kind_nbt;
            use super::slot_nbt;
            pub fn from_nbt(
                comp: NbtCompoundParse,
            ) -> Result<(IVec3, Box<BlockEntity>), NbtParseError> {
                let x = comp.get_int("x")?;
                let y = comp.get_int("y")?;
                let z = comp.get_int("z")?;
                let id = comp.get_string("id")?;
                let block_entity = Box::new(
                    match id {
                        "Chest" => {
                            let mut chest = ChestBlockEntity::default();
                            slot_nbt::from_nbt_to_inv(
                                comp.get_list("Items")?,
                                &mut chest.inv[..],
                            )?;
                            BlockEntity::Chest(chest)
                        }
                        "Furnace" => {
                            let mut inv = [ItemStack::EMPTY; 3];
                            slot_nbt::from_nbt_to_inv(
                                comp.get_list("Items")?,
                                &mut inv[..],
                            )?;
                            let mut furnace = FurnaceBlockEntity::default();
                            furnace.input_stack = inv[0];
                            furnace.fuel_stack = inv[1];
                            furnace.output_stack = inv[2];
                            furnace
                                .burn_remaining_ticks = comp.get_short("BurnTime")?.max(0)
                                as u16;
                            furnace
                                .smelt_ticks = comp.get_short("CookTime")?.max(0) as u16;
                            BlockEntity::Furnace(furnace)
                        }
                        "Trap" => {
                            let mut dispenser = DispenserBlockEntity::default();
                            slot_nbt::from_nbt_to_inv(
                                comp.get_list("Items")?,
                                &mut dispenser.inv[..],
                            )?;
                            BlockEntity::Dispenser(dispenser)
                        }
                        "MobSpawner" => {
                            let mut spawner = SpawnerBlockEntity::default();
                            spawner
                                .entity_kind = entity_kind_nbt::from_nbt(
                                    comp.get_string("EntityId")?,
                                )
                                .unwrap_or(EntityKind::Pig);
                            spawner.remaining_time = comp.get_short("Delay")? as u16;
                            BlockEntity::Spawner(spawner)
                        }
                        "Music" => {
                            let mut note_block = NoteBlockBlockEntity::default();
                            note_block.note = comp.get_byte("note")? as u8;
                            BlockEntity::NoteBlock(note_block)
                        }
                        "Piston" => {
                            let mut piston = PistonBlockEntity::default();
                            piston.block = comp.get_int("blockId")? as u8;
                            piston.metadata = comp.get_int("blockData")? as u8;
                            piston
                                .face = match comp.get_int("facing")? {
                                0 => Face::NegY,
                                1 => Face::PosY,
                                2 => Face::NegZ,
                                3 => Face::PosZ,
                                4 => Face::NegX,
                                _ => Face::PosX,
                            };
                            piston.progress = comp.get_float("progress")?;
                            piston.extending = comp.get_boolean("extending")?;
                            BlockEntity::Piston(piston)
                        }
                        "Sign" => {
                            let mut sign = SignBlockEntity::default();
                            for (i, key) in ["Text1", "Text2", "Text3", "Text4"]
                                .into_iter()
                                .enumerate()
                            {
                                sign.lines[i] = comp.get_string(key)?.to_string();
                            }
                            BlockEntity::Sign(sign)
                        }
                        "RecordPlayer" => {
                            BlockEntity::Jukebox(JukeboxBlockEntity {
                                record: comp.get_int("Record")? as u32,
                            })
                        }
                        _ => {
                            return Err(
                                NbtParseError::new(
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("{0}/id", comp.path()),
                                        );
                                        res
                                    },
                                    "valid block entity id",
                                ),
                            );
                        }
                    },
                );
                Ok((IVec3::new(x, y, z), block_entity))
            }
            pub fn to_nbt<'a>(
                comp: &'a mut NbtCompound,
                pos: IVec3,
                block_entity: &BlockEntity,
            ) -> &'a mut NbtCompound {
                comp.insert("x", pos.x);
                comp.insert("y", pos.y);
                comp.insert("z", pos.z);
                match block_entity {
                    BlockEntity::Chest(chest) => {
                        comp.insert("id", "Chest");
                        comp.insert("Items", slot_nbt::to_nbt_from_inv(&chest.inv[..]));
                    }
                    BlockEntity::Furnace(furnace) => {
                        comp.insert("id", "Furnace");
                        comp.insert(
                            "Items",
                            slot_nbt::to_nbt_from_inv(
                                &[
                                    furnace.input_stack,
                                    furnace.fuel_stack,
                                    furnace.output_stack,
                                ],
                            ),
                        );
                        comp.insert("BurnTime", furnace.burn_remaining_ticks);
                        comp.insert("CookTime", furnace.smelt_ticks);
                    }
                    BlockEntity::Dispenser(dispenser) => {
                        comp.insert("id", "Trap");
                        comp.insert(
                            "Items",
                            slot_nbt::to_nbt_from_inv(&dispenser.inv[..]),
                        );
                    }
                    BlockEntity::Spawner(spawner) => {
                        comp.insert("id", "MobSpawner");
                        comp.insert(
                            "EntityId",
                            entity_kind_nbt::to_nbt(spawner.entity_kind)
                                .unwrap_or({
                                    let res = ::alloc::fmt::format(format_args!("Pig"));
                                    res
                                }),
                        );
                        comp.insert(
                            "Delay",
                            spawner.remaining_time.min(i16::MAX as _) as i16,
                        );
                    }
                    BlockEntity::NoteBlock(note_block) => {
                        comp.insert("id", "Music");
                        comp.insert("note", note_block.note);
                    }
                    BlockEntity::Piston(piston) => {
                        comp.insert("id", "Piston");
                        comp.insert("blockId", piston.block as u32);
                        comp.insert("blockData", piston.metadata as u32);
                        comp.insert(
                            "facing",
                            match piston.face {
                                Face::NegY => 0i32,
                                Face::PosY => 1,
                                Face::NegZ => 2,
                                Face::PosZ => 3,
                                Face::NegX => 4,
                                Face::PosX => 5,
                            },
                        );
                        comp.insert("progress", piston.progress);
                        comp.insert("extending", piston.extending);
                    }
                    BlockEntity::Sign(sign) => {
                        comp.insert("id", "Sign");
                        for (i, key) in ["Text1", "Text2", "Text3", "Text4"]
                            .into_iter()
                            .enumerate()
                        {
                            comp.insert(key, sign.lines[i].as_str());
                        }
                    }
                    BlockEntity::Jukebox(jukebox) => {
                        comp.insert("id", "RecordPlayer");
                        comp.insert("Record", jukebox.record);
                    }
                }
                comp
            }
        }
        pub mod entity_kind_nbt {
            //! NBT serialization and deserialization for [`EntityKind`] enumeration.
            use crate::entity::EntityKind;
            pub fn from_nbt(id: &str) -> Option<EntityKind> {
                Some(
                    match id {
                        "Arrow" => EntityKind::Arrow,
                        "Snowball" => EntityKind::Snowball,
                        "Item" => EntityKind::Item,
                        "Painting" => EntityKind::Painting,
                        "Creeper" => EntityKind::Creeper,
                        "Skeleton" => EntityKind::Skeleton,
                        "Spider" => EntityKind::Spider,
                        "Giant" => EntityKind::Giant,
                        "Zombie" => EntityKind::Zombie,
                        "Slime" => EntityKind::Slime,
                        "Ghast" => EntityKind::Ghast,
                        "PigZombie" => EntityKind::PigZombie,
                        "Pig" => EntityKind::Pig,
                        "Sheep" => EntityKind::Sheep,
                        "Cow" => EntityKind::Cow,
                        "Chicken" => EntityKind::Chicken,
                        "Squid" => EntityKind::Squid,
                        "Wolf" => EntityKind::Wolf,
                        "PrimedTnt" => EntityKind::Tnt,
                        "FallingSand" => EntityKind::FallingBlock,
                        "Minecart" => EntityKind::Minecart,
                        "Boat" => EntityKind::Boat,
                        _ => return None,
                    },
                )
            }
            pub fn to_nbt(kind: EntityKind) -> Option<String> {
                Some(
                    match kind {
                        EntityKind::Item => "Item",
                        EntityKind::Painting => "Painting",
                        EntityKind::Boat => "Boat",
                        EntityKind::Minecart => "Minecart",
                        EntityKind::FallingBlock => "FallingSand",
                        EntityKind::Tnt => "PrimedTnt",
                        EntityKind::Arrow => "Arrow",
                        EntityKind::Snowball => "Snowball",
                        EntityKind::Ghast => "Ghast",
                        EntityKind::Slime => "Slime",
                        EntityKind::Pig => "Pig",
                        EntityKind::Chicken => "Chicken",
                        EntityKind::Cow => "Cow",
                        EntityKind::Sheep => "Sheep",
                        EntityKind::Squid => "Squid",
                        EntityKind::Wolf => "Wolf",
                        EntityKind::Creeper => "Creeper",
                        EntityKind::Giant => "Giant",
                        EntityKind::PigZombie => "PigZombie",
                        EntityKind::Skeleton => "Skeleton",
                        EntityKind::Spider => "Spider",
                        EntityKind::Zombie => "Zombie",
                        _ => return None,
                    }
                        .to_string(),
                )
            }
        }
        pub mod item_stack_nbt {
            //! NBT serialization and deserialization for [`ItemStack`] type.
            use crate::serde::nbt::{NbtParseError, NbtCompound, NbtCompoundParse};
            use crate::item::ItemStack;
            /// Create an item stack from a NBT compound.
            pub fn from_nbt(comp: NbtCompoundParse) -> Result<ItemStack, NbtParseError> {
                let id = comp.get_short("id")? as u16;
                let size = comp.get_byte("Count")?.max(0) as u16;
                let damage = comp.get_short("Damage")? as u16;
                Ok(ItemStack { id, size, damage })
            }
            /// Encode an item stack into a NBT compound.
            pub fn to_nbt(comp: &mut NbtCompound, stack: ItemStack) -> &mut NbtCompound {
                comp.insert("id", stack.id);
                comp.insert("Count", stack.size.min(i8::MAX as _) as i8);
                comp.insert("Damage", stack.damage);
                comp
            }
        }
        pub mod entity_nbt {
            //! NBT serialization and deserialization for `Vec<Box<Entity>>` type.
            use glam::IVec3;
            use crate::entity::{
                self as e, Entity, Base, BaseKind, Projectile, ProjectileKind, Living,
                LivingKind, PaintingOrientation, PaintingArt,
            };
            use crate::serde::nbt::{NbtCompoundParse, NbtCompound, NbtParseError};
            use crate::item::ItemStack;
            use super::item_stack_nbt;
            use super::slot_nbt;
            pub fn from_nbt(
                comp: NbtCompoundParse,
            ) -> Result<Box<Entity>, NbtParseError> {
                let mut base = Base::default();
                base.persistent = true;
                for (i, nbt) in comp.get_list("Pos")?.iter().enumerate().take(3) {
                    base.pos[i] = nbt.as_double()?;
                }
                for (i, nbt) in comp.get_list("Motion")?.iter().enumerate().take(3) {
                    base.vel[i] = nbt.as_double()?;
                }
                for (i, nbt) in comp.get_list("Rotation")?.iter().enumerate().take(2) {
                    base.look[i] = nbt.as_float()?;
                }
                base.fall_distance = comp.get_float("FallDistance").unwrap_or_default();
                base
                    .fire_time = comp.get_short("Fire").unwrap_or_default().max(0)
                    as u32;
                base.air_time = comp.get_short("Air").unwrap_or_default().max(0) as u32;
                base.on_ground = comp.get_boolean("OnGround").unwrap_or_default();
                let id = comp.get_string("id")?;
                let base_kind = match id {
                    "Item" => {
                        base
                            .lifetime = comp.get_int("Age").unwrap_or_default().max(0)
                            as u32;
                        let mut item = e::Item::default();
                        item
                            .health = comp.get_short("Health").unwrap_or_default().max(0)
                            as u16;
                        item
                            .stack = item_stack_nbt::from_nbt(
                            comp.get_compound("Item")?,
                        )?;
                        BaseKind::Item(item)
                    }
                    "Painting" => {
                        BaseKind::Painting(e::Painting {
                            block_pos: IVec3 {
                                x: comp.get_int("TileX")?,
                                y: comp.get_int("TileY")?,
                                z: comp.get_int("TileZ")?,
                            },
                            orientation: match comp.get_byte("Dir")? {
                                0 => PaintingOrientation::NegZ,
                                1 => PaintingOrientation::NegX,
                                2 => PaintingOrientation::PosZ,
                                _ => PaintingOrientation::PosX,
                            },
                            art: PaintingArt::Kebab,
                            ..Default::default()
                        })
                    }
                    "PrimedTnt" => {
                        BaseKind::Tnt(e::Tnt {
                            fuse_time: comp.get_byte("Fuse")?.max(0) as u32,
                        })
                    }
                    "FallingSand" => {
                        BaseKind::FallingBlock(e::FallingBlock {
                            block_id: comp.get_byte("Tile")? as u8,
                            ..Default::default()
                        })
                    }
                    "Minecart" => {
                        BaseKind::Minecart(
                            match comp.get_int("Type")? {
                                1 => {
                                    let mut inv: Box<[ItemStack; 27]> = Box::default();
                                    slot_nbt::from_nbt_to_inv(
                                        comp.get_list("Items")?,
                                        &mut inv[..],
                                    )?;
                                    e::Minecart::Chest { inv }
                                }
                                2 => {
                                    e::Minecart::Furnace {
                                        fuel: comp.get_short("fuel")?.max(0) as u32,
                                        push_x: comp.get_double("PushX")?,
                                        push_z: comp.get_double("PushZ")?,
                                    }
                                }
                                _ => e::Minecart::Normal,
                            },
                        )
                    }
                    "Boat" => BaseKind::Boat(e::Boat::default()),
                    "Arrow" | "Snowball" => {
                        let mut projectile = Projectile::default();
                        if comp.get_boolean("inGround")? {
                            projectile
                                .state = Some(e::ProjectileHit {
                                pos: IVec3 {
                                    x: comp.get_short("xTile")? as i32,
                                    y: comp.get_short("yTile")? as i32,
                                    z: comp.get_short("zTile")? as i32,
                                },
                                block: comp.get_byte("inTile")? as u8,
                                metadata: comp.get_byte("inData")? as u8,
                            });
                        }
                        projectile.shake = comp.get_byte("shake")?.max(0) as u8;
                        let projectile_kind = match id {
                            "Arrow" => {
                                ProjectileKind::Arrow(e::Arrow {
                                    from_player: comp.get_boolean("player").unwrap_or_default(),
                                })
                            }
                            "Snowball" => {
                                ProjectileKind::Snowball(e::Snowball::default())
                            }
                            _ => {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                        };
                        BaseKind::Projectile(projectile, projectile_kind)
                    }
                    "Creeper" | "Skeleton" | "Spider" | "Giant" | "Zombie" | "Slime"
                    | "Ghast" | "PigZombie" | "Pig" | "Sheep" | "Cow" | "Chicken"
                    | "Squid" | "Wolf" => {
                        let mut living = Living::default();
                        living
                            .health = comp.get_short("Health").unwrap_or(10).max(0)
                            as u16;
                        living.hurt_time = comp.get_short("HurtTime")?.max(0) as u16;
                        living.death_time = comp.get_short("DeathTime")?.max(0) as u16;
                        living.attack_time = comp.get_short("AttackTime")?.max(0) as u16;
                        let living_kind = match id {
                            "Creeper" => {
                                LivingKind::Creeper(e::Creeper {
                                    powered: comp.get_boolean("powered")?,
                                    ignited_time: None,
                                })
                            }
                            "Skeleton" => LivingKind::Skeleton(e::Skeleton::default()),
                            "Spider" => LivingKind::Spider(e::Spider::default()),
                            "Giant" => LivingKind::Giant(e::Giant::default()),
                            "Zombie" => LivingKind::Zombie(e::Zombie::default()),
                            "Slime" => {
                                LivingKind::Slime(e::Slime {
                                    size: comp.get_int("Size")?.clamp(0, 255) as u8,
                                    ..Default::default()
                                })
                            }
                            "Ghast" => LivingKind::Ghast(e::Ghast::default()),
                            "PigZombie" => {
                                LivingKind::PigZombie(e::PigZombie {
                                    anger: comp.get_short("Anger")? != 0,
                                })
                            }
                            "Pig" => {
                                LivingKind::Pig(e::Pig {
                                    saddle: comp.get_boolean("Saddle")?,
                                })
                            }
                            "Sheep" => {
                                LivingKind::Sheep(e::Sheep {
                                    sheared: comp.get_boolean("Sheared")?,
                                    color: comp.get_byte("Color")? as u8,
                                })
                            }
                            "Cow" => LivingKind::Cow(e::Cow::default()),
                            "Chicken" => LivingKind::Chicken(e::Chicken::default()),
                            "Squid" => LivingKind::Squid(e::Squid::default()),
                            "Wolf" => {
                                LivingKind::Wolf(e::Wolf {
                                    angry: comp.get_boolean("Angry")?,
                                    sitting: comp.get_boolean("Sitting")?,
                                    owner: {
                                        let owner = comp.get_string("Owner")?;
                                        (!owner.is_empty()).then(|| owner.to_string())
                                    },
                                })
                            }
                            _ => {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                        };
                        BaseKind::Living(living, living_kind)
                    }
                    _ => {
                        return Err(
                            NbtParseError::new(
                                {
                                    let res = ::alloc::fmt::format(
                                        format_args!("{0}/id", comp.path()),
                                    );
                                    res
                                },
                                "valid entity id",
                            ),
                        );
                    }
                };
                let mut entity = Box::new(Entity(base, base_kind));
                entity.resize();
                Ok(entity)
            }
            pub fn to_nbt<'a>(
                comp: &'a mut NbtCompound,
                entity: &Entity,
            ) -> Option<&'a mut NbtCompound> {
                let Entity(base, base_kind) = entity;
                match base_kind {
                    BaseKind::Item(item) => {
                        comp.insert("id", "Item");
                        comp.insert("Age", base.lifetime);
                        comp.insert("Health", item.health.min(i16::MAX as _) as i16);
                        let mut item_comp = NbtCompound::new();
                        item_stack_nbt::to_nbt(&mut item_comp, item.stack);
                        comp.insert("Item", item_comp);
                    }
                    BaseKind::Painting(painting) => {
                        comp.insert("id", "Painting");
                        comp.insert("TileX", painting.block_pos.x);
                        comp.insert("TileY", painting.block_pos.y);
                        comp.insert("TileZ", painting.block_pos.z);
                        comp.insert(
                            "Dir",
                            match painting.orientation {
                                PaintingOrientation::NegZ => 0i8,
                                PaintingOrientation::NegX => 1,
                                PaintingOrientation::PosZ => 2,
                                PaintingOrientation::PosX => 3,
                            },
                        );
                        comp.insert("Motive", "Kebab");
                    }
                    BaseKind::Boat(_) => {
                        comp.insert("id", "Boat");
                    }
                    BaseKind::Minecart(e::Minecart::Normal) => {
                        comp.insert("id", "Minecart");
                        comp.insert("Type", 0i32);
                    }
                    BaseKind::Minecart(e::Minecart::Chest { inv }) => {
                        comp.insert("id", "Minecart");
                        comp.insert("Type", 1i32);
                        comp.insert("Items", slot_nbt::to_nbt_from_inv(&inv[..]));
                    }
                    &BaseKind::Minecart(
                        e::Minecart::Furnace { push_x, push_z, fuel },
                    ) => {
                        comp.insert("id", "Minecart");
                        comp.insert("Type", 2i32);
                        comp.insert("fuel", fuel.min(i16::MAX as _) as i16);
                        comp.insert("PushX", push_x);
                        comp.insert("PushZ", push_z);
                    }
                    BaseKind::LightningBolt(_) => return None,
                    BaseKind::FallingBlock(falling_block) => {
                        comp.insert("id", "FallingSand");
                        comp.insert("Tile", falling_block.block_id);
                    }
                    BaseKind::Tnt(tnt) => {
                        comp.insert("id", "PrimedTnt");
                        comp.insert("Fuse", tnt.fuse_time.min(i8::MAX as _) as i8);
                    }
                    BaseKind::Projectile(projectile, projectile_kind) => {
                        match projectile_kind {
                            ProjectileKind::Arrow(arrow) => {
                                comp.insert("id", "Arrow");
                                comp.insert("player", arrow.from_player);
                            }
                            ProjectileKind::Snowball(_) => comp.insert("id", "Snowball"),
                            ProjectileKind::Egg(_) => return None,
                            ProjectileKind::Fireball(_) => return None,
                            ProjectileKind::Bobber(_) => return None,
                        }
                        let block = projectile.state.unwrap_or_default();
                        comp.insert("xTile", block.pos.x as i16);
                        comp.insert("yTile", block.pos.y as i16);
                        comp.insert("zTile", block.pos.z as i16);
                        comp.insert("inTile", block.block);
                        comp.insert("inData", block.metadata);
                        comp.insert("inGround", projectile.state.is_some());
                        comp.insert("shake", projectile.shake.min(i8::MAX as _) as i8);
                    }
                    BaseKind::Living(living, living_kind) => {
                        match living_kind {
                            LivingKind::Ghast(_) => comp.insert("id", "Ghast"),
                            LivingKind::Slime(slime) => {
                                comp.insert("id", "Slime");
                                comp.insert("Size", slime.size as u32);
                            }
                            LivingKind::Pig(pig) => {
                                comp.insert("id", "Pig");
                                comp.insert("Saddle", pig.saddle);
                            }
                            LivingKind::Chicken(_) => comp.insert("id", "Chicken"),
                            LivingKind::Cow(_) => comp.insert("id", "Cow"),
                            LivingKind::Sheep(sheep) => {
                                comp.insert("id", "Sheep");
                                comp.insert("Sheared", sheep.sheared);
                                comp.insert("Color", sheep.color);
                            }
                            LivingKind::Squid(_) => comp.insert("id", "Squid"),
                            LivingKind::Wolf(wolf) => {
                                comp.insert("id", "Wolf");
                                comp.insert("Angry", wolf.angry);
                                comp.insert("Sitting", wolf.sitting);
                                comp.insert(
                                    "Owner",
                                    wolf.owner.clone().unwrap_or_default(),
                                );
                            }
                            LivingKind::Creeper(creeper) => {
                                comp.insert("id", "Creeper");
                                comp.insert("powered", creeper.powered);
                            }
                            LivingKind::Giant(_) => comp.insert("id", "Giant"),
                            LivingKind::PigZombie(pig_zombie) => {
                                comp.insert("id", "PigZombie");
                                comp.insert("Anger", pig_zombie.anger as i16);
                            }
                            LivingKind::Skeleton(_) => comp.insert("id", "Skeleton"),
                            LivingKind::Spider(_) => comp.insert("id", "Spider"),
                            LivingKind::Zombie(_) => comp.insert("id", "Zombie"),
                            _ => return None,
                        }
                        comp.insert("Health", living.health.min(i16::MAX as _) as i16);
                        comp.insert(
                            "HurtTime",
                            living.hurt_time.min(i16::MAX as _) as i16,
                        );
                        comp.insert(
                            "DeathTime",
                            living.death_time.min(i16::MAX as _) as i16,
                        );
                        comp.insert(
                            "AttackTime",
                            living.attack_time.min(i16::MAX as _) as i16,
                        );
                    }
                }
                comp.insert("Pos", &base.pos.to_array()[..]);
                comp.insert("Motion", &base.vel.to_array()[..]);
                comp.insert("Rotation", &base.look.to_array()[..]);
                comp.insert("FallDistance", base.fall_distance);
                comp.insert("Fire", base.fire_time.min(i16::MAX as _) as i16);
                comp.insert("Air", base.air_time.min(i16::MAX as _) as i16);
                comp.insert("OnGround", base.on_ground);
                Some(comp)
            }
        }
        pub mod slot_nbt {
            //! Common NBT serde functions for item slots.
            use crate::serde::nbt::{
                NbtParseError, NbtCompoundParse, NbtCompound, NbtListParse, Nbt,
            };
            use crate::item::ItemStack;
            use super::item_stack_nbt;
            /// Create an slot and item stack from a NBT compound.
            pub fn from_nbt(
                comp: NbtCompoundParse,
            ) -> Result<(u8, ItemStack), NbtParseError> {
                let slot = comp.get_byte("Slot")? as u8;
                let stack = item_stack_nbt::from_nbt(comp)?;
                Ok((slot, stack))
            }
            /// Encode a slot and item stack into a NBT compound.
            pub fn to_nbt(
                comp: &mut NbtCompound,
                slot: u8,
                stack: ItemStack,
            ) -> &mut NbtCompound {
                comp.insert("Slot", slot);
                item_stack_nbt::to_nbt(comp, stack)
            }
            pub fn from_nbt_to_inv(
                list: NbtListParse,
                inv: &mut [ItemStack],
            ) -> Result<(), NbtParseError> {
                for item in list.iter() {
                    let (slot, stack) = from_nbt(item.as_compound()?)?;
                    if (slot as usize) < inv.len() {
                        inv[slot as usize] = stack;
                    }
                }
                Ok(())
            }
            pub fn to_nbt_from_inv(inv: &[ItemStack]) -> Vec<Nbt> {
                let mut list = Vec::new();
                for (index, stack) in inv.iter().copied().enumerate() {
                    if index < 256 && !stack.is_empty() {
                        let mut comp = NbtCompound::new();
                        to_nbt(&mut comp, index as u8, stack);
                        list.push(comp.into());
                    }
                }
                list
            }
        }
        pub mod chunk_nbt {
            //! NBT serialization and deserialization for [`ChunkSnapshot`] type.
            use std::sync::Arc;
            use crate::serde::nbt::{NbtCompoundParse, NbtCompound, NbtParseError, Nbt};
            use crate::world::ChunkSnapshot;
            use super::block_entity_nbt;
            use super::entity_nbt;
            pub fn from_nbt(
                comp: NbtCompoundParse,
            ) -> Result<ChunkSnapshot, NbtParseError> {
                let level = comp.get_compound("Level")?;
                let cx = level.get_int("xPos")?;
                let cz = level.get_int("zPos")?;
                let mut snapshot = ChunkSnapshot::new(cx, cz);
                let chunk = Arc::get_mut(&mut snapshot.chunk).unwrap();
                chunk.block.copy_from_slice(level.get_byte_array("Blocks")?);
                chunk.metadata.inner.copy_from_slice(level.get_byte_array("Data")?);
                chunk
                    .block_light
                    .inner
                    .copy_from_slice(level.get_byte_array("BlockLight")?);
                chunk.sky_light.inner.copy_from_slice(level.get_byte_array("SkyLight")?);
                chunk.height.copy_from_slice(level.get_byte_array("HeightMap")?);
                for item in level.get_list("Entities")?.iter() {
                    let entity = entity_nbt::from_nbt(item.as_compound()?)?;
                    snapshot.entities.push(entity);
                }
                for item in level.get_list("TileEntities")?.iter() {
                    let (pos, block_entity) = block_entity_nbt::from_nbt(
                        item.as_compound()?,
                    )?;
                    snapshot.block_entities.insert(pos, block_entity);
                }
                Ok(snapshot)
            }
            pub fn to_nbt<'a>(
                comp: &'a mut NbtCompound,
                snapshot: &ChunkSnapshot,
            ) -> &'a mut NbtCompound {
                let mut level = NbtCompound::new();
                level.insert("xPos", snapshot.cx);
                level.insert("zPos", snapshot.cz);
                level.insert("Blocks", snapshot.chunk.block.to_vec());
                level.insert("Data", snapshot.chunk.metadata.inner.to_vec());
                level.insert("BlockLight", snapshot.chunk.block_light.inner.to_vec());
                level.insert("SkyLight", snapshot.chunk.sky_light.inner.to_vec());
                level.insert("HeightMap", snapshot.chunk.height.to_vec());
                level
                    .insert(
                        "Entities",
                        snapshot
                            .entities
                            .iter()
                            .filter_map(|entity| {
                                let mut comp = NbtCompound::new();
                                if entity_nbt::to_nbt(&mut comp, &entity).is_some() {
                                    Some(Nbt::Compound(comp))
                                } else {
                                    None
                                }
                            })
                            .collect::<Vec<_>>(),
                    );
                level
                    .insert(
                        "TileEntities",
                        snapshot
                            .block_entities
                            .iter()
                            .map(|(&pos, block_entity)| {
                                let mut comp = NbtCompound::new();
                                block_entity_nbt::to_nbt(&mut comp, pos, &block_entity);
                                Nbt::Compound(comp)
                            })
                            .collect::<Vec<_>>(),
                    );
                comp.insert("Level", level);
                comp
            }
        }
        pub fn from_nbt(root: &Nbt) -> Result<ChunkSnapshot, NbtParseError> {
            chunk_nbt::from_nbt(root.parse().as_compound()?)
        }
        pub fn to_nbt(snapshot: &ChunkSnapshot) -> Nbt {
            let mut comp = NbtCompound::new();
            chunk_nbt::to_nbt(&mut comp, snapshot);
            Nbt::Compound(comp)
        }
    }
    pub mod nbt {
        //! NBT format serialization and deserialization.
        use std::io::{self, Read, Write};
        use std::collections::BTreeMap;
        use std::fmt;
        use crate::io::{ReadJavaExt, WriteJavaExt};
        const NBT_BYTE: i8 = 1;
        const NBT_SHORT: i8 = 2;
        const NBT_INT: i8 = 3;
        const NBT_LONG: i8 = 4;
        const NBT_FLOAT: i8 = 5;
        const NBT_DOUBLE: i8 = 6;
        const NBT_BYTE_ARRAY: i8 = 7;
        const NBT_STRING: i8 = 8;
        const NBT_LIST: i8 = 9;
        const NBT_COMPOUND: i8 = 10;
        /// A generic NBT tag, this structure has a size of 32 bytes.
        pub enum Nbt {
            Byte(i8),
            Short(i16),
            Int(i32),
            Long(i64),
            Float(f32),
            Double(f64),
            ByteArray(Vec<u8>),
            String(String),
            List(Vec<Nbt>),
            Compound(NbtCompound),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Nbt {
            #[inline]
            fn clone(&self) -> Nbt {
                match self {
                    Nbt::Byte(__self_0) => {
                        Nbt::Byte(::core::clone::Clone::clone(__self_0))
                    }
                    Nbt::Short(__self_0) => {
                        Nbt::Short(::core::clone::Clone::clone(__self_0))
                    }
                    Nbt::Int(__self_0) => Nbt::Int(::core::clone::Clone::clone(__self_0)),
                    Nbt::Long(__self_0) => {
                        Nbt::Long(::core::clone::Clone::clone(__self_0))
                    }
                    Nbt::Float(__self_0) => {
                        Nbt::Float(::core::clone::Clone::clone(__self_0))
                    }
                    Nbt::Double(__self_0) => {
                        Nbt::Double(::core::clone::Clone::clone(__self_0))
                    }
                    Nbt::ByteArray(__self_0) => {
                        Nbt::ByteArray(::core::clone::Clone::clone(__self_0))
                    }
                    Nbt::String(__self_0) => {
                        Nbt::String(::core::clone::Clone::clone(__self_0))
                    }
                    Nbt::List(__self_0) => {
                        Nbt::List(::core::clone::Clone::clone(__self_0))
                    }
                    Nbt::Compound(__self_0) => {
                        Nbt::Compound(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Nbt {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Nbt {
            #[inline]
            fn eq(&self, other: &Nbt) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (Nbt::Byte(__self_0), Nbt::Byte(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Nbt::Short(__self_0), Nbt::Short(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Nbt::Int(__self_0), Nbt::Int(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Nbt::Long(__self_0), Nbt::Long(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Nbt::Float(__self_0), Nbt::Float(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Nbt::Double(__self_0), Nbt::Double(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Nbt::ByteArray(__self_0), Nbt::ByteArray(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Nbt::String(__self_0), Nbt::String(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Nbt::List(__self_0), Nbt::List(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Nbt::Compound(__self_0), Nbt::Compound(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        /// An abstract NBT compound type that hides the internal implementation of the mapping.
        pub struct NbtCompound {
            inner: BTreeMap<String, Nbt>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for NbtCompound {
            #[inline]
            fn clone(&self) -> NbtCompound {
                NbtCompound {
                    inner: ::core::clone::Clone::clone(&self.inner),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for NbtCompound {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for NbtCompound {
            #[inline]
            fn eq(&self, other: &NbtCompound) -> bool {
                self.inner == other.inner
            }
        }
        impl From<bool> for Nbt {
            fn from(value: bool) -> Self {
                Nbt::Byte(value as _)
            }
        }
        impl<'a> From<&'a [bool]> for Nbt {
            fn from(value: &'a [bool]) -> Self {
                Nbt::List(value.iter().map(|&value| Nbt::Byte(value as _)).collect())
            }
        }
        impl From<i8> for Nbt {
            fn from(value: i8) -> Self {
                Nbt::Byte(value as _)
            }
        }
        impl<'a> From<&'a [i8]> for Nbt {
            fn from(value: &'a [i8]) -> Self {
                Nbt::List(value.iter().map(|&value| Nbt::Byte(value as _)).collect())
            }
        }
        impl From<u8> for Nbt {
            fn from(value: u8) -> Self {
                Nbt::Byte(value as _)
            }
        }
        impl<'a> From<&'a [u8]> for Nbt {
            fn from(value: &'a [u8]) -> Self {
                Nbt::List(value.iter().map(|&value| Nbt::Byte(value as _)).collect())
            }
        }
        impl From<i16> for Nbt {
            fn from(value: i16) -> Self {
                Nbt::Short(value as _)
            }
        }
        impl<'a> From<&'a [i16]> for Nbt {
            fn from(value: &'a [i16]) -> Self {
                Nbt::List(value.iter().map(|&value| Nbt::Short(value as _)).collect())
            }
        }
        impl From<u16> for Nbt {
            fn from(value: u16) -> Self {
                Nbt::Short(value as _)
            }
        }
        impl<'a> From<&'a [u16]> for Nbt {
            fn from(value: &'a [u16]) -> Self {
                Nbt::List(value.iter().map(|&value| Nbt::Short(value as _)).collect())
            }
        }
        impl From<i32> for Nbt {
            fn from(value: i32) -> Self {
                Nbt::Int(value as _)
            }
        }
        impl<'a> From<&'a [i32]> for Nbt {
            fn from(value: &'a [i32]) -> Self {
                Nbt::List(value.iter().map(|&value| Nbt::Int(value as _)).collect())
            }
        }
        impl From<u32> for Nbt {
            fn from(value: u32) -> Self {
                Nbt::Int(value as _)
            }
        }
        impl<'a> From<&'a [u32]> for Nbt {
            fn from(value: &'a [u32]) -> Self {
                Nbt::List(value.iter().map(|&value| Nbt::Int(value as _)).collect())
            }
        }
        impl From<i64> for Nbt {
            fn from(value: i64) -> Self {
                Nbt::Long(value as _)
            }
        }
        impl<'a> From<&'a [i64]> for Nbt {
            fn from(value: &'a [i64]) -> Self {
                Nbt::List(value.iter().map(|&value| Nbt::Long(value as _)).collect())
            }
        }
        impl From<u64> for Nbt {
            fn from(value: u64) -> Self {
                Nbt::Long(value as _)
            }
        }
        impl<'a> From<&'a [u64]> for Nbt {
            fn from(value: &'a [u64]) -> Self {
                Nbt::List(value.iter().map(|&value| Nbt::Long(value as _)).collect())
            }
        }
        impl From<f32> for Nbt {
            fn from(value: f32) -> Self {
                Nbt::Float(value as _)
            }
        }
        impl<'a> From<&'a [f32]> for Nbt {
            fn from(value: &'a [f32]) -> Self {
                Nbt::List(value.iter().map(|&value| Nbt::Float(value as _)).collect())
            }
        }
        impl From<f64> for Nbt {
            fn from(value: f64) -> Self {
                Nbt::Double(value as _)
            }
        }
        impl<'a> From<&'a [f64]> for Nbt {
            fn from(value: &'a [f64]) -> Self {
                Nbt::List(value.iter().map(|&value| Nbt::Double(value as _)).collect())
            }
        }
        impl From<Vec<u8>> for Nbt {
            fn from(value: Vec<u8>) -> Self {
                Nbt::ByteArray(value as _)
            }
        }
        impl From<String> for Nbt {
            fn from(value: String) -> Self {
                Nbt::String(value as _)
            }
        }
        impl From<Vec<Nbt>> for Nbt {
            fn from(value: Vec<Nbt>) -> Self {
                Nbt::List(value as _)
            }
        }
        impl From<NbtCompound> for Nbt {
            fn from(value: NbtCompound) -> Self {
                Nbt::Compound(value as _)
            }
        }
        impl<'a> From<&'a str> for Nbt {
            fn from(value: &'a str) -> Self {
                Nbt::String(value.to_string())
            }
        }
        /// Basic methods to interpret a tag as its inner type if possible.
        impl Nbt {
            #[inline]
            pub fn as_boolean(&self) -> Option<bool> {
                self.as_byte().map(|b| b != 0)
            }
            #[inline]
            pub fn as_byte(&self) -> Option<i8> {
                match *self {
                    Self::Byte(n) => Some(n),
                    _ => None,
                }
            }
            #[inline]
            pub fn as_short(&self) -> Option<i16> {
                match *self {
                    Self::Short(n) => Some(n),
                    _ => None,
                }
            }
            #[inline]
            pub fn as_int(&self) -> Option<i32> {
                match *self {
                    Self::Int(n) => Some(n),
                    _ => None,
                }
            }
            #[inline]
            pub fn as_long(&self) -> Option<i64> {
                match *self {
                    Self::Long(n) => Some(n),
                    _ => None,
                }
            }
            #[inline]
            pub fn as_float(&self) -> Option<f32> {
                match *self {
                    Self::Float(n) => Some(n),
                    _ => None,
                }
            }
            #[inline]
            pub fn as_double(&self) -> Option<f64> {
                match *self {
                    Self::Double(n) => Some(n),
                    _ => None,
                }
            }
            #[inline]
            pub fn as_byte_array(&self) -> Option<&[u8]> {
                match self {
                    Self::ByteArray(buf) => Some(&buf[..]),
                    _ => None,
                }
            }
            #[inline]
            pub fn as_string(&self) -> Option<&str> {
                match self {
                    Self::String(string) => Some(string.as_str()),
                    _ => None,
                }
            }
            #[inline]
            pub fn as_list(&self) -> Option<&[Nbt]> {
                match self {
                    Self::List(list) => Some(&list[..]),
                    _ => None,
                }
            }
            #[inline]
            pub fn as_compound(&self) -> Option<&NbtCompound> {
                match self {
                    Self::Compound(comp) => Some(comp),
                    _ => None,
                }
            }
            pub fn parse(&self) -> NbtParse<'_> {
                NbtParse {
                    inner: self,
                    path: String::new(),
                }
            }
        }
        /// Basic methods to create and manage keys in a compound.
        impl NbtCompound {
            pub const fn new() -> Self {
                Self { inner: BTreeMap::new() }
            }
            #[inline]
            pub fn len(&self) -> usize {
                self.inner.len()
            }
            #[inline]
            pub fn is_empty(&self) -> bool {
                self.inner.is_empty()
            }
            #[inline]
            pub fn insert(&mut self, key: impl Into<String>, tag: impl Into<Nbt>) {
                self.inner.insert(key.into(), tag.into());
            }
            #[inline]
            pub fn get(&self, key: &str) -> Option<&Nbt> {
                self.inner.get(key)
            }
            #[inline]
            pub fn get_boolean(&self, key: &str) -> Option<bool> {
                self.get(key).and_then(Nbt::as_boolean)
            }
            #[inline]
            pub fn get_byte(&self, key: &str) -> Option<i8> {
                self.get(key).and_then(Nbt::as_byte)
            }
            #[inline]
            pub fn get_short(&self, key: &str) -> Option<i16> {
                self.get(key).and_then(Nbt::as_short)
            }
            #[inline]
            pub fn get_int(&self, key: &str) -> Option<i32> {
                self.get(key).and_then(Nbt::as_int)
            }
            #[inline]
            pub fn get_long(&self, key: &str) -> Option<i64> {
                self.get(key).and_then(Nbt::as_long)
            }
            #[inline]
            pub fn get_float(&self, key: &str) -> Option<f32> {
                self.get(key).and_then(Nbt::as_float)
            }
            #[inline]
            pub fn get_double(&self, key: &str) -> Option<f64> {
                self.get(key).and_then(Nbt::as_double)
            }
            #[inline]
            pub fn get_byte_array(&self, key: &str) -> Option<&[u8]> {
                self.get(key).and_then(Nbt::as_byte_array)
            }
            #[inline]
            pub fn get_string(&self, key: &str) -> Option<&str> {
                self.get(key).and_then(Nbt::as_string)
            }
            #[inline]
            pub fn get_list(&self, key: &str) -> Option<&[Nbt]> {
                self.get(key).and_then(Nbt::as_list)
            }
            #[inline]
            pub fn get_compound(&self, key: &str) -> Option<&NbtCompound> {
                self.get(key).and_then(Nbt::as_compound)
            }
        }
        /// Manual debug implement to shrink the potential huge byte arrays.
        impl fmt::Debug for Nbt {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match self {
                    Self::Byte(n) => f.debug_tuple("Byte").field(n).finish(),
                    Self::Short(n) => f.debug_tuple("Short").field(n).finish(),
                    Self::Int(n) => f.debug_tuple("Int").field(n).finish(),
                    Self::Long(n) => f.debug_tuple("Long").field(n).finish(),
                    Self::Float(n) => f.debug_tuple("Float").field(n).finish(),
                    Self::Double(n) => f.debug_tuple("Double").field(n).finish(),
                    Self::ByteArray(buf) => {
                        f.debug_tuple("ByteArray")
                            .field(
                                &format_args!(
                                    "({0}) {1:X?}...",
                                    buf.len(),
                                    &buf[..buf.len().min(10)],
                                ),
                            )
                            .finish()
                    }
                    Self::String(string) => {
                        f.debug_tuple("String").field(string).finish()
                    }
                    Self::List(list) => f.debug_tuple("List").field(list).finish(),
                    Self::Compound(compound) => {
                        f.debug_tuple("Compound").field(&compound.inner).finish()
                    }
                }
            }
        }
        /// Deserialize a NBT tag from a reader.
        pub fn from_reader(mut reader: impl Read) -> Result<Nbt, NbtError> {
            let type_id = reader.read_java_byte()?;
            if type_id == 0 {
                return Err(NbtError::IllegalTagType);
            }
            let _key = reader.read_java_string8()?;
            from_reader_with_type(&mut reader, type_id)
        }
        /// Internal function to read a NBT tag of a specific type.
        fn from_reader_with_type(
            reader: &mut impl Read,
            type_id: i8,
        ) -> Result<Nbt, NbtError> {
            Ok(
                match type_id {
                    NBT_BYTE => Nbt::Byte(reader.read_java_byte()?),
                    NBT_SHORT => Nbt::Short(reader.read_java_short()?),
                    NBT_INT => Nbt::Int(reader.read_java_int()?),
                    NBT_LONG => Nbt::Long(reader.read_java_long()?),
                    NBT_FLOAT => Nbt::Float(reader.read_java_float()?),
                    NBT_DOUBLE => Nbt::Double(reader.read_java_double()?),
                    NBT_BYTE_ARRAY => {
                        let len: usize = reader
                            .read_java_int()?
                            .try_into()
                            .map_err(|_| NbtError::IllegalLength)?;
                        let mut buf = ::alloc::vec::from_elem(0u8, len as usize);
                        reader.read_exact(&mut buf)?;
                        Nbt::ByteArray(buf)
                    }
                    NBT_STRING => Nbt::String(reader.read_java_string8()?),
                    NBT_LIST => {
                        let type_id = reader.read_java_byte()?;
                        let len: usize = reader
                            .read_java_int()?
                            .try_into()
                            .map_err(|_| NbtError::IllegalLength)?;
                        let mut list = Vec::with_capacity(len as usize);
                        for _ in 0..len {
                            list.push(from_reader_with_type(reader, type_id)?);
                        }
                        Nbt::List(list)
                    }
                    NBT_COMPOUND => {
                        let mut map = BTreeMap::new();
                        loop {
                            let type_id = reader.read_java_byte()?;
                            if type_id == 0 {
                                break Nbt::Compound(NbtCompound { inner: map });
                            }
                            let key = reader.read_java_string8()?;
                            map.insert(key, from_reader_with_type(reader, type_id)?);
                        }
                    }
                    _ => return Err(NbtError::IllegalTagType),
                },
            )
        }
        /// Serialize a NBT tag into a writer.
        pub fn to_writer(mut writer: impl Write, tag: &Nbt) -> Result<(), NbtError> {
            writer.write_java_byte(get_nbt_type_id(tag))?;
            writer.write_java_string8("")?;
            to_writer_raw(&mut writer, tag)
        }
        /// Internal function to write a NBT tag content.
        fn to_writer_raw(writer: &mut impl Write, tag: &Nbt) -> Result<(), NbtError> {
            match *tag {
                Nbt::Byte(n) => writer.write_java_byte(n)?,
                Nbt::Short(n) => writer.write_java_short(n)?,
                Nbt::Int(n) => writer.write_java_int(n)?,
                Nbt::Long(n) => writer.write_java_long(n)?,
                Nbt::Float(n) => writer.write_java_float(n)?,
                Nbt::Double(n) => writer.write_java_double(n)?,
                Nbt::ByteArray(ref buf) => {
                    let len: i32 = buf
                        .len()
                        .try_into()
                        .map_err(|_| NbtError::IllegalLength)?;
                    writer.write_java_int(len)?;
                    writer.write_all(&buf)?;
                }
                Nbt::String(ref string) => writer.write_java_string8(&string)?,
                Nbt::List(ref list) => {
                    let len: i32 = list
                        .len()
                        .try_into()
                        .map_err(|_| NbtError::IllegalLength)?;
                    let type_id = list.first().map(get_nbt_type_id).unwrap_or(NBT_BYTE);
                    writer.write_java_byte(type_id)?;
                    writer.write_java_int(len)?;
                    for item in list {
                        if get_nbt_type_id(item) != type_id {
                            return Err(NbtError::IllegalTagType);
                        }
                        to_writer_raw(writer, item)?;
                    }
                }
                Nbt::Compound(ref compound) => {
                    for (key, tag) in &compound.inner {
                        writer.write_java_byte(get_nbt_type_id(tag))?;
                        writer.write_java_string8(&key)?;
                        to_writer_raw(writer, tag)?;
                    }
                    writer.write_java_byte(0)?;
                }
            }
            Ok(())
        }
        /// Internal function to get the NBT type id of a tag.
        fn get_nbt_type_id(tag: &Nbt) -> i8 {
            match tag {
                Nbt::Byte(_) => NBT_BYTE,
                Nbt::Short(_) => NBT_SHORT,
                Nbt::Int(_) => NBT_INT,
                Nbt::Long(_) => NBT_LONG,
                Nbt::Float(_) => NBT_FLOAT,
                Nbt::Double(_) => NBT_DOUBLE,
                Nbt::ByteArray(_) => NBT_BYTE_ARRAY,
                Nbt::String(_) => NBT_STRING,
                Nbt::List(_) => NBT_LIST,
                Nbt::Compound(_) => NBT_COMPOUND,
            }
        }
        /// Error type used together with `RegionResult` for every call on region file methods.
        pub enum NbtError {
            #[error("io: {0}")]
            Io(#[from] io::Error),
            #[error("illegal tag type")]
            IllegalTagType,
            #[error("illegal decoded length")]
            IllegalLength,
        }
        #[allow(unused_qualifications)]
        impl std::error::Error for NbtError {
            fn source(
                &self,
            ) -> ::core::option::Option<&(dyn std::error::Error + 'static)> {
                use thiserror::__private::AsDynError;
                #[allow(deprecated)]
                match self {
                    NbtError::Io { 0: source, .. } => {
                        ::core::option::Option::Some(source.as_dyn_error())
                    }
                    NbtError::IllegalTagType { .. } => ::core::option::Option::None,
                    NbtError::IllegalLength { .. } => ::core::option::Option::None,
                }
            }
        }
        #[allow(unused_qualifications)]
        impl ::core::fmt::Display for NbtError {
            fn fmt(
                &self,
                __formatter: &mut ::core::fmt::Formatter,
            ) -> ::core::fmt::Result {
                use thiserror::__private::AsDisplay as _;
                #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
                match self {
                    NbtError::Io(_0) => {
                        __formatter.write_fmt(format_args!("io: {0}", _0.as_display()))
                    }
                    NbtError::IllegalTagType {} => {
                        __formatter.write_fmt(format_args!("illegal tag type"))
                    }
                    NbtError::IllegalLength {} => {
                        __formatter.write_fmt(format_args!("illegal decoded length"))
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        impl ::core::convert::From<io::Error> for NbtError {
            #[allow(deprecated)]
            fn from(source: io::Error) -> Self {
                NbtError::Io { 0: source }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NbtError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    NbtError::Io(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Io",
                            &__self_0,
                        )
                    }
                    NbtError::IllegalTagType => {
                        ::core::fmt::Formatter::write_str(f, "IllegalTagType")
                    }
                    NbtError::IllegalLength => {
                        ::core::fmt::Formatter::write_str(f, "IllegalLength")
                    }
                }
            }
        }
        /// Parsing utility structure for anonymous NBT.
        pub struct NbtParse<'nbt> {
            /// Reference to the anonymous NBT.
            inner: &'nbt Nbt,
            /// Current path being parsed, used to return relevant errors.
            path: String,
        }
        #[automatically_derived]
        impl<'nbt> ::core::clone::Clone for NbtParse<'nbt> {
            #[inline]
            fn clone(&self) -> NbtParse<'nbt> {
                NbtParse {
                    inner: ::core::clone::Clone::clone(&self.inner),
                    path: ::core::clone::Clone::clone(&self.path),
                }
            }
        }
        impl<'nbt> NbtParse<'nbt> {
            #[inline]
            fn make_error(self, expected: &'static str) -> NbtParseError {
                NbtParseError::new(self.path, expected)
            }
            #[inline]
            pub fn as_boolean(self) -> Result<bool, NbtParseError> {
                self.as_byte().map(|b| b != 0)
            }
            #[inline]
            pub fn as_byte(self) -> Result<i8, NbtParseError> {
                self.inner.as_byte().ok_or_else(|| self.make_error("byte"))
            }
            #[inline]
            pub fn as_short(self) -> Result<i16, NbtParseError> {
                self.inner.as_short().ok_or_else(|| self.make_error("short"))
            }
            #[inline]
            pub fn as_int(self) -> Result<i32, NbtParseError> {
                self.inner.as_int().ok_or_else(|| self.make_error("int"))
            }
            #[inline]
            pub fn as_long(self) -> Result<i64, NbtParseError> {
                self.inner.as_long().ok_or_else(|| self.make_error("long"))
            }
            #[inline]
            pub fn as_float(self) -> Result<f32, NbtParseError> {
                self.inner.as_float().ok_or_else(|| self.make_error("float"))
            }
            #[inline]
            pub fn as_double(self) -> Result<f64, NbtParseError> {
                self.inner.as_double().ok_or_else(|| self.make_error("double"))
            }
            #[inline]
            pub fn as_byte_array(self) -> Result<&'nbt [u8], NbtParseError> {
                self.inner.as_byte_array().ok_or_else(|| self.make_error("byte array"))
            }
            #[inline]
            pub fn as_string(self) -> Result<&'nbt str, NbtParseError> {
                self.inner.as_string().ok_or_else(|| self.make_error("string"))
            }
            #[inline]
            pub fn as_list(self) -> Result<NbtListParse<'nbt>, NbtParseError> {
                match self.inner.as_list() {
                    Some(inner) => {
                        Ok(NbtListParse {
                            inner,
                            path: self.path,
                        })
                    }
                    None => Err(self.make_error("list")),
                }
            }
            #[inline]
            pub fn as_compound(self) -> Result<NbtCompoundParse<'nbt>, NbtParseError> {
                match self.inner.as_compound() {
                    Some(inner) => {
                        Ok(NbtCompoundParse {
                            inner,
                            path: self.path,
                        })
                    }
                    None => Err(self.make_error("compound")),
                }
            }
            #[inline]
            pub fn path(&self) -> &str {
                &self.path
            }
            #[inline]
            pub fn inner(&self) -> &'nbt Nbt {
                self.inner
            }
        }
        /// Parsing utility structure for NBT list.
        pub struct NbtListParse<'nbt> {
            /// Reference to the parsed NBT data.
            inner: &'nbt [Nbt],
            /// Current path being parsed, used to return relevant errors.
            path: String,
        }
        #[automatically_derived]
        impl<'nbt> ::core::clone::Clone for NbtListParse<'nbt> {
            #[inline]
            fn clone(&self) -> NbtListParse<'nbt> {
                NbtListParse {
                    inner: ::core::clone::Clone::clone(&self.inner),
                    path: ::core::clone::Clone::clone(&self.path),
                }
            }
        }
        impl<'nbt> NbtListParse<'nbt> {
            /// Get an item from its index in this list.
            /// An expected item error is returned if not found.
            pub fn get(&self, index: usize) -> Result<NbtParse<'nbt>, NbtParseError> {
                let path = {
                    let res = ::alloc::fmt::format(
                        format_args!("{0}/{1}", self.path, index),
                    );
                    res
                };
                match self.inner.get(index) {
                    Some(inner) => Ok(NbtParse { inner, path }),
                    None => Err(NbtParseError::new(path, "list value")),
                }
            }
            #[inline]
            pub fn get_boolean(&self, index: usize) -> Result<bool, NbtParseError> {
                self.get(index).and_then(NbtParse::as_boolean)
            }
            #[inline]
            pub fn get_byte(&self, index: usize) -> Result<i8, NbtParseError> {
                self.get(index).and_then(NbtParse::as_byte)
            }
            #[inline]
            pub fn get_short(&self, index: usize) -> Result<i16, NbtParseError> {
                self.get(index).and_then(NbtParse::as_short)
            }
            #[inline]
            pub fn get_int(&self, index: usize) -> Result<i32, NbtParseError> {
                self.get(index).and_then(NbtParse::as_int)
            }
            #[inline]
            pub fn get_long(&self, index: usize) -> Result<i64, NbtParseError> {
                self.get(index).and_then(NbtParse::as_long)
            }
            #[inline]
            pub fn get_float(&self, index: usize) -> Result<f32, NbtParseError> {
                self.get(index).and_then(NbtParse::as_float)
            }
            #[inline]
            pub fn get_double(&self, index: usize) -> Result<f64, NbtParseError> {
                self.get(index).and_then(NbtParse::as_double)
            }
            #[inline]
            pub fn get_byte_array(
                &self,
                index: usize,
            ) -> Result<&'nbt [u8], NbtParseError> {
                self.get(index).and_then(NbtParse::as_byte_array)
            }
            #[inline]
            pub fn get_string(&self, index: usize) -> Result<&'nbt str, NbtParseError> {
                self.get(index).and_then(NbtParse::as_string)
            }
            #[inline]
            pub fn get_list(
                &self,
                index: usize,
            ) -> Result<NbtListParse<'nbt>, NbtParseError> {
                self.get(index).and_then(NbtParse::as_list)
            }
            #[inline]
            pub fn get_compound(
                &self,
                index: usize,
            ) -> Result<NbtCompoundParse<'nbt>, NbtParseError> {
                self.get(index).and_then(NbtParse::as_compound)
            }
            #[inline]
            pub fn len(&self) -> usize {
                self.inner.len()
            }
            #[inline]
            pub fn path(&self) -> &str {
                &self.path
            }
            #[inline]
            pub fn inner(&self) -> &'nbt [Nbt] {
                self.inner
            }
            pub fn iter(&self) -> impl Iterator<Item = NbtParse<'_>> + '_ {
                self.inner
                    .iter()
                    .enumerate()
                    .map(|(i, inner)| {
                        let path = {
                            let res = ::alloc::fmt::format(
                                format_args!("{0}/{1}", self.path, i),
                            );
                            res
                        };
                        NbtParse { inner, path }
                    })
            }
        }
        /// Parsing utility structure for a NBT compound.
        pub struct NbtCompoundParse<'nbt> {
            /// Reference to the NBT compound.
            inner: &'nbt NbtCompound,
            /// Current path being parsed, used to return relevant errors.
            path: String,
        }
        #[automatically_derived]
        impl<'nbt> ::core::clone::Clone for NbtCompoundParse<'nbt> {
            #[inline]
            fn clone(&self) -> NbtCompoundParse<'nbt> {
                NbtCompoundParse {
                    inner: ::core::clone::Clone::clone(&self.inner),
                    path: ::core::clone::Clone::clone(&self.path),
                }
            }
        }
        impl<'nbt> NbtCompoundParse<'nbt> {
            /// Get a item from its key in this compound.
            /// An expected item error is returned if not found.
            pub fn get(&self, key: &str) -> Result<NbtParse<'nbt>, NbtParseError> {
                let path = {
                    let res = ::alloc::fmt::format(
                        format_args!("{0}/{1}", self.path, key),
                    );
                    res
                };
                match self.inner.get(key) {
                    Some(inner) => Ok(NbtParse { inner, path }),
                    None => Err(NbtParseError::new(path, "compound value")),
                }
            }
            #[inline]
            pub fn get_boolean(&self, key: &str) -> Result<bool, NbtParseError> {
                self.get(key).and_then(NbtParse::as_boolean)
            }
            #[inline]
            pub fn get_byte(&self, key: &str) -> Result<i8, NbtParseError> {
                self.get(key).and_then(NbtParse::as_byte)
            }
            #[inline]
            pub fn get_short(&self, key: &str) -> Result<i16, NbtParseError> {
                self.get(key).and_then(NbtParse::as_short)
            }
            #[inline]
            pub fn get_int(&self, key: &str) -> Result<i32, NbtParseError> {
                self.get(key).and_then(NbtParse::as_int)
            }
            #[inline]
            pub fn get_long(&self, key: &str) -> Result<i64, NbtParseError> {
                self.get(key).and_then(NbtParse::as_long)
            }
            #[inline]
            pub fn get_float(&self, key: &str) -> Result<f32, NbtParseError> {
                self.get(key).and_then(NbtParse::as_float)
            }
            #[inline]
            pub fn get_double(&self, key: &str) -> Result<f64, NbtParseError> {
                self.get(key).and_then(NbtParse::as_double)
            }
            #[inline]
            pub fn get_byte_array(
                &self,
                key: &str,
            ) -> Result<&'nbt [u8], NbtParseError> {
                self.get(key).and_then(NbtParse::as_byte_array)
            }
            #[inline]
            pub fn get_string(&self, key: &str) -> Result<&'nbt str, NbtParseError> {
                self.get(key).and_then(NbtParse::as_string)
            }
            #[inline]
            pub fn get_list(
                &self,
                key: &str,
            ) -> Result<NbtListParse<'nbt>, NbtParseError> {
                self.get(key).and_then(NbtParse::as_list)
            }
            #[inline]
            pub fn get_compound(
                &self,
                key: &str,
            ) -> Result<NbtCompoundParse<'nbt>, NbtParseError> {
                self.get(key).and_then(NbtParse::as_compound)
            }
            #[inline]
            pub fn len(&self) -> usize {
                self.inner.len()
            }
            #[inline]
            pub fn path(&self) -> &str {
                &self.path
            }
            #[inline]
            pub fn inner(&self) -> &'nbt NbtCompound {
                self.inner
            }
        }
        /// A parsing error as returned by [`NbtParse`] and [`NbtCompoundParse`] wrappers.
        #[error("{}: expected {}", self.path(), self.expected())]
        pub struct NbtParseError(Box<NbtParseErrorInner>);
        #[allow(unused_qualifications)]
        impl std::error::Error for NbtParseError {}
        #[allow(unused_qualifications)]
        impl ::core::fmt::Display for NbtParseError {
            #[allow(clippy::used_underscore_binding)]
            fn fmt(
                &self,
                __formatter: &mut ::core::fmt::Formatter,
            ) -> ::core::fmt::Result {
                #[allow(unused_variables, deprecated)]
                let Self(_0) = self;
                __formatter
                    .write_fmt(
                        format_args!("{0}: expected {1}", self.path(), self.expected()),
                    )
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NbtParseError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "NbtParseError",
                    &&self.0,
                )
            }
        }
        struct NbtParseErrorInner {
            /// The path of the tag that caused an error.
            path: String,
            /// The type of item expected at the path.
            expected: &'static str,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for NbtParseErrorInner {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NbtParseErrorInner",
                    "path",
                    &self.path,
                    "expected",
                    &&self.expected,
                )
            }
        }
        impl NbtParseError {
            /// Create a new parse error.
            pub fn new(path: String, expected: &'static str) -> Self {
                Self(
                    Box::new(NbtParseErrorInner {
                        path,
                        expected,
                    }),
                )
            }
            pub fn path(&self) -> &str {
                &self.0.path
            }
            pub fn expected(&self) -> &'static str {
                self.0.expected
            }
        }
    }
}
pub mod gen {
    //! World generation module.
    //!
    //! PARITY: The parity of world generation is really hard to get fully exact, mostly
    //! because Minecraft itself is not at parity with itself! The world generation scheduling
    //! has a huge impact on chunk populating, so this implementation is on parity but it may
    //! not give exact same world on each generation, just like Minecraft. Terrain however,
    //! should be exactly the same on same run.
    use glam::IVec3;
    use crate::rand::JavaRandom;
    use crate::chunk::Chunk;
    use crate::world::World;
    pub mod math {
        //! Math utilities specialized for Minecraft, such as sin/cos precomputed tables, in order
        //! to get the best parity with Minecraft generation.
        #[allow(clippy::approx_constant)]
        const JAVA_PI: f64 = 3.141592653589793;
        /// We internally do not use a precomputed table as in Notchian implementation. For now
        /// we recompute the table value on each access.
        #[inline(always)]
        fn mc_sin_table(index: u16) -> f32 {
            (index as f64 * JAVA_PI * 2.0 / 65536.0).sin() as f32
        }
        #[inline]
        fn mc_sin(x: f32) -> f32 {
            mc_sin_table((x * 10430.378) as i32 as u16)
        }
        #[inline]
        fn mc_cos(x: f32) -> f32 {
            mc_sin_table((x * 10430.378 + 16384.0) as i32 as u16)
        }
        /// An extension trait to numbers.
        pub trait MinecraftMath: Copy {
            const MC_PI: Self;
            /// Computes the sine of a number (in radians) with parity with Notchian impl.
            fn mc_sin(self) -> Self;
            /// Computes the cosine of a number (in radians) with parity with Notchian impl.
            fn mc_cos(self) -> Self;
            /// Same as [`f32::sin_cos`] but for Notchian impl.
            #[inline]
            fn mc_sin_cos(self) -> (Self, Self) {
                (self.mc_sin(), self.mc_cos())
            }
        }
        impl MinecraftMath for f32 {
            const MC_PI: Self = JAVA_PI as f32;
            #[inline]
            fn mc_sin(self) -> Self {
                mc_sin(self)
            }
            #[inline]
            fn mc_cos(self) -> Self {
                mc_cos(self)
            }
        }
        impl MinecraftMath for f64 {
            const MC_PI: Self = JAVA_PI;
            #[inline]
            fn mc_sin(self) -> Self {
                mc_sin(self as f32) as f64
            }
            #[inline]
            fn mc_cos(self) -> Self {
                mc_cos(self as f32) as f64
            }
        }
    }
    pub mod noise {
        //! Perlin and octaves noise generators at parity with Minecraft world generation.
        //!
        //! Note that in this module, every usage of the primitive cast operator `as` that
        //! are narrowing the values are documented and justified to be at parity with the
        //! Java conversion.
        //!
        //! Reference for the narrowing casts in Java:
        //! <https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html>
        use std::mem;
        use std::fmt;
        use glam::{DVec3, DVec2, IVec3};
        use crate::rand::JavaRandom;
        /// A cube of given size for storing noise values.
        #[repr(transparent)]
        pub struct NoiseCube<const X: usize, const Y: usize, const Z: usize> {
            inner: [[[f64; Y]; Z]; X],
        }
        #[automatically_derived]
        impl<const X: usize, const Y: usize, const Z: usize> ::core::clone::Clone
        for NoiseCube<X, Y, Z> {
            #[inline]
            fn clone(&self) -> NoiseCube<X, Y, Z> {
                NoiseCube {
                    inner: ::core::clone::Clone::clone(&self.inner),
                }
            }
        }
        #[automatically_derived]
        impl<
            const X: usize,
            const Y: usize,
            const Z: usize,
        > ::core::marker::StructuralPartialEq for NoiseCube<X, Y, Z> {}
        #[automatically_derived]
        impl<const X: usize, const Y: usize, const Z: usize> ::core::cmp::PartialEq
        for NoiseCube<X, Y, Z> {
            #[inline]
            fn eq(&self, other: &NoiseCube<X, Y, Z>) -> bool {
                self.inner == other.inner
            }
        }
        impl<const X: usize, const Y: usize, const Z: usize> NoiseCube<X, Y, Z> {
            #[inline]
            pub fn new() -> Self {
                Self { inner: [[[0.0; Y]; Z]; X] }
            }
            #[inline]
            pub fn fill(&mut self, value: f64) {
                self.inner = [[[value; Y]; Z]; X];
            }
            #[inline]
            pub fn get(&self, x: usize, y: usize, z: usize) -> f64 {
                self.inner[x][z][y]
            }
            #[inline]
            pub fn set(&mut self, x: usize, y: usize, z: usize, value: f64) {
                self.inner[x][z][y] = value;
            }
            #[inline]
            pub fn add(&mut self, x: usize, y: usize, z: usize, value: f64) {
                self.inner[x][z][y] += value;
            }
        }
        impl<const X: usize, const Y: usize, const Z: usize> Default
        for NoiseCube<X, Y, Z> {
            #[inline]
            fn default() -> Self {
                Self::new()
            }
        }
        impl<const X: usize, const Y: usize, const Z: usize> fmt::Debug
        for NoiseCube<X, Y, Z> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_tuple("NoiseCube").field(&self.inner).finish()
            }
        }
        impl NoiseCube<1, 1, 1> {
            /// Create a reference to a 1x1x1 noise cube from a reference to a single f64.
            #[inline(always)]
            pub fn from_ref(value: &f64) -> &Self {
                const __ASSERT: () = if !(mem::size_of::<NoiseCube<1, 1, 1>>()
                    == mem::size_of::<f64>())
                {
                    ::core::panicking::panic(
                        "assertion failed: mem::size_of::<NoiseCube<1, 1, 1>>() == mem::size_of::<f64>()",
                    )
                };
                unsafe { &*(value as *const f64 as *const Self) }
            }
            /// Create a mutable reference to a 1x1x1 noise cube from a mutable reference to a
            /// single f64.
            #[inline(always)]
            pub fn from_mut(value: &mut f64) -> &mut Self {
                unsafe { &mut *(value as *mut f64 as *mut Self) }
            }
        }
        /// A 3D/2D Perlin noise generator.
        pub struct PerlinNoise {
            /// Offset applied to all position given to the generator.
            offset: DVec3,
            /// All permutations used by Perlin noise algorithm.
            permutations: Box<[u16; 512]>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PerlinNoise {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "PerlinNoise",
                    "offset",
                    &self.offset,
                    "permutations",
                    &&self.permutations,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PerlinNoise {
            #[inline]
            fn clone(&self) -> PerlinNoise {
                PerlinNoise {
                    offset: ::core::clone::Clone::clone(&self.offset),
                    permutations: ::core::clone::Clone::clone(&self.permutations),
                }
            }
        }
        impl PerlinNoise {
            /// Create a new perlin noise initialized with the given RNG.
            pub fn new(rand: &mut JavaRandom) -> Self {
                let offset = rand.next_double_vec() * 256.0;
                let mut permutations = Box::new(
                    std::array::from_fn::<
                        u16,
                        512,
                        _,
                    >(|i| { if i <= 256 { i as u16 } else { 0 } }),
                );
                for index in 0usize..256 {
                    let permutation_index = rand.next_int_bounded(256 - index as i32)
                        as usize + index;
                    permutations.swap(index, permutation_index);
                    permutations[index + 256] = permutations[index];
                }
                Self { offset, permutations }
            }
            /// Get the noise value at given 3D coordinates.
            pub fn gen_3d_point(&self, pos: DVec3) -> f64 {
                let mut pos = pos + self.offset;
                let pos_floor = pos.floor();
                pos -= pos_floor;
                let factor = pos * pos * pos * (pos * (pos * 6.0 - 15.0) + 10.0);
                let pos_int = pos_floor.as_ivec3();
                let x_index = (pos_int.x & 255) as usize;
                let y_index = (pos_int.y & 255) as usize;
                let z_index = (pos_int.z & 255) as usize;
                let a = self.permutations[x_index] as usize + y_index;
                let a0 = self.permutations[a] as usize + z_index;
                let a1 = self.permutations[a + 1] as usize + z_index;
                let b = self.permutations[x_index + 1] as usize + y_index;
                let b0 = self.permutations[b] as usize + z_index;
                let b1 = self.permutations[b + 1] as usize + z_index;
                let DVec3 { x, y, z } = pos;
                lerp(
                    factor.z,
                    lerp(
                        factor.y,
                        lerp(
                            factor.x,
                            grad3(self.permutations[a0], x, y, z),
                            grad3(self.permutations[b0], x - 1.0, y, z),
                        ),
                        lerp(
                            factor.x,
                            grad3(self.permutations[a1], x, y - 1.0, z),
                            grad3(self.permutations[b1], x - 1.0, y - 1.0, z),
                        ),
                    ),
                    lerp(
                        factor.y,
                        lerp(
                            factor.x,
                            grad3(self.permutations[a0 + 1], x, y, z - 1.0),
                            grad3(self.permutations[b0 + 1], x - 1.0, y, z - 1.0),
                        ),
                        lerp(
                            factor.x,
                            grad3(self.permutations[a1 + 1], x, y - 1.0, z - 1.0),
                            grad3(self.permutations[b1 + 1], x - 1.0, y - 1.0, z - 1.0),
                        ),
                    ),
                )
            }
            /// Get the noise value at given 2D coordinates.
            pub fn gen_2d_point(&self, pos: DVec2) -> f64 {
                self.gen_3d_point(pos.extend(0.0))
            }
            /// Generate a 3D noise cube at a given offset with the given scale and frequency.
            pub fn gen_3d<const X: usize, const Y: usize, const Z: usize>(
                &self,
                cube: &mut NoiseCube<X, Y, Z>,
                offset: DVec3,
                scale: DVec3,
                amplitude: f64,
            ) {
                let mut last_y_index = usize::MAX;
                let mut x0 = 0.0;
                let mut x1 = 0.0;
                let mut x2 = 0.0;
                let mut x3 = 0.0;
                for x_cube in 0..X {
                    let (x, x_factor, x_index) = calc_pos(
                        (offset.x + x_cube as f64) * scale.x + self.offset.x,
                    );
                    for z_cube in 0..Z {
                        let (z, z_factor, z_index) = calc_pos(
                            (offset.z + z_cube as f64) * scale.z + self.offset.z,
                        );
                        for y_cube in 0..Y {
                            let (y, y_factor, y_index) = calc_pos(
                                (offset.y + y_cube as f64) * scale.y + self.offset.y,
                            );
                            if y_cube == 0 || y_index != last_y_index {
                                last_y_index = y_index;
                                let a = self.permutations[x_index] as usize + y_index;
                                let a0 = self.permutations[a] as usize + z_index;
                                let a1 = self.permutations[a + 1] as usize + z_index;
                                let b = self.permutations[x_index + 1] as usize + y_index;
                                let b0 = self.permutations[b] as usize + z_index;
                                let b1 = self.permutations[b + 1] as usize + z_index;
                                x0 = lerp(
                                    x_factor,
                                    grad3(self.permutations[a0], x, y, z),
                                    grad3(self.permutations[b0], x - 1.0, y, z),
                                );
                                x1 = lerp(
                                    x_factor,
                                    grad3(self.permutations[a1], x, y - 1.0, z),
                                    grad3(self.permutations[b1], x - 1.0, y - 1.0, z),
                                );
                                x2 = lerp(
                                    x_factor,
                                    grad3(self.permutations[a0 + 1], x, y, z - 1.0),
                                    grad3(self.permutations[b0 + 1], x - 1.0, y, z - 1.0),
                                );
                                x3 = lerp(
                                    x_factor,
                                    grad3(self.permutations[a1 + 1], x, y - 1.0, z - 1.0),
                                    grad3(self.permutations[b1 + 1], x - 1.0, y - 1.0, z - 1.0),
                                );
                            }
                            let noise = lerp(
                                z_factor,
                                lerp(y_factor, x0, x1),
                                lerp(y_factor, x2, x3),
                            );
                            cube.add(x_cube, y_cube, z_cube, noise * amplitude);
                        }
                    }
                }
            }
            /// Generate a 2D noise cube at a given offset with the given scale and frequency.
            pub fn gen_2d<const X: usize, const Z: usize>(
                &self,
                cube: &mut NoiseCube<X, 1, Z>,
                offset: DVec2,
                scale: DVec2,
                amplitude: f64,
            ) {
                for x_cube in 0..X {
                    let (x, x_factor, x_index) = calc_pos(
                        (offset.x + x_cube as f64) * scale.x + self.offset.x,
                    );
                    for z_cube in 0..Z {
                        let (z, z_factor, z_index) = calc_pos(
                            (offset.y + z_cube as f64) * scale.y + self.offset.z,
                        );
                        let a = self.permutations[x_index] as usize + 0;
                        let a0 = self.permutations[a] as usize + z_index;
                        let b = self.permutations[x_index + 1] as usize + 0;
                        let b0 = self.permutations[b] as usize + z_index;
                        let noise = lerp(
                            z_factor,
                            lerp(
                                x_factor,
                                grad2(self.permutations[a0], x, z),
                                grad3(self.permutations[b0], x - 1.0, 0.0, z),
                            ),
                            lerp(
                                x_factor,
                                grad3(self.permutations[a0 + 1], x, 0.0, z - 1.0),
                                grad3(self.permutations[b0 + 1], x - 1.0, 0.0, z - 1.0),
                            ),
                        );
                        cube.add(x_cube, 0, z_cube, noise * amplitude);
                    }
                }
            }
            /// Weird noise generation (a handcrafted noise generator used by Notchian server
            /// that uses the same type of permutations table and offset as the perlin noise, so
            /// we use the same structure).
            ///
            /// The function is to be renamed if the algorithm name is found.
            pub fn gen_weird_2d<const X: usize, const Z: usize>(
                &self,
                cube: &mut NoiseCube<X, 1, Z>,
                offset: DVec2,
                scale: DVec2,
                amplitude: f64,
            ) {
                let const_a: f64 = 0.5 * (f64::sqrt(3.0) - 1.0);
                let const_b: f64 = (3.0 - f64::sqrt(3.0)) / 6.0;
                for x_noise in 0..X {
                    let x = (offset.x + x_noise as f64) * scale.x + self.offset.x;
                    for z_noise in 0..Z {
                        let z = (offset.y + z_noise as f64) * scale.y + self.offset.y;
                        let a = (x + z) * const_a;
                        let x_wrap = wrap(x + a);
                        let z_wrap = wrap(z + a);
                        let b = i32::wrapping_add(x_wrap, z_wrap) as f64 * const_b;
                        let x_wrap_b = x_wrap as f64 - b;
                        let z_wrap_b = z_wrap as f64 - b;
                        let x_delta = x - x_wrap_b;
                        let z_delta = z - z_wrap_b;
                        let (x_offset, z_offset) = if x_delta > z_delta {
                            (1, 0)
                        } else {
                            (0, 1)
                        };
                        let x_delta0 = x_delta - x_offset as f64 + const_b;
                        let z_delta0 = z_delta - z_offset as f64 + const_b;
                        let x_delta1 = x_delta - 1.0 + 2.0 * const_b;
                        let z_delta1 = z_delta - 1.0 + 2.0 * const_b;
                        let x_index = (x_wrap & 255) as usize;
                        let z_index = (z_wrap & 255) as usize;
                        let v0_index = self
                            .permutations[x_index + self.permutations[z_index] as usize]
                            % 12;
                        let v1_index = self
                            .permutations[x_index + x_offset
                            + self.permutations[z_index + z_offset] as usize] % 12;
                        let v2_index = self
                            .permutations[x_index + 1
                            + self.permutations[z_index + 1] as usize] % 12;
                        let v0 = calc_weird_noise(x_delta, z_delta, v0_index as usize);
                        let v1 = calc_weird_noise(x_delta0, z_delta0, v1_index as usize);
                        let v2 = calc_weird_noise(x_delta1, z_delta1, v2_index as usize);
                        cube.add(x_noise, 0, z_noise, 70.0 * (v0 + v1 + v2) * amplitude);
                    }
                }
            }
        }
        /// A Perlin-based octave noise generator.
        pub struct PerlinOctaveNoise {
            /// Collection of generators for the different octaves.
            generators: Box<[PerlinNoise]>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PerlinOctaveNoise {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "PerlinOctaveNoise",
                    "generators",
                    &&self.generators,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PerlinOctaveNoise {
            #[inline]
            fn clone(&self) -> PerlinOctaveNoise {
                PerlinOctaveNoise {
                    generators: ::core::clone::Clone::clone(&self.generators),
                }
            }
        }
        impl PerlinOctaveNoise {
            /// Create a new Perlin-based octaves noise generator.
            pub fn new(rand: &mut JavaRandom, octaves: usize) -> Self {
                Self {
                    generators: (0..octaves)
                        .map(move |_| PerlinNoise::new(rand))
                        .collect::<Vec<_>>()
                        .into_boxed_slice(),
                }
            }
            /// Get the noise value at given 3D coordinates.
            pub fn gen_3d_point(&self, pos: DVec3) -> f64 {
                let mut ret = 0.0;
                let mut freq = 1.0;
                for gen in &self.generators[..] {
                    ret += gen.gen_3d_point(pos * freq) / freq;
                    freq /= 2.0;
                }
                ret
            }
            /// Get the noise value at given 3D coordinates.
            pub fn gen_2d_point(&self, pos: DVec2) -> f64 {
                let mut ret = 0.0;
                let mut freq = 1.0;
                for gen in &self.generators[..] {
                    ret += gen.gen_2d_point(pos * freq) / freq;
                    freq /= 2.0;
                }
                ret
            }
            /// Generate a 3D noise cube at a given offset with the given scale and frequency.
            pub fn gen_3d<const X: usize, const Y: usize, const Z: usize>(
                &self,
                cube: &mut NoiseCube<X, Y, Z>,
                offset: DVec3,
                scale: DVec3,
            ) {
                cube.fill(0.0);
                let mut freq = 1.0;
                for gen in &self.generators[..] {
                    gen.gen_3d(cube, offset, scale * freq, 1.0 / freq);
                    freq /= 2.0;
                }
            }
            /// Generate a 2D noise cube at a given offset with the given scale and frequency.
            pub fn gen_2d<const X: usize, const Z: usize>(
                &self,
                cube: &mut NoiseCube<X, 1, Z>,
                offset: DVec2,
                scale: DVec2,
            ) {
                cube.fill(0.0);
                let mut freq = 1.0;
                for gen in &self.generators[..] {
                    gen.gen_2d(cube, offset, scale * freq, 1.0 / freq);
                    freq /= 2.0;
                }
            }
            /// Weird noise generation (a handcrafted noise generator used by Notchian server
            /// that uses the same type of permutations table and offset as the Perlin noise, so
            /// we use the same structure).
            ///
            /// The function is to be renamed if the algorithm name is found.
            pub fn gen_weird_2d<const X: usize, const Z: usize>(
                &self,
                cube: &mut NoiseCube<X, 1, Z>,
                offset: DVec2,
                scale: DVec2,
                freq_factor: f64,
            ) {
                cube.fill(0.0);
                let scale = scale / 1.5;
                let mut freq = 1.0;
                let mut amplitude = 0.55;
                for gen in &self.generators[..] {
                    gen.gen_weird_2d(cube, offset, scale * freq, amplitude);
                    freq *= freq_factor;
                    amplitude *= 2.0;
                }
            }
        }
        #[inline]
        fn lerp(factor: f64, from: f64, to: f64) -> f64 {
            from + factor * (to - from)
        }
        #[inline]
        fn grad3(value: u16, x: f64, y: f64, z: f64) -> f64 {
            let value = value & 15;
            let a = if value < 8 { x } else { y };
            let b = if value < 4 {
                y
            } else if value != 12 && value != 14 {
                z
            } else {
                x
            };
            (if value & 1 == 0 { a } else { -a }) + (if value & 2 == 0 { b } else { -b })
        }
        #[inline]
        fn grad2(value: u16, x: f64, z: f64) -> f64 {
            let value = value & 15;
            let a = (1 - ((value & 8) >> 3)) as f64 * x;
            let b = if value < 4 {
                0.0
            } else if value != 12 && value != 14 {
                z
            } else {
                x
            };
            (if value & 1 == 0 { a } else { -a }) + (if value & 2 == 0 { b } else { -b })
        }
        #[inline]
        fn calc_pos(mut pos: f64) -> (f64, f64, usize) {
            let mut floor = pos as i32;
            if pos < floor as f64 {
                floor = floor.wrapping_sub(1);
            }
            pos -= floor as f64;
            let factor = pos * pos * pos * (pos * (pos * 6.0 - 15.0) + 10.0);
            let index = (floor & 255) as usize;
            (pos, factor, index)
        }
        #[inline]
        fn wrap(value: f64) -> i32 {
            let ret = value as i32;
            if value > 0.0 { ret } else { ret.wrapping_sub(1) }
        }
        #[inline]
        fn calc_weird_noise(x_delta: f64, z_delta: f64, index: usize) -> f64 {
            static WEIRD_TABLE: [IVec3; 12] = [
                IVec3::new(1, 1, 0),
                IVec3::new(-1, 1, 0),
                IVec3::new(1, -1, 0),
                IVec3::new(-1, -1, 0),
                IVec3::new(1, 0, 1),
                IVec3::new(-1, 0, 1),
                IVec3::new(1, 0, -1),
                IVec3::new(-1, 0, -1),
                IVec3::new(0, 1, 1),
                IVec3::new(0, -1, 1),
                IVec3::new(0, 1, -1),
                IVec3::new(0, -1, -1),
            ];
            let tmp = 0.5 - x_delta * x_delta - z_delta * z_delta;
            if tmp < 0.0 {
                0.0
            } else {
                let tmp = tmp * tmp;
                let weird = WEIRD_TABLE[index];
                tmp * tmp * (weird.x as f64 * x_delta + weird.y as f64 * z_delta)
            }
        }
    }
    pub mod dungeon {
        //! Dungeon generator.
        use glam::IVec3;
        use crate::block_entity::spawner::SpawnerBlockEntity;
        use crate::block_entity::chest::ChestBlockEntity;
        use crate::block_entity::BlockEntity;
        use crate::item::{ItemStack, self};
        use crate::entity::EntityKind;
        use crate::rand::JavaRandom;
        use crate::world::World;
        use crate::geom::Face;
        use crate::block;
        use super::FeatureGenerator;
        /// A generator for mob spawner dungeon.
        pub struct DungeonGenerator {}
        impl DungeonGenerator {
            pub fn new() -> Self {
                Self {}
            }
        }
        impl DungeonGenerator {
            fn gen_chest_stack(&self, rand: &mut JavaRandom) -> ItemStack {
                match rand.next_int_bounded(11) {
                    0 => ItemStack::new_single(item::SADDLE, 0),
                    1 => {
                        ItemStack::new_sized(
                            item::IRON_INGOT,
                            0,
                            rand.next_int_bounded(4) as u16 + 1,
                        )
                    }
                    2 => ItemStack::new_single(item::BREAD, 0),
                    3 => ItemStack::new_single(item::BREAD, 0),
                    4 => {
                        ItemStack::new_sized(
                            item::GUNPOWDER,
                            0,
                            rand.next_int_bounded(4) as u16 + 1,
                        )
                    }
                    5 => {
                        ItemStack::new_sized(
                            item::STRING,
                            0,
                            rand.next_int_bounded(4) as u16 + 1,
                        )
                    }
                    6 => ItemStack::new_single(item::BUCKET, 0),
                    7 if rand.next_int_bounded(100) == 0 => {
                        ItemStack::new_single(item::GOLD_APPLE, 0)
                    }
                    8 if rand.next_int_bounded(2) == 0 => {
                        ItemStack::new_sized(
                            item::REDSTONE,
                            0,
                            rand.next_int_bounded(4) as u16 + 1,
                        )
                    }
                    9 if rand.next_int_bounded(10) == 0 => {
                        match rand.next_int_bounded(2) {
                            0 => ItemStack::new_single(item::RECORD_13, 0),
                            1 => ItemStack::new_single(item::RECORD_CAT, 0),
                            _ => {
                                ::core::panicking::panic(
                                    "internal error: entered unreachable code",
                                )
                            }
                        }
                    }
                    10 => ItemStack::new_single(item::DYE, 3),
                    _ => ItemStack::EMPTY,
                }
            }
            fn gen_spawner_entity(&self, rand: &mut JavaRandom) -> EntityKind {
                match rand.next_int_bounded(4) {
                    0 => EntityKind::Skeleton,
                    1 | 2 => EntityKind::Zombie,
                    3 => EntityKind::Spider,
                    _ => {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                }
            }
        }
        impl FeatureGenerator for DungeonGenerator {
            fn generate(
                &mut self,
                world: &mut World,
                pos: IVec3,
                rand: &mut JavaRandom,
            ) -> bool {
                let x_radius = rand.next_int_bounded(2) + 2;
                let z_radius = rand.next_int_bounded(2) + 2;
                let height = 3;
                let mut air_count = 0usize;
                let start = pos - IVec3::new(x_radius + 1, 1, x_radius + 1);
                let end = pos + IVec3::new(x_radius + 1, height + 1, x_radius + 1);
                for x in start.x..=end.x {
                    for y in start.y..=end.y {
                        for z in start.z..=end.z {
                            let check_pos = IVec3::new(x, y, z);
                            let check_material = world.get_block_material(check_pos);
                            if y == start.y && !check_material.is_solid() {
                                return false;
                            } else if y == end.y && !check_material.is_solid() {
                                return false;
                            } else if y == pos.y
                                && (x == start.x || x == end.x || z == start.z
                                    || z == end.z)
                            {
                                if world.is_block_air(check_pos)
                                    && world.is_block_air(check_pos + IVec3::Y)
                                {
                                    air_count += 1;
                                }
                            }
                        }
                    }
                }
                if air_count < 1 || air_count > 5 {
                    return false;
                }
                for x in start.x..=end.x {
                    for y in (start.y..end.y).rev() {
                        for z in start.z..=end.z {
                            let carve_pos = IVec3::new(x, y, z);
                            if x != start.x && y != start.y && z != start.z && x != end.x
                                && z != end.z
                            {
                                world.set_block(carve_pos, block::AIR, 0);
                            } else if y >= 0
                                && !world
                                    .get_block_material(carve_pos - IVec3::Y)
                                    .is_solid()
                            {
                                world.set_block(carve_pos, block::AIR, 0);
                            } else if world.get_block_material(carve_pos).is_solid() {
                                if y == start.y && rand.next_int_bounded(4) != 0 {
                                    world.set_block(carve_pos, block::MOSSY_COBBLESTONE, 0);
                                } else {
                                    world.set_block(carve_pos, block::COBBLESTONE, 0);
                                }
                            }
                        }
                    }
                }
                for _ in 0..2 {
                    'chest_try: for _ in 0..3 {
                        let chest_pos = pos
                            + IVec3 {
                                x: rand.next_int_bounded(x_radius * 2 + 1) - x_radius,
                                y: 0,
                                z: rand.next_int_bounded(z_radius * 2 + 1) - z_radius,
                            };
                        if world.is_block_air(pos) {
                            let mut solid_count = 0usize;
                            for face in Face::HORIZONTAL {
                                if world
                                    .get_block_material(chest_pos + face.delta())
                                    .is_solid()
                                {
                                    solid_count += 1;
                                    if solid_count > 1 {
                                        continue 'chest_try;
                                    }
                                }
                            }
                            if solid_count == 0 {
                                continue 'chest_try;
                            }
                            let mut chest = ChestBlockEntity::default();
                            for _ in 0..8 {
                                let stack = self.gen_chest_stack(rand);
                                if !stack.is_empty() {
                                    *rand.next_choice_mut(&mut chest.inv[..]) = stack;
                                }
                            }
                            world.set_block(chest_pos, block::CHEST, 0);
                            world.set_block_entity(chest_pos, BlockEntity::Chest(chest));
                            break;
                        }
                    }
                }
                let mut spawner = SpawnerBlockEntity::default();
                spawner.entity_kind = self.gen_spawner_entity(rand);
                world.set_block(pos, block::SPAWNER, 0);
                world.set_block_entity(pos, BlockEntity::Spawner(spawner));
                true
            }
        }
    }
    pub mod plant {
        //! Plants feature generation.
        use glam::IVec3;
        use crate::block::material::Material;
        use crate::rand::JavaRandom;
        use crate::world::World;
        use crate::geom::Face;
        use crate::block;
        use super::FeatureGenerator;
        /// A generator for flower patch.
        pub struct PlantGenerator {
            plant_id: u8,
            plant_metadata: u8,
            count: u8,
            find_ground: bool,
        }
        impl PlantGenerator {
            #[inline]
            pub fn new(
                plant_id: u8,
                plant_metadata: u8,
                count: u8,
                find_ground: bool,
            ) -> Self {
                Self {
                    plant_id,
                    plant_metadata,
                    count,
                    find_ground,
                }
            }
            #[inline]
            pub fn new_flower(flower_id: u8) -> Self {
                Self::new(flower_id, 0, 64, false)
            }
            #[inline]
            pub fn new_tall_grass(metadata: u8) -> Self {
                Self::new(block::TALL_GRASS, metadata, 128, true)
            }
            #[inline]
            pub fn new_dead_bush() -> Self {
                Self::new(block::DEAD_BUSH, 0, 4, true)
            }
        }
        impl FeatureGenerator for PlantGenerator {
            fn generate(
                &mut self,
                world: &mut World,
                mut pos: IVec3,
                rand: &mut JavaRandom,
            ) -> bool {
                if self.find_ground {
                    while pos.y > 0 {
                        if !match world.get_block(pos) {
                            Some((block::AIR | block::LEAVES, _)) => true,
                            _ => false,
                        } {
                            break;
                        }
                        pos.y -= 1;
                    }
                }
                for _ in 0..self.count {
                    let place_pos = pos
                        + IVec3 {
                            x: rand.next_int_bounded(8) - rand.next_int_bounded(8),
                            y: rand.next_int_bounded(4) - rand.next_int_bounded(4),
                            z: rand.next_int_bounded(8) - rand.next_int_bounded(8),
                        };
                    if world.is_block_air(place_pos)
                        && world.can_place_block(place_pos, Face::NegY, self.plant_id)
                    {
                        world.set_block(place_pos, self.plant_id, self.plant_metadata);
                    }
                }
                true
            }
        }
        /// A generator for sugar canes.
        pub struct SugarCanesGenerator(());
        impl SugarCanesGenerator {
            #[inline]
            pub fn new() -> Self {
                Self(())
            }
        }
        impl FeatureGenerator for SugarCanesGenerator {
            fn generate(
                &mut self,
                world: &mut World,
                pos: IVec3,
                rand: &mut JavaRandom,
            ) -> bool {
                for _ in 0..20 {
                    let place_pos = pos
                        + IVec3 {
                            x: rand.next_int_bounded(4) - rand.next_int_bounded(4),
                            y: 0,
                            z: rand.next_int_bounded(4) - rand.next_int_bounded(4),
                        };
                    if world.is_block_air(place_pos) {
                        for face in Face::HORIZONTAL {
                            if world
                                .get_block_material(place_pos - IVec3::Y + face.delta())
                                == Material::Water
                            {
                                let v = rand.next_int_bounded(3) + 1;
                                let height = rand.next_int_bounded(v) + 2;
                                if world
                                    .can_place_block(place_pos, Face::NegY, block::SUGAR_CANES)
                                {
                                    for dy in 0..height {
                                        world
                                            .set_block(
                                                place_pos + IVec3::new(0, dy, 0),
                                                block::SUGAR_CANES,
                                                0,
                                            );
                                    }
                                }
                            }
                        }
                    }
                }
                true
            }
        }
        /// A generator for pumpkin.
        pub struct PumpkinGenerator(());
        impl PumpkinGenerator {
            #[inline]
            pub fn new() -> Self {
                Self(())
            }
        }
        impl FeatureGenerator for PumpkinGenerator {
            fn generate(
                &mut self,
                world: &mut World,
                pos: IVec3,
                rand: &mut JavaRandom,
            ) -> bool {
                for _ in 0..64 {
                    let place_pos = pos
                        + IVec3 {
                            x: rand.next_int_bounded(8) - rand.next_int_bounded(8),
                            y: rand.next_int_bounded(4) - rand.next_int_bounded(4),
                            z: rand.next_int_bounded(8) - rand.next_int_bounded(8),
                        };
                    if world.is_block_air(place_pos)
                        && world.is_block(place_pos - IVec3::Y, block::GRASS)
                    {
                        world
                            .set_block(
                                place_pos,
                                block::PUMPKIN,
                                rand.next_int_bounded(4) as u8,
                            );
                    }
                }
                true
            }
        }
        /// A generator for cactus.
        pub struct CactusGenerator(());
        impl CactusGenerator {
            #[inline]
            pub fn new() -> Self {
                Self(())
            }
        }
        impl FeatureGenerator for CactusGenerator {
            fn generate(
                &mut self,
                world: &mut World,
                pos: IVec3,
                rand: &mut JavaRandom,
            ) -> bool {
                for _ in 0..10 {
                    let place_pos = pos
                        + IVec3 {
                            x: rand.next_int_bounded(8) - rand.next_int_bounded(8),
                            y: rand.next_int_bounded(4) - rand.next_int_bounded(4),
                            z: rand.next_int_bounded(8) - rand.next_int_bounded(8),
                        };
                    if world.is_block_air(place_pos) {
                        let v = rand.next_int_bounded(3) + 1;
                        let height = rand.next_int_bounded(v) + 1;
                        for dy in 0..height {
                            if world
                                .can_place_block(place_pos, Face::NegY, block::CACTUS)
                            {
                                world
                                    .set_block(
                                        place_pos + IVec3::new(0, dy, 0),
                                        block::CACTUS,
                                        0,
                                    );
                            }
                        }
                    }
                }
                true
            }
        }
    }
    pub mod vein {
        //! Clay and ore patch feature.
        use glam::{IVec3, DVec3};
        use crate::rand::JavaRandom;
        use crate::world::World;
        use crate::block;
        use super::math::MinecraftMath;
        use super::FeatureGenerator;
        /// A generator for mob spawner dungeon.
        pub struct VeinGenerator {
            replace_id: u8,
            place_id: u8,
            count: u8,
        }
        impl VeinGenerator {
            #[inline]
            pub fn new(replace_id: u8, place_id: u8, count: u8) -> Self {
                Self {
                    replace_id,
                    place_id,
                    count,
                }
            }
            #[inline]
            pub fn new_clay(count: u8) -> Self {
                Self::new(block::SAND, block::CLAY, count)
            }
            #[inline]
            pub fn new_ore(place_id: u8, count: u8) -> Self {
                Self::new(block::STONE, place_id, count)
            }
        }
        impl FeatureGenerator for VeinGenerator {
            fn generate(
                &mut self,
                world: &mut World,
                pos: IVec3,
                rand: &mut JavaRandom,
            ) -> bool {
                let angle = rand.next_float() * f32::MC_PI;
                let (angle_sin, angle_cos) = angle.mc_sin_cos();
                let angle_sin = angle_sin * self.count as f32 / 8.0;
                let angle_cos = angle_cos * self.count as f32 / 8.0;
                let line_start = DVec3 {
                    x: ((pos.x + 8) as f32 + angle_sin) as f64,
                    y: (pos.y + rand.next_int_bounded(3) + 2) as f64,
                    z: ((pos.z + 8) as f32 + angle_cos) as f64,
                };
                let line_stop = DVec3 {
                    x: ((pos.x + 8) as f32 - angle_sin) as f64,
                    y: (pos.y + rand.next_int_bounded(3) + 2) as f64,
                    z: ((pos.z + 8) as f32 - angle_cos) as f64,
                };
                for i in 0..=self.count {
                    let center_pos = line_start
                        + (line_stop - line_start) * i as f64 / self.count as f64;
                    let base_size = rand.next_double() * self.count as f64 / 16.0;
                    let size = ((i as f32 * f32::MC_PI / self.count as f32).mc_sin()
                        + 1.0) as f64 * base_size + 1.0;
                    let half_size = size / 2.0;
                    let start = (center_pos - half_size).floor().as_ivec3();
                    let stop = (center_pos + half_size).floor().as_ivec3();
                    for x in start.x..=stop.x {
                        for z in start.z..=stop.z {
                            for y in start.y..=stop.y {
                                let place_pos = IVec3::new(x, y, z);
                                let delta = (place_pos.as_dvec3() + 0.5 - center_pos)
                                    / half_size;
                                if delta.length_squared() < 1.0 {
                                    if world.is_block(place_pos, self.replace_id) {
                                        world.set_block(place_pos, self.place_id, 0);
                                    }
                                }
                            }
                        }
                    }
                }
                true
            }
        }
    }
    pub mod liquid {
        //! Liquids generation.
        use glam::{IVec3, DVec3};
        use crate::rand::JavaRandom;
        use crate::world::World;
        use crate::geom::Face;
        use crate::block;
        use super::FeatureGenerator;
        /// A generator for lakes.
        pub struct LakeGenerator {
            fluid_id: u8,
        }
        impl LakeGenerator {
            /// Create a new lake generator for the given block id.
            #[inline]
            pub fn new(fluid_id: u8) -> Self {
                Self { fluid_id }
            }
        }
        impl FeatureGenerator for LakeGenerator {
            fn generate(
                &mut self,
                world: &mut World,
                mut pos: IVec3,
                rand: &mut JavaRandom,
            ) -> bool {
                pos -= IVec3::new(8, 0, 8);
                while pos.y > 0 && world.is_block_air(pos) {
                    pos.y -= 1;
                }
                pos.y -= 4;
                let mut fill = Box::new([[[false; 8]; 16]; 16]);
                let count = rand.next_int_bounded(4) + 4;
                for _ in 0..count {
                    let a = rand.next_double_vec() * DVec3::new(6.0, 4.0, 6.0)
                        + DVec3::new(3.0, 2.0, 3.0);
                    let b = rand.next_double_vec()
                        * (DVec3::new(16.0, 8.0, 16.0) - a - DVec3::new(2.0, 4.0, 2.0))
                        + DVec3::new(1.0, 2.0, 1.0) + a / 2.0;
                    let a = a / 2.0;
                    for dx in 1..15 {
                        for dz in 1..15 {
                            for dy in 1..7 {
                                let dist = (DVec3::new(dx as f64, dy as f64, dz as f64) - b)
                                    / a;
                                if dist.length_squared() < 1.0 {
                                    fill[dx][dz][dy] = true;
                                }
                            }
                        }
                    }
                }
                for dx in 0..16 {
                    for dz in 0..16 {
                        for dy in 0..8 {
                            let filled = !fill[dx][dz][dy]
                                && (dx < 15 && fill[dx + 1][dz][dy]
                                    || dx > 0 && fill[dx - 1][dz][dy]
                                    || dz < 15 && fill[dx][dz + 1][dy]
                                    || dz > 0 && fill[dx][dz - 1][dy]
                                    || dy < 7 && fill[dx][dz][dy + 1]
                                    || dy > 0 && fill[dx][dz][dy - 1]);
                            if filled {
                                let check_pos = pos
                                    + IVec3::new(dx as i32, dy as i32, dz as i32);
                                let check_id = world
                                    .get_block(check_pos)
                                    .map(|(id, _)| id)
                                    .unwrap_or(block::AIR);
                                let check_material = block::material::get_material(
                                    check_id,
                                );
                                if dy >= 4 && check_material.is_fluid() {
                                    return false;
                                } else if dy < 4 && !check_material.is_solid()
                                    && check_id != self.fluid_id
                                {
                                    return false;
                                }
                            }
                        }
                    }
                }
                for dx in 0..16 {
                    for dz in 0..16 {
                        for dy in 0..8 {
                            if fill[dx][dz][dy] {
                                let place_pos = pos
                                    + IVec3::new(dx as i32, dy as i32, dz as i32);
                                world
                                    .set_block(
                                        place_pos,
                                        if dy >= 4 { block::AIR } else { self.fluid_id },
                                        0,
                                    );
                            }
                        }
                    }
                }
                for dx in 0..16 {
                    for dz in 0..16 {
                        for dy in 4..8 {
                            if fill[dx][dz][dy] {
                                let check_pos = pos
                                    + IVec3::new(dx as i32, dy as i32 - 1, dz as i32);
                                if world.is_block(check_pos, block::DIRT) {
                                    if world.get_light(check_pos).sky > 0 {
                                        world.set_block(check_pos, block::GRASS, 0);
                                    }
                                }
                            }
                        }
                    }
                }
                if let block::LAVA_STILL | block::LAVA_MOVING = self.fluid_id {
                    for dx in 0..16 {
                        for dz in 0..16 {
                            for dy in 0..8 {
                                let filled = !fill[dx][dz][dy]
                                    && (dx < 15 && fill[dx + 1][dz][dy]
                                        || dx > 0 && fill[dx - 1][dz][dy]
                                        || dz < 15 && fill[dx][dz + 1][dy]
                                        || dz > 0 && fill[dx][dz - 1][dy]
                                        || dy < 7 && fill[dx][dz][dy + 1]
                                        || dy > 0 && fill[dx][dz][dy - 1]);
                                if filled && (dy < 4 || rand.next_int_bounded(2) != 0) {
                                    let place_pos = pos
                                        + IVec3::new(dx as i32, dy as i32, dz as i32);
                                    if world.get_block_material(place_pos).is_solid() {
                                        world.set_block(place_pos, block::STONE, 0);
                                    }
                                }
                            }
                        }
                    }
                }
                true
            }
        }
        /// A generator for single liquid blocks.
        pub struct LiquidGenerator {
            fluid_id: u8,
        }
        impl LiquidGenerator {
            /// Create a new liquid generator for the given block id.
            #[inline]
            pub fn new(fluid_id: u8) -> Self {
                Self { fluid_id }
            }
        }
        impl FeatureGenerator for LiquidGenerator {
            fn generate(
                &mut self,
                world: &mut World,
                pos: IVec3,
                _rand: &mut JavaRandom,
            ) -> bool {
                if !world.is_block(pos + IVec3::Y, block::STONE) {
                    return false;
                } else if !world.is_block(pos - IVec3::Y, block::STONE) {
                    return false;
                } else if !match world.get_block(pos) {
                    Some((block::AIR | block::STONE, _)) => true,
                    _ => false,
                } {
                    return false;
                }
                let mut stone_count = 0;
                let mut air_count = 0;
                for face in Face::HORIZONTAL {
                    match world.get_block(pos + face.delta()) {
                        Some((block::STONE, _)) => stone_count += 1,
                        None | Some((block::AIR, _)) => air_count += 1,
                        _ => {}
                    }
                }
                if stone_count == 3 && air_count == 1 {
                    world.set_block(pos, self.fluid_id, 0);
                }
                true
            }
        }
    }
    pub mod tree {
        //! Tree generation functions.
        use glam::IVec3;
        use crate::rand::JavaRandom;
        use crate::world::World;
        use crate::block;
        use super::FeatureGenerator;
        /// A feature generator for simple trees of varying blocks and height.
        pub struct SimpleTreeGenerator {
            /// Minimum height for the simple tree.
            min_height: u8,
            /// Metadata to apply to wood and leaves.
            metadata: u8,
        }
        impl SimpleTreeGenerator {
            #[inline]
            pub fn new(min_height: u8, metadata: u8) -> Self {
                Self { min_height, metadata }
            }
            #[inline]
            pub fn new_oak() -> Self {
                Self::new(4, 0)
            }
            #[inline]
            pub fn new_birch() -> Self {
                Self::new(5, 2)
            }
        }
        impl FeatureGenerator for SimpleTreeGenerator {
            fn generate(
                &mut self,
                world: &mut World,
                pos: IVec3,
                rand: &mut JavaRandom,
            ) -> bool {
                let height = rand.next_int_bounded(3) + self.min_height as i32;
                let check_radius = |y| {
                    if y == pos.y { 0 } else if y >= pos.y + height - 1 { 2 } else { 1 }
                };
                if !check_tree(world, pos, height, check_radius) {
                    return false;
                }
                world.set_block(pos - IVec3::Y, block::DIRT, 0);
                for y in (pos.y + height - 3)..=(pos.y + height) {
                    let dy = y - (pos.y + height);
                    let radius = 1 - dy / 2;
                    for x in pos.x - radius..=pos.x + radius {
                        for z in pos.z - radius..=pos.z + radius {
                            let dx = (x - pos.x).abs();
                            let dz = (z - pos.z).abs();
                            if dx != radius || dz != radius
                                || (rand.next_int_bounded(2) != 0 && dy != 0)
                            {
                                let replace_pos = IVec3::new(x, y, z);
                                if !world.is_block_opaque_cube(replace_pos) {
                                    world.set_block(replace_pos, block::LEAVES, self.metadata);
                                }
                            }
                        }
                    }
                }
                for y in pos.y..(pos.y + height) {
                    let replace_pos = IVec3::new(pos.x, y, pos.z);
                    if let Some((block::AIR | block::LEAVES, _)) = world
                        .get_block(replace_pos)
                    {
                        world.set_block(replace_pos, block::LOG, self.metadata);
                    }
                }
                true
            }
        }
        /// Generator for big oak trees.
        pub struct BigTreeGenerator {
            height_range: i32,
            height_attenuation: f32,
            leaf_density: f32,
            branch_delta_height: i32,
            branch_scale: f32,
            branch_slope: f32,
        }
        impl FeatureGenerator for BigTreeGenerator {
            fn generate(
                &mut self,
                world: &mut World,
                pos: IVec3,
                rand: &mut JavaRandom,
            ) -> bool {
                let mut rand = JavaRandom::new(rand.next_long());
                let mut height = rand.next_int_bounded(self.height_range) + 5;
                if !match world.get_block(pos - IVec3::Y) {
                    Some((block::GRASS | block::DIRT, _)) => true,
                    _ => false,
                } {
                    return false;
                }
                let main_branch_from = pos;
                let main_branch_to = pos + IVec3::new(0, height, 0);
                match self.check_big_tree_branch(world, main_branch_from, main_branch_to)
                {
                    Some(new_to) => {
                        if new_to.y - pos.y < 6 {
                            return false;
                        } else {
                            height = new_to.y - pos.y;
                        }
                    }
                    None => {}
                }
                let mut height_attenuated = (height as f32 * self.height_attenuation)
                    as i32;
                if height_attenuated >= height {
                    height_attenuated = height - 1;
                }
                let nodes_per_height = ((1.382
                    + (self.leaf_density * height as f32 / 13.0).powi(2)) as i32)
                    .max(1) as usize;
                let mut nodes = Vec::with_capacity(nodes_per_height * height as usize);
                let mut leaf_offset = height - self.branch_delta_height;
                let mut leaf_y = pos.y + leaf_offset;
                let start_y = pos.y + height_attenuated;
                nodes
                    .push(BigTreeNode {
                        pos: IVec3::new(pos.x, leaf_y, pos.z),
                        start_y,
                    });
                leaf_y -= 1;
                while leaf_offset >= 0 {
                    let size = self.calc_big_tree_layer_size(leaf_offset, height);
                    if size >= 0.0 {
                        for _ in 0..nodes_per_height {
                            let length = self.branch_scale * size as f32
                                * (rand.next_float() + 0.328);
                            let angle = rand.next_float() * 2.0 * 3.14159;
                            let leaf_x = (length * angle.sin() + pos.x as f32 + 0.5)
                                .floor() as i32;
                            let leaf_z = (length * angle.cos() + pos.z as f32 + 0.5)
                                .floor() as i32;
                            let leaf_pos = IVec3::new(leaf_x, leaf_y, leaf_z);
                            let leaf_check_pos = leaf_pos
                                + IVec3::new(0, self.branch_delta_height, 0);
                            if self
                                .check_big_tree_branch(world, leaf_pos, leaf_check_pos)
                                .is_none()
                            {
                                let horiz_dist = (((pos.x as f32 - leaf_x as f32).powi(2)
                                    + (pos.z as f32 - leaf_z as f32).powi(2)))
                                    .sqrt();
                                let leaf_start_delta = horiz_dist * self.branch_slope;
                                let leaf_start_y = ((leaf_y as f32 - leaf_start_delta)
                                    as i32)
                                    .min(start_y);
                                let leaf_start_pos = IVec3::new(pos.x, leaf_start_y, pos.z);
                                if self
                                    .check_big_tree_branch(world, leaf_start_pos, leaf_pos)
                                    .is_none()
                                {
                                    nodes
                                        .push(BigTreeNode {
                                            pos: leaf_pos,
                                            start_y: leaf_start_y,
                                        });
                                }
                            }
                        }
                    }
                    leaf_y -= 1;
                    leaf_offset -= 1;
                }
                for node in &nodes {
                    self.place_big_tree_leaf(world, node.pos);
                }
                self.place_big_tree_branch(
                    world,
                    pos,
                    pos + IVec3::new(0, height_attenuated, 0),
                );
                let min_height = height as f32 * 0.2;
                for node in &nodes {
                    if (node.start_y - pos.y) as f32 >= min_height {
                        self.place_big_tree_branch(
                            world,
                            IVec3::new(pos.x, node.start_y, pos.z),
                            node.pos,
                        );
                    }
                }
                true
            }
        }
        impl BigTreeGenerator {
            #[inline]
            pub fn new() -> Self {
                Self {
                    height_range: 12,
                    height_attenuation: 0.618,
                    leaf_density: 1.0,
                    branch_delta_height: 4,
                    branch_scale: 1.0,
                    branch_slope: 0.381,
                }
            }
            /// Create a new big tree generator for natural generation, it has some slight
            /// modification from the default one, such as the branch delta height.
            #[inline]
            pub fn new_natural() -> Self {
                let mut ret = Self::new();
                ret.branch_delta_height = 5;
                ret
            }
            /// Grow a big tree leaf ball of leaves.
            fn place_big_tree_leaf(&self, world: &mut World, pos: IVec3) {
                for dy in 0..self.branch_delta_height {
                    let radius = if dy != 0 && dy != self.branch_delta_height - 1 {
                        3.0
                    } else {
                        2.0
                    };
                    self.place_big_tree_leaf_layer(
                        world,
                        pos + IVec3::new(0, dy, 0),
                        radius,
                    );
                }
            }
            /// Grow a single horizontal layer of leaves of given radius.
            fn place_big_tree_leaf_layer(
                &self,
                world: &mut World,
                pos: IVec3,
                radius: f32,
            ) {
                let block_radius = (radius + 0.618) as i32;
                for dx in -block_radius..=block_radius {
                    for dz in -block_radius..=block_radius {
                        let dist = ((dx.abs() as f32 + 0.5).powi(2)
                            + (dz.abs() as f32 + 0.5).powi(2))
                            .sqrt();
                        if dist <= radius {
                            let replace_pos = pos + IVec3::new(dx, 0, dz);
                            if let Some((block::AIR | block::LEAVES, _)) = world
                                .get_block(replace_pos)
                            {
                                world.set_block(replace_pos, block::LEAVES, 0);
                            }
                        }
                    }
                }
            }
            /// Place a branch from a position to another one.
            fn place_big_tree_branch(&self, world: &mut World, from: IVec3, to: IVec3) {
                for pos in BlockLineIter::new(from, to) {
                    world.set_block(pos, block::LOG, 0);
                }
            }
            /// Check a big tree branch, this function returns the first position on the line
            /// that is not valid for growing a branch.
            /// If none is returned then the branch is fully valid.
            fn check_big_tree_branch(
                &self,
                world: &mut World,
                from: IVec3,
                to: IVec3,
            ) -> Option<IVec3> {
                for pos in BlockLineIter::new(from, to) {
                    if !match world.get_block(pos) {
                        Some((block::AIR | block::LEAVES, _)) => true,
                        _ => false,
                    } {
                        return Some(pos);
                    }
                }
                None
            }
            fn calc_big_tree_layer_size(&self, leaf_offset: i32, height: i32) -> f32 {
                if (leaf_offset as f64) < (height as f64 * 0.3) {
                    return -1.618;
                }
                let a = height as f32 / 2.0;
                let b = a - leaf_offset as f32;
                (if b == 0.0 {
                    a
                } else if b.abs() >= a {
                    0.0
                } else {
                    (a.abs().powi(2) - b.abs().powi(2)).sqrt()
                }) * 0.5
            }
        }
        struct BigTreeNode {
            /// Center of the leaves node.
            pos: IVec3,
            /// Start Y position on the main branch.
            start_y: i32,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for BigTreeNode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "BigTreeNode",
                    "pos",
                    &self.pos,
                    "start_y",
                    &&self.start_y,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for BigTreeNode {
            #[inline]
            fn clone(&self) -> BigTreeNode {
                let _: ::core::clone::AssertParamIsClone<IVec3>;
                let _: ::core::clone::AssertParamIsClone<i32>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for BigTreeNode {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for BigTreeNode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for BigTreeNode {
            #[inline]
            fn eq(&self, other: &BigTreeNode) -> bool {
                self.pos == other.pos && self.start_y == other.start_y
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for BigTreeNode {}
        #[automatically_derived]
        impl ::core::cmp::Eq for BigTreeNode {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<IVec3>;
                let _: ::core::cmp::AssertParamIsEq<i32>;
            }
        }
        pub struct Spruce1TreeGenerator(());
        impl Spruce1TreeGenerator {
            pub fn new() -> Self {
                Self(())
            }
        }
        impl FeatureGenerator for Spruce1TreeGenerator {
            fn generate(
                &mut self,
                world: &mut World,
                pos: IVec3,
                rand: &mut JavaRandom,
            ) -> bool {
                let height = rand.next_int_bounded(5) + 7;
                let leaves_offset = height - rand.next_int_bounded(2) - 3;
                let leaves_height = height - leaves_offset;
                let max_radius = rand.next_int_bounded(leaves_height + 1);
                let leaves_y = pos.y + leaves_offset;
                let check_radius = |y| { if y < leaves_y { 0 } else { max_radius } };
                if !check_tree(world, pos, height, check_radius) {
                    return false;
                }
                world.set_block(pos - IVec3::Y, block::DIRT, 0);
                let mut current_radius = 0;
                for y in leaves_y..=(pos.y + height) {
                    for x in pos.x - current_radius..=pos.x + current_radius {
                        for z in pos.z - current_radius..=pos.z + current_radius {
                            let dx = (x - pos.x).abs();
                            let dz = (z - pos.z).abs();
                            if dx != current_radius || dz != current_radius
                                || current_radius <= 0
                            {
                                let replace_pos = IVec3::new(x, y, z);
                                if !world.is_block_opaque_cube(replace_pos) {
                                    world.set_block(replace_pos, block::LEAVES, 1);
                                }
                            }
                        }
                    }
                    if current_radius >= 1 && y == leaves_y + 1 {
                        current_radius -= 1;
                    } else if current_radius < max_radius {
                        current_radius += 1;
                    }
                }
                for y in pos.y..(pos.y + height - 1) {
                    let replace_pos = IVec3::new(pos.x, y, pos.z);
                    if let Some((block::AIR | block::LEAVES, _)) = world
                        .get_block(replace_pos)
                    {
                        world.set_block(replace_pos, block::LOG, 1);
                    }
                }
                true
            }
        }
        /// A generator for a spruce (variation 2) tree.
        pub struct Spruce2TreeGenerator(());
        impl Spruce2TreeGenerator {
            pub fn new() -> Self {
                Self(())
            }
        }
        impl FeatureGenerator for Spruce2TreeGenerator {
            fn generate(
                &mut self,
                world: &mut World,
                pos: IVec3,
                rand: &mut JavaRandom,
            ) -> bool {
                let height = rand.next_int_bounded(4) + 6;
                let leaves_offset = rand.next_int_bounded(2) + 1;
                let leaves_height = height - leaves_offset;
                let max_radius = rand.next_int_bounded(2) + 2;
                let leaves_y = pos.y + leaves_offset;
                let check_radius = |y| { if y < leaves_y { 0 } else { max_radius } };
                if !check_tree(world, pos, height, check_radius) {
                    return false;
                }
                world.set_block(pos - IVec3::Y, block::DIRT, 0);
                let mut current_radius = rand.next_int_bounded(2);
                let mut start_radius = 0;
                let mut global_radius = 1;
                for dy in 0..=leaves_height {
                    let y = pos.y + height - dy;
                    for x in pos.x - current_radius..=pos.x + current_radius {
                        for z in pos.z - current_radius..=pos.z + current_radius {
                            let dx = (x - pos.x).abs();
                            let dz = (z - pos.z).abs();
                            if dx != current_radius || dz != current_radius
                                || current_radius <= 0
                            {
                                let replace_pos = IVec3::new(x, y, z);
                                if !world.is_block_opaque_cube(replace_pos) {
                                    world.set_block(replace_pos, block::LEAVES, 1);
                                }
                            }
                        }
                    }
                    if current_radius >= global_radius {
                        current_radius = start_radius;
                        start_radius = 1;
                        global_radius = max_radius.min(global_radius + 1);
                    } else {
                        current_radius += 1;
                    }
                }
                let log_offset = rand.next_int_bounded(3);
                for y in pos.y..(pos.y + height - log_offset) {
                    let replace_pos = IVec3::new(pos.x, y, pos.z);
                    if let Some((block::AIR | block::LEAVES, _)) = world
                        .get_block(replace_pos)
                    {
                        world.set_block(replace_pos, block::LOG, 1);
                    }
                }
                true
            }
        }
        /// A generic tree generator of any type.
        pub enum TreeGenerator {
            Simple(SimpleTreeGenerator),
            Big(BigTreeGenerator),
            Spruce1(Spruce1TreeGenerator),
            Spruce2(Spruce2TreeGenerator),
        }
        impl TreeGenerator {
            #[inline]
            pub fn new_oak() -> Self {
                Self::Simple(SimpleTreeGenerator::new_oak())
            }
            #[inline]
            pub fn new_birch() -> Self {
                Self::Simple(SimpleTreeGenerator::new_birch())
            }
            #[inline]
            pub fn new_big() -> Self {
                Self::Big(BigTreeGenerator::new())
            }
            #[inline]
            pub fn new_big_natural() -> Self {
                Self::Big(BigTreeGenerator::new_natural())
            }
            #[inline]
            pub fn new_spruce1() -> Self {
                Self::Spruce1(Spruce1TreeGenerator::new())
            }
            #[inline]
            pub fn new_spruce2() -> Self {
                Self::Spruce2(Spruce2TreeGenerator::new())
            }
        }
        impl FeatureGenerator for TreeGenerator {
            fn generate(
                &mut self,
                world: &mut World,
                pos: IVec3,
                rand: &mut JavaRandom,
            ) -> bool {
                match self {
                    TreeGenerator::Simple(gen) => gen.generate(world, pos, rand),
                    TreeGenerator::Big(gen) => gen.generate(world, pos, rand),
                    TreeGenerator::Spruce1(gen) => gen.generate(world, pos, rand),
                    TreeGenerator::Spruce2(gen) => gen.generate(world, pos, rand),
                }
            }
        }
        impl TreeGenerator {
            pub fn generate_from_sapling(
                &mut self,
                world: &mut World,
                pos: IVec3,
            ) -> bool {
                let Some((prev_id, prev_metadata)) = world.set_block(pos, block::AIR, 0)
                else { return false };
                let mut rand = world.get_rand_mut().clone();
                let success = if !self.generate(world, pos, &mut rand) {
                    world.set_block(pos, prev_id, prev_metadata);
                    false
                } else {
                    true
                };
                *world.get_rand_mut() = rand;
                success
            }
        }
        /// Check if a tree can grow based on some common properties.
        fn check_tree(
            world: &mut World,
            pos: IVec3,
            height: i32,
            check_radius: impl Fn(i32) -> i32,
        ) -> bool {
            let max_y = pos.y + height + 1;
            if pos.y < 1 || max_y >= 128 {
                return false;
            }
            if !match world.get_block(pos - IVec3::Y) {
                Some((block::GRASS | block::DIRT, _)) => true,
                _ => false,
            } {
                return false;
            }
            for y in pos.y..=max_y {
                let check_radius = check_radius(y);
                for x in pos.x - check_radius..=pos.x + check_radius {
                    for z in pos.z - check_radius..=pos.z + check_radius {
                        if let Some((block::AIR | block::LEAVES, _)) = world
                            .get_block(IVec3::new(x, y, z))
                        {
                            continue;
                        }
                        return false;
                    }
                }
            }
            true
        }
        /// Internal iterator for iterating all blocks of a straight line between two points.
        struct BlockLineIter {
            from: IVec3,
            major_axis: usize,
            second_axis: usize,
            third_axis: usize,
            second_ratio: f32,
            third_ratio: f32,
            major_inc: i32,
            major_max: i32,
            major: i32,
        }
        #[automatically_derived]
        impl ::core::default::Default for BlockLineIter {
            #[inline]
            fn default() -> BlockLineIter {
                BlockLineIter {
                    from: ::core::default::Default::default(),
                    major_axis: ::core::default::Default::default(),
                    second_axis: ::core::default::Default::default(),
                    third_axis: ::core::default::Default::default(),
                    second_ratio: ::core::default::Default::default(),
                    third_ratio: ::core::default::Default::default(),
                    major_inc: ::core::default::Default::default(),
                    major_max: ::core::default::Default::default(),
                    major: ::core::default::Default::default(),
                }
            }
        }
        impl BlockLineIter {
            fn new(from: IVec3, to: IVec3) -> Self {
                let delta = to - from;
                if delta == IVec3::ZERO {
                    return Self::default();
                }
                let major_axis = (0..3)
                    .map(|i: usize| (i, delta[i].abs()))
                    .max_by_key(|&(_, delta)| delta)
                    .unwrap()
                    .0;
                let second_axis = (major_axis + 1) % 3;
                let third_axis = (major_axis + 2) % 3;
                let major_delta = delta[major_axis];
                let second_ratio = delta[second_axis] as f32 / major_delta as f32;
                let third_ratio = delta[third_axis] as f32 / major_delta as f32;
                let major_inc = major_delta.signum();
                let major_max = major_delta + major_inc;
                Self {
                    from,
                    major_axis,
                    second_axis,
                    third_axis,
                    second_ratio,
                    third_ratio,
                    major_inc,
                    major_max,
                    major: 0,
                }
            }
        }
        impl Iterator for BlockLineIter {
            type Item = IVec3;
            fn next(&mut self) -> Option<Self::Item> {
                if self.major == self.major_max {
                    None
                } else {
                    let mut pos = IVec3::ZERO;
                    pos[self.major_axis] = self.from[self.major_axis] + self.major;
                    pos[self
                        .second_axis] = (self.from[self.second_axis] as f32
                        + self.major as f32 * self.second_ratio + 0.5)
                        .floor() as i32;
                    pos[self
                        .third_axis] = (self.from[self.third_axis] as f32
                        + self.major as f32 * self.third_ratio + 0.5)
                        .floor() as i32;
                    self.major += self.major_inc;
                    Some(pos)
                }
            }
        }
    }
    pub mod cave {
        //! Cave generation utility.
        use glam::{IVec3, DVec3};
        use crate::rand::JavaRandom;
        use crate::chunk::Chunk;
        use crate::block;
        use super::math::MinecraftMath;
        /// A cave generator.
        pub struct CaveGenerator {
            /// Max chunk radius for the caves.
            radius: u8,
        }
        impl CaveGenerator {
            pub fn new(radius: u8) -> Self {
                Self { radius }
            }
            /// Generate all caves in the given chunk.
            pub fn generate(&self, cx: i32, cz: i32, chunk: &mut Chunk, seed: i64) {
                let mut rand = JavaRandom::new(seed);
                let x_mul = rand
                    .next_long()
                    .wrapping_div(2)
                    .wrapping_mul(2)
                    .wrapping_add(1);
                let z_mul = rand
                    .next_long()
                    .wrapping_div(2)
                    .wrapping_mul(2)
                    .wrapping_add(1);
                let radius = self.radius as i32;
                for from_cx in cx - radius..=cx + radius {
                    for from_cz in cz - radius..=cz + radius {
                        let chunk_seed = i64::wrapping_add(
                            (from_cx as i64).wrapping_mul(x_mul),
                            (from_cz as i64).wrapping_mul(z_mul),
                        ) ^ seed;
                        rand.set_seed(chunk_seed);
                        self.generate_from(from_cx, from_cz, cx, cz, chunk, &mut rand);
                    }
                }
            }
            /// Internal function to generate a cave from a chunk and modify the chunk if that
            /// cave come in.
            fn generate_from(
                &self,
                from_cx: i32,
                from_cz: i32,
                cx: i32,
                cz: i32,
                chunk: &mut Chunk,
                rand: &mut JavaRandom,
            ) {
                let count = rand.next_int_bounded(40);
                let count = rand.next_int_bounded(count + 1);
                let count = rand.next_int_bounded(count + 1);
                if rand.next_int_bounded(15) != 0 {
                    return;
                }
                for _ in 0..count {
                    let start = IVec3 {
                        x: from_cx * 16 + rand.next_int_bounded(16),
                        y: {
                            let v = rand.next_int_bounded(120);
                            rand.next_int_bounded(v + 8)
                        },
                        z: from_cz * 16 + rand.next_int_bounded(16),
                    }
                        .as_dvec3();
                    let mut normal_count = 1;
                    if rand.next_int_bounded(4) == 0 {
                        let start_width = rand.next_float() * 6.0 + 1.0;
                        self.generate_node(
                            cx,
                            cz,
                            chunk,
                            rand,
                            start,
                            start_width,
                            0.0,
                            0.0,
                            -1,
                            -1,
                            0.5,
                        );
                        normal_count += rand.next_int_bounded(4);
                    }
                    for _ in 0..normal_count {
                        let yaw = rand.next_float() * f32::MC_PI * 2.0;
                        let pitch = (rand.next_float() - 0.5) * 2.0 / 8.0;
                        let start_width = rand.next_float() * 2.0 + rand.next_float();
                        self.generate_node(
                            cx,
                            cz,
                            chunk,
                            rand,
                            start,
                            start_width,
                            yaw,
                            pitch,
                            0,
                            0,
                            1.0,
                        );
                    }
                }
            }
            /// Generate a cave node with the given properties.
            fn generate_node(
                &self,
                cx: i32,
                cz: i32,
                chunk: &mut Chunk,
                chunk_rand: &mut JavaRandom,
                mut pos: DVec3,
                start_width: f32,
                mut yaw: f32,
                mut pitch: f32,
                mut offset: i32,
                mut length: i32,
                height_scale: f64,
            ) {
                let cx_mid = (cx * 16 + 8) as f64;
                let cz_mid = (cz * 16 + 8) as f64;
                let mut rand = JavaRandom::new(chunk_rand.next_long());
                if length <= 0 {
                    let v = self.radius as i32 * 16 - 16;
                    length = v - rand.next_int_bounded(v / 4);
                }
                let mut auto_offset = false;
                if offset == -1 {
                    offset = length / 2;
                    auto_offset = true;
                }
                if true {
                    if !(offset >= 0 && offset < length) {
                        ::core::panicking::panic(
                            "assertion failed: offset >= 0 && offset < length",
                        )
                    }
                }
                let new_nodes_offset = rand.next_int_bounded(length / 2) + length / 4;
                let stable_pitch = rand.next_int_bounded(6) == 0;
                let mut pitch_scale = 0.0;
                let mut yaw_scale = 0.0;
                'main: for offset in offset..length {
                    let width = 1.5
                        + ((offset as f32 * f32::MC_PI / length as f32).mc_sin()
                            * start_width * 1.0) as f64;
                    let height = width * height_scale;
                    let (pitch_sin, pitch_cos) = pitch.mc_sin_cos();
                    let (yaw_sin, yaw_cos) = yaw.mc_sin_cos();
                    pos.x += (yaw_cos * pitch_cos) as f64;
                    pos.y += pitch_sin as f64;
                    pos.z += (yaw_sin * pitch_cos) as f64;
                    if stable_pitch {
                        pitch *= 0.92;
                    } else {
                        pitch *= 0.7;
                    }
                    pitch += pitch_scale * 0.1;
                    yaw += yaw_scale * 0.1;
                    pitch_scale *= 0.9;
                    yaw_scale *= 12.0 / 16.0;
                    pitch_scale
                        += (rand.next_float() - rand.next_float()) * rand.next_float()
                            * 2.0;
                    yaw_scale
                        += (rand.next_float() - rand.next_float()) * rand.next_float()
                            * 4.0;
                    if !auto_offset && offset == new_nodes_offset && start_width > 1.0 {
                        self.generate_node(
                            cx,
                            cz,
                            chunk,
                            chunk_rand,
                            pos,
                            rand.next_float() * 0.5 + 0.5,
                            yaw - f32::MC_PI * 0.5,
                            pitch / 3.0,
                            offset,
                            length,
                            1.0,
                        );
                        self.generate_node(
                            cx,
                            cz,
                            chunk,
                            chunk_rand,
                            pos,
                            rand.next_float() * 0.5 + 0.5,
                            yaw + f32::MC_PI * 0.5,
                            pitch / 3.0,
                            offset,
                            length,
                            1.0,
                        );
                        return;
                    }
                    if !auto_offset && rand.next_int_bounded(4) == 0 {
                        continue;
                    }
                    let cx_mid_delta = pos.x - cx_mid;
                    let cz_mid_delta = pos.z - cz_mid;
                    let remaining_length = (length - offset) as f64;
                    let c = (start_width + 2.0 + 16.0) as f64;
                    if cx_mid_delta.powi(2) + cz_mid_delta.powi(2)
                        - remaining_length.powi(2) > c.powi(2)
                    {
                        return;
                    }
                    if pos.x < cx_mid - 16.0 - width * 2.0
                        || pos.z < cz_mid - 16.0 - width * 2.0
                        || pos.x > cx_mid + 16.0 + width * 2.0
                        || pos.z > cz_mid + 16.0 + width * 2.0
                    {
                        continue;
                    }
                    let size = DVec3::new(width, height, width);
                    let mut start = (pos - size).floor().as_ivec3();
                    let mut end = (pos + size).floor().as_ivec3();
                    start -= IVec3::new(cx * 16 + 1, 1, cz * 16 + 1);
                    end -= IVec3::new(cx * 16 - 1, -1, cz * 16 - 1);
                    let start = start.max(IVec3::new(0, 1, 0));
                    let end = end.min(IVec3::new(16, 120, 16));
                    for bx in start.x..end.x {
                        for bz in start.z..end.z {
                            let mut by = end.y + 1;
                            while by >= start.y - 1 {
                                if by < 128 {
                                    let carve_pos = IVec3::new(bx, by, bz);
                                    if let (block::WATER_MOVING | block::WATER_STILL, _) = chunk
                                        .get_block(carve_pos)
                                    {
                                        continue 'main;
                                    } else if by != start.y - 1 && bx != start.x
                                        && bx != end.x - 1 && bz != start.z && bz != end.z - 1
                                    {
                                        by = start.y;
                                    }
                                    by -= 1;
                                }
                            }
                        }
                    }
                    for bx in start.x..end.x {
                        let dx = ((bx + cx * 16) as f64 + 0.5 - pos.x) / width;
                        for bz in start.z..end.z {
                            let dz = ((bz + cz * 16) as f64 + 0.5 - pos.z) / width;
                            let xz_dist_sq = dx.powi(2) + dz.powi(2);
                            if xz_dist_sq >= 1.0 {
                                continue;
                            }
                            let mut carving_surface = false;
                            for by in (start.y..=end.y - 1).rev() {
                                let dy = (by as f64 + 0.5 - pos.y) / height;
                                if dy <= -0.7 || xz_dist_sq + dy.powi(2) >= 1.0 {
                                    continue;
                                }
                                let carve_pos = IVec3::new(bx, by + 1, bz);
                                let (prev_id, _) = chunk.get_block(carve_pos);
                                if prev_id == block::GRASS {
                                    carving_surface = true;
                                }
                                if let block::STONE | block::DIRT | block::GRASS = prev_id {
                                    if by < 10 {
                                        chunk.set_block(carve_pos, block::LAVA_MOVING, 0);
                                    } else {
                                        chunk.set_block(carve_pos, block::AIR, 0);
                                        if carving_surface {
                                            let below_pos = carve_pos - IVec3::Y;
                                            if let (block::DIRT, _) = chunk.get_block(below_pos) {
                                                chunk.set_block(below_pos, block::GRASS, 0);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if auto_offset {
                        break;
                    }
                }
            }
        }
    }
    mod overworld {
        //! Overworld chunk generator.
        //!
        //! The overworld generator is fully featured and should produces the same chunk terrain
        //! and randomly the same features.
        //!
        //! The overworld generator is an heavy piece of algorithm, and the runtime duration of
        //! generation and population depends on optimization level:
        //! - Release: populate take around 75% of time to generate
        //! - Debug: populate take around 150% of time to generate
        //!
        //! However, it's important to note that to fully generate a chunk in middle of nowhere,
        //! it's required to generate terrain for 9 chunks and populate only one, so populating
        //! in this case will always be faster that terrain generation. Even in the worst case
        //! of no optimization, populate only represent around 16% of terrain generation time,
        //! for each fully populated chunk.
        //!
        //! If we take a more realistic approach of loading a chunk near already-existing chunks,
        //! we only need to generate 2 to 4 chunks, in the worst case, populate represent 75% of
        //! terrain generation time, for each fully populated chunk.
        //!
        //! We see that in general, we will have more terrain generation than populating to run.
        use glam::{DVec2, IVec3, Vec3Swizzles, DVec3};
        use crate::chunk::{Chunk, CHUNK_WIDTH, CHUNK_HEIGHT};
        use crate::block::material::Material;
        use crate::rand::JavaRandom;
        use crate::biome::Biome;
        use crate::world::World;
        use crate::block;
        use super::noise::{PerlinOctaveNoise, NoiseCube};
        use super::{ChunkGenerator, FeatureGenerator};
        use super::plant::{
            PlantGenerator, SugarCanesGenerator, PumpkinGenerator, CactusGenerator,
        };
        use super::liquid::{LakeGenerator, LiquidGenerator};
        use super::dungeon::DungeonGenerator;
        use super::cave::CaveGenerator;
        use super::vein::VeinGenerator;
        use super::tree::TreeGenerator;
        const NOISE_WIDTH: usize = 5;
        const NOISE_HEIGHT: usize = 17;
        const TEMPERATURE_SCALE: DVec2 = DVec2::splat(0.025f32 as f64);
        const TEMPERATURE_FREQ_FACTOR: f64 = 0.25;
        const HUMIDITY_SCALE: DVec2 = DVec2::splat(0.05f32 as f64);
        const HUMIDITY_FREQ_FACTOR: f64 = 1.0 / 3.0;
        const BIOME_SCALE: DVec2 = DVec2::splat(0.25);
        const BIOME_FREQ_FACTOR: f64 = 0.5882352941176471;
        /// A chunk generator for the overworld dimension. This structure can be shared between
        /// workers.
        pub struct OverworldGenerator {
            /// The world seed.
            seed: i64,
            /// The noise used for generating biome temperature.
            temperature_noise: PerlinOctaveNoise,
            /// The noise used for generating biome humidity.
            humidity_noise: PerlinOctaveNoise,
            /// The noise used to alter both temperature and humidity for biome.
            biome_noise: PerlinOctaveNoise,
            terrain_noise0: PerlinOctaveNoise,
            terrain_noise1: PerlinOctaveNoise,
            terrain_noise2: PerlinOctaveNoise,
            terrain_noise3: PerlinOctaveNoise,
            terrain_noise4: PerlinOctaveNoise,
            sand_gravel_noise: PerlinOctaveNoise,
            thickness_noise: PerlinOctaveNoise,
            feature_noise: PerlinOctaveNoise,
            biome_table: Box<[Biome; 4096]>,
        }
        /// This structure stores huge structures that should not be shared between workers.
        pub struct OverworldState {
            temperature: NoiseCube<CHUNK_WIDTH, 1, CHUNK_WIDTH>,
            humidity: NoiseCube<CHUNK_WIDTH, 1, CHUNK_WIDTH>,
            biome: NoiseCube<CHUNK_WIDTH, 1, CHUNK_WIDTH>,
            terrain: NoiseCube<NOISE_WIDTH, NOISE_HEIGHT, NOISE_WIDTH>,
            terrain0: NoiseCube<NOISE_WIDTH, NOISE_HEIGHT, NOISE_WIDTH>,
            terrain1: NoiseCube<NOISE_WIDTH, NOISE_HEIGHT, NOISE_WIDTH>,
            terrain2: NoiseCube<NOISE_WIDTH, NOISE_HEIGHT, NOISE_WIDTH>,
            terrain3: NoiseCube<NOISE_WIDTH, 1, NOISE_WIDTH>,
            terrain4: NoiseCube<NOISE_WIDTH, 1, NOISE_WIDTH>,
            sand: NoiseCube<CHUNK_WIDTH, CHUNK_WIDTH, 1>,
            gravel: NoiseCube<CHUNK_WIDTH, 1, CHUNK_WIDTH>,
            thickness: NoiseCube<CHUNK_WIDTH, CHUNK_WIDTH, 1>,
        }
        #[automatically_derived]
        impl ::core::default::Default for OverworldState {
            #[inline]
            fn default() -> OverworldState {
                OverworldState {
                    temperature: ::core::default::Default::default(),
                    humidity: ::core::default::Default::default(),
                    biome: ::core::default::Default::default(),
                    terrain: ::core::default::Default::default(),
                    terrain0: ::core::default::Default::default(),
                    terrain1: ::core::default::Default::default(),
                    terrain2: ::core::default::Default::default(),
                    terrain3: ::core::default::Default::default(),
                    terrain4: ::core::default::Default::default(),
                    sand: ::core::default::Default::default(),
                    gravel: ::core::default::Default::default(),
                    thickness: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OverworldState {
            #[inline]
            fn clone(&self) -> OverworldState {
                OverworldState {
                    temperature: ::core::clone::Clone::clone(&self.temperature),
                    humidity: ::core::clone::Clone::clone(&self.humidity),
                    biome: ::core::clone::Clone::clone(&self.biome),
                    terrain: ::core::clone::Clone::clone(&self.terrain),
                    terrain0: ::core::clone::Clone::clone(&self.terrain0),
                    terrain1: ::core::clone::Clone::clone(&self.terrain1),
                    terrain2: ::core::clone::Clone::clone(&self.terrain2),
                    terrain3: ::core::clone::Clone::clone(&self.terrain3),
                    terrain4: ::core::clone::Clone::clone(&self.terrain4),
                    sand: ::core::clone::Clone::clone(&self.sand),
                    gravel: ::core::clone::Clone::clone(&self.gravel),
                    thickness: ::core::clone::Clone::clone(&self.thickness),
                }
            }
        }
        impl OverworldGenerator {
            /// Create a new overworld generator given a seed.
            pub fn new(seed: i64) -> Self {
                let biome_lookup = Box::new(
                    std::array::from_fn(|i| {
                        let t = (i % 64) as f32 / 63.0;
                        let h = (i / 64) as f32 / 63.0;
                        let h = h * t;
                        if t < 0.1 {
                            Biome::Tundra
                        } else if h < 0.2 {
                            if t < 0.5 {
                                Biome::Tundra
                            } else if t < 0.95 {
                                Biome::Savanna
                            } else {
                                Biome::Desert
                            }
                        } else if h > 0.5 && t < 0.7 {
                            Biome::Swampland
                        } else if t < 0.5 {
                            Biome::Taiga
                        } else if t < 0.97 {
                            if h < 0.35 { Biome::ShrubLand } else { Biome::Forest }
                        } else if h < 0.45 {
                            Biome::Plains
                        } else if h < 0.9 {
                            Biome::SeasonalForest
                        } else {
                            Biome::RainForest
                        }
                    }),
                );
                let mut rand = JavaRandom::new(seed);
                Self {
                    seed,
                    temperature_noise: PerlinOctaveNoise::new(
                        &mut JavaRandom::new(seed.wrapping_mul(9871)),
                        4,
                    ),
                    humidity_noise: PerlinOctaveNoise::new(
                        &mut JavaRandom::new(seed.wrapping_mul(39811)),
                        4,
                    ),
                    biome_noise: PerlinOctaveNoise::new(
                        &mut JavaRandom::new(seed.wrapping_mul(543321)),
                        2,
                    ),
                    terrain_noise0: PerlinOctaveNoise::new(&mut rand, 16),
                    terrain_noise1: PerlinOctaveNoise::new(&mut rand, 16),
                    terrain_noise2: PerlinOctaveNoise::new(&mut rand, 8),
                    sand_gravel_noise: PerlinOctaveNoise::new(&mut rand, 4),
                    thickness_noise: PerlinOctaveNoise::new(&mut rand, 4),
                    terrain_noise3: PerlinOctaveNoise::new(&mut rand, 10),
                    terrain_noise4: PerlinOctaveNoise::new(&mut rand, 16),
                    feature_noise: PerlinOctaveNoise::new(&mut rand, 8),
                    biome_table: biome_lookup,
                }
            }
            /// Internal function to calculate the biome from given random variables.
            #[inline]
            fn calc_biome(
                &self,
                temperature: f64,
                humidity: f64,
                biome: f64,
            ) -> (f64, f64, Biome) {
                let a = biome * 1.1 + 0.5;
                let t = (temperature * 0.15 + 0.7) * 0.99 + a * 0.01;
                let t = 1.0 - (1.0 - t).powi(2);
                let h = (humidity * 0.15 + 0.5) * 0.998 + a * 0.002;
                let t = t.clamp(0.0, 1.0);
                let h = h.clamp(0.0, 1.0);
                let pos_biome = self
                    .biome_table[(t * 63.0) as usize + (h * 63.0) as usize * 64];
                (t, h, pos_biome)
            }
            /// Get a single biome at given position.
            fn get_biome(&self, x: i32, z: i32) -> Biome {
                let offset = DVec2::new(x as f64, z as f64);
                let mut temperature = 0.0;
                let mut humidity = 0.0;
                let mut biome = 0.0;
                self.temperature_noise
                    .gen_weird_2d(
                        NoiseCube::from_mut(&mut temperature),
                        offset,
                        TEMPERATURE_SCALE,
                        TEMPERATURE_FREQ_FACTOR,
                    );
                self.humidity_noise
                    .gen_weird_2d(
                        NoiseCube::from_mut(&mut humidity),
                        offset,
                        HUMIDITY_SCALE,
                        HUMIDITY_FREQ_FACTOR,
                    );
                self.biome_noise
                    .gen_weird_2d(
                        NoiseCube::from_mut(&mut biome),
                        offset,
                        BIOME_SCALE,
                        BIOME_FREQ_FACTOR,
                    );
                self.calc_biome(temperature, humidity, biome).2
            }
            /// Generate a biome map for the chunk and store it in the chunk data.
            fn gen_biomes(
                &self,
                cx: i32,
                cz: i32,
                chunk: &mut Chunk,
                state: &mut OverworldState,
            ) {
                let offset = DVec2::new((cx * 16) as f64, (cz * 16) as f64);
                let temperature = &mut state.temperature;
                let humidity = &mut state.humidity;
                let biome = &mut state.biome;
                self.temperature_noise
                    .gen_weird_2d(
                        temperature,
                        offset,
                        TEMPERATURE_SCALE,
                        TEMPERATURE_FREQ_FACTOR,
                    );
                self.humidity_noise
                    .gen_weird_2d(
                        humidity,
                        offset,
                        HUMIDITY_SCALE,
                        HUMIDITY_FREQ_FACTOR,
                    );
                self.biome_noise
                    .gen_weird_2d(biome, offset, BIOME_SCALE, BIOME_FREQ_FACTOR);
                for x in 0usize..16 {
                    for z in 0usize..16 {
                        let (t, h, pos_biome) = self
                            .calc_biome(
                                temperature.get(x, 0, z),
                                humidity.get(x, 0, z),
                                biome.get(x, 0, z),
                            );
                        temperature.set(x, 0, z, t);
                        humidity.set(x, 0, z, h);
                        chunk.set_biome(IVec3::new(x as i32, 0, z as i32), pos_biome);
                    }
                }
            }
            /// Generate the primitive terrain of the chunk.
            fn gen_terrain(
                &self,
                cx: i32,
                cz: i32,
                chunk: &mut Chunk,
                state: &mut OverworldState,
            ) {
                const NOISE_STRIDE: usize = CHUNK_WIDTH / NOISE_WIDTH;
                const NOISE_REAL_WIDTH: usize = NOISE_WIDTH - 1;
                const NOISE_REAL_HEIGHT: usize = NOISE_HEIGHT - 1;
                const NOISE_REAL_WIDTH_STRIDE: usize = CHUNK_WIDTH / NOISE_REAL_WIDTH;
                const NOISE_REAL_HEIGHT_STRIDE: usize = CHUNK_HEIGHT / NOISE_REAL_HEIGHT;
                let offset = IVec3::new(
                    cx * NOISE_REAL_WIDTH as i32,
                    0,
                    cz * NOISE_REAL_WIDTH as i32,
                );
                let terrain = &mut state.terrain;
                let terrain0 = &mut state.terrain0;
                let terrain1 = &mut state.terrain1;
                let terrain2 = &mut state.terrain2;
                let terrain3 = &mut state.terrain3;
                let terrain4 = &mut state.terrain4;
                let temperature = &state.temperature;
                let humidity = &state.humidity;
                let offset_2d = offset.xz().as_dvec2();
                let offset_3d = offset.as_dvec3();
                self.terrain_noise3.gen_2d(terrain3, offset_2d, DVec2::splat(1.121));
                self.terrain_noise4.gen_2d(terrain4, offset_2d, DVec2::splat(200.0));
                self.terrain_noise2
                    .gen_3d(
                        terrain2,
                        offset_3d,
                        DVec3::new(684.412 / 80.0, 684.412 / 160.0, 684.412 / 80.0),
                    );
                self.terrain_noise0.gen_3d(terrain0, offset_3d, DVec3::splat(684.412));
                self.terrain_noise1.gen_3d(terrain1, offset_3d, DVec3::splat(684.412));
                for x_noise in 0..NOISE_WIDTH {
                    let x_block = x_noise * NOISE_STRIDE + (NOISE_STRIDE / 2);
                    for z_noise in 0..NOISE_WIDTH {
                        let z_block = z_noise * NOISE_STRIDE + (NOISE_STRIDE / 2);
                        let t = temperature.get(x_block, 0, z_block);
                        let h = humidity.get(x_block, 0, z_block) * t;
                        let h_inv = (1.0 - h).powi(4);
                        let h = 1.0 - h_inv;
                        let mut v0 = (terrain3.get(x_noise, 0, z_noise) + 256.0) / 512.0
                            * h;
                        v0 = v0.min(1.0);
                        let mut v1 = terrain4.get(x_noise, 0, z_noise) / 8000.0;
                        if v1 < 0.0 {
                            v1 = -v1 * 0.3;
                        }
                        v1 = v1 * 3.0 - 2.0;
                        if v1 < 0.0 {
                            v1 /= 2.0;
                            v1 = v1.max(-1.0);
                            v1 /= 1.4;
                            v1 /= 2.0;
                            v0 = 0.0;
                        } else {
                            v1 = v1.min(1.0);
                            v1 /= 8.0;
                        }
                        v0 = v0.max(0.0);
                        v0 += 0.5;
                        v1 = v1 * NOISE_HEIGHT as f64 / 16.0;
                        let v2 = NOISE_HEIGHT as f64 / 2.0 + v1 * 4.0;
                        for y_noise in 0..NOISE_HEIGHT {
                            let mut v3 = (y_noise as f64 - v2) * 12.0 / v0;
                            if v3 < 0.0 {
                                v3 *= 4.0;
                            }
                            let v4 = terrain0.get(x_noise, y_noise, z_noise) / 512.0;
                            let v5 = terrain1.get(x_noise, y_noise, z_noise) / 512.0;
                            let v6 = (terrain2.get(x_noise, y_noise, z_noise) / 10.0
                                + 1.0) / 2.0;
                            let mut final_value = if v6 < 0.0 {
                                v4
                            } else if v6 > 1.0 {
                                v5
                            } else {
                                v4 + (v5 - v4) * v6
                            };
                            final_value -= v3;
                            if y_noise > NOISE_HEIGHT - 4 {
                                let v7 = ((y_noise - (NOISE_HEIGHT - 4)) as f32 / 3.0)
                                    as f64;
                                final_value = final_value * (1.0 - v7) + (-10.0 * v7);
                            }
                            terrain.set(x_noise, y_noise, z_noise, final_value);
                        }
                    }
                }
                for x_noise in 0..NOISE_REAL_WIDTH {
                    for z_noise in 0..NOISE_REAL_WIDTH {
                        for y_noise in 0..NOISE_REAL_HEIGHT {
                            let mut a = terrain
                                .get(x_noise + 0, y_noise + 0, z_noise + 0);
                            let mut b = terrain
                                .get(x_noise + 0, y_noise + 0, z_noise + 1);
                            let mut c = terrain
                                .get(x_noise + 1, y_noise + 0, z_noise + 0);
                            let mut d = terrain
                                .get(x_noise + 1, y_noise + 0, z_noise + 1);
                            let e = (terrain.get(x_noise + 0, y_noise + 1, z_noise + 0)
                                - a) * 0.125;
                            let f = (terrain.get(x_noise + 0, y_noise + 1, z_noise + 1)
                                - b) * 0.125;
                            let g = (terrain.get(x_noise + 1, y_noise + 1, z_noise + 0)
                                - c) * 0.125;
                            let h = (terrain.get(x_noise + 1, y_noise + 1, z_noise + 1)
                                - d) * 0.125;
                            for y_index in 0..NOISE_REAL_HEIGHT_STRIDE {
                                let y = y_noise * NOISE_REAL_HEIGHT_STRIDE + y_index;
                                let ca = (c - a) * 0.25;
                                let db = (d - b) * 0.25;
                                let mut a0 = a;
                                let mut b0 = b;
                                for x_index in 0..NOISE_REAL_WIDTH_STRIDE {
                                    let x = x_noise * NOISE_REAL_WIDTH_STRIDE + x_index;
                                    let b0a0 = (b0 - a0) * 0.25;
                                    let mut a00 = a0;
                                    for z_index in 0..NOISE_REAL_WIDTH_STRIDE {
                                        let z = z_noise * NOISE_REAL_WIDTH_STRIDE + z_index;
                                        let t = temperature.get(x, 0, z);
                                        let mut id = block::AIR;
                                        if y < 64 {
                                            id = if t < 0.5 && y == 63 {
                                                block::ICE
                                            } else {
                                                block::WATER_STILL
                                            };
                                        }
                                        if a00 > 0.0 {
                                            id = block::STONE;
                                        }
                                        if id != block::AIR {
                                            chunk
                                                .set_block(IVec3::new(x as i32, y as i32, z as i32), id, 0);
                                        }
                                        a00 += b0a0;
                                    }
                                    a0 += ca;
                                    b0 += db;
                                }
                                a += e;
                                b += f;
                                c += g;
                                d += h;
                            }
                        }
                    }
                }
            }
            /// Generate the primitive terrain of the chunk.
            fn gen_surface(
                &self,
                cx: i32,
                cz: i32,
                chunk: &mut Chunk,
                state: &mut OverworldState,
                rand: &mut JavaRandom,
            ) {
                let sand = &mut state.sand;
                let gravel = &mut state.gravel;
                let thickness = &mut state.thickness;
                let offset = DVec3::new((cx * 16) as f64, (cz * 16) as f64, 0.0);
                let scale = 1.0 / 32.0;
                let sea_level = 64;
                self.sand_gravel_noise
                    .gen_3d(sand, offset, DVec3::new(scale, scale, 1.0));
                self.sand_gravel_noise
                    .gen_2d(gravel, offset.truncate(), DVec2::new(scale, scale));
                self.thickness_noise
                    .gen_3d(thickness, offset, DVec3::splat(scale * 2.0));
                for z in 0usize..16 {
                    for x in 0usize..16 {
                        let mut pos = IVec3::new(x as i32, 0, z as i32);
                        let biome = chunk.get_biome(pos);
                        let have_sand = sand.get(x, z, 0) + rand.next_double() * 0.2
                            > 0.0;
                        let have_gravel = gravel.get(x, 0, z) + rand.next_double() * 0.2
                            > 3.0;
                        let thickness = (thickness.get(x, z, 0) / 3.0 + 3.0
                            + rand.next_double() * 0.25) as i32;
                        let (biome_top_id, biome_filler_id) = match biome {
                            Biome::Desert | Biome::IceDesert => {
                                (block::SAND, block::SAND)
                            }
                            _ => (block::GRASS, block::DIRT),
                        };
                        let mut top_id = biome_top_id;
                        let mut filler_id = biome_filler_id;
                        let mut remaining_thickness = -1;
                        for y in (0..128).rev() {
                            pos.y = y;
                            if y <= rand.next_int_bounded(5) {
                                chunk.set_block(pos, block::BEDROCK, 0);
                                continue;
                            }
                            let (prev_id, _) = chunk.get_block(pos);
                            if prev_id == block::AIR {
                                remaining_thickness = -1;
                            } else if prev_id == block::STONE {
                                if remaining_thickness == -1 {
                                    if thickness <= 0 {
                                        top_id = block::AIR;
                                        filler_id = block::STONE;
                                    } else if y >= sea_level - 4 && y <= sea_level + 1 {
                                        top_id = biome_top_id;
                                        filler_id = biome_filler_id;
                                        if have_sand {
                                            top_id = block::SAND;
                                            filler_id = block::SAND;
                                        } else if have_gravel {
                                            top_id = block::AIR;
                                            filler_id = block::GRAVEL;
                                        }
                                    }
                                    if y < sea_level && top_id == block::AIR {
                                        top_id = block::WATER_STILL;
                                    }
                                    remaining_thickness = thickness;
                                    if y >= sea_level - 1 {
                                        chunk.set_block(pos, top_id, 0);
                                    } else {
                                        chunk.set_block(pos, filler_id, 0);
                                    }
                                } else if remaining_thickness > 0 {
                                    chunk.set_block(pos, filler_id, 0);
                                    remaining_thickness -= 1;
                                    if remaining_thickness == 0 && filler_id == block::SAND {
                                        remaining_thickness = rand.next_int_bounded(4);
                                        filler_id = block::SANDSTONE;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            fn gen_carving(&self, cx: i32, cz: i32, chunk: &mut Chunk) {
                CaveGenerator::new(8).generate(cx, cz, chunk, self.seed);
            }
        }
        impl ChunkGenerator for OverworldGenerator {
            type State = OverworldState;
            fn gen_biomes(
                &self,
                cx: i32,
                cz: i32,
                chunk: &mut Chunk,
                state: &mut Self::State,
            ) {
                self.gen_biomes(cx, cz, chunk, state);
            }
            fn gen_terrain(
                &self,
                cx: i32,
                cz: i32,
                chunk: &mut Chunk,
                state: &mut Self::State,
            ) {
                let chunk_seed = i64::wrapping_add(
                    (cx as i64).wrapping_mul(341873128712),
                    (cz as i64).wrapping_mul(132897987541),
                );
                let mut rand = JavaRandom::new(chunk_seed);
                self.gen_biomes(cx, cz, chunk, state);
                self.gen_terrain(cx, cz, chunk, state);
                self.gen_surface(cx, cz, chunk, state, &mut rand);
                self.gen_carving(cx, cz, chunk);
                chunk.recompute_all_height();
            }
            fn gen_features(
                &self,
                cx: i32,
                cz: i32,
                world: &mut World,
                state: &mut Self::State,
            ) {
                let pos = IVec3::new(cx * 16, 0, cz * 16);
                let biome = self.get_biome(pos.x + 16, pos.z + 16);
                let mut rand = JavaRandom::new(self.seed);
                let x_mul = rand
                    .next_long()
                    .wrapping_div(2)
                    .wrapping_mul(2)
                    .wrapping_add(1);
                let z_mul = rand
                    .next_long()
                    .wrapping_div(2)
                    .wrapping_mul(2)
                    .wrapping_add(1);
                let chunk_seed = i64::wrapping_add(
                    (cx as i64).wrapping_mul(x_mul),
                    (cz as i64).wrapping_mul(z_mul),
                ) ^ self.seed;
                rand.set_seed(chunk_seed);
                #[inline(always)]
                fn next_offset(
                    rand: &mut JavaRandom,
                    max_y: i32,
                    offset_xz: i32,
                ) -> IVec3 {
                    IVec3 {
                        x: rand.next_int_bounded(16) + offset_xz,
                        y: rand.next_int_bounded(max_y),
                        z: rand.next_int_bounded(16) + offset_xz,
                    }
                }
                if rand.next_int_bounded(4) == 0 {
                    let pos = pos + next_offset(&mut rand, 128, 8);
                    LakeGenerator::new(block::WATER_STILL)
                        .generate(world, pos, &mut rand);
                }
                if rand.next_int_bounded(8) == 0 {
                    let pos = pos
                        + IVec3 {
                            x: rand.next_int_bounded(16) + 8,
                            y: {
                                let v = rand.next_int_bounded(120);
                                rand.next_int_bounded(v + 8)
                            },
                            z: rand.next_int_bounded(16) + 8,
                        };
                    if pos.y < 64 || rand.next_int_bounded(10) == 0 {
                        LakeGenerator::new(block::LAVA_STILL)
                            .generate(world, pos, &mut rand);
                    }
                }
                for _ in 0..8 {
                    let pos = pos + next_offset(&mut rand, 128, 8);
                    DungeonGenerator::new().generate(world, pos, &mut rand);
                }
                for _ in 0..10 {
                    let pos = pos + next_offset(&mut rand, 128, 0);
                    if world.get_block_material(pos) == Material::Water {
                        VeinGenerator::new_clay(32).generate(world, pos, &mut rand);
                    }
                }
                for _ in 0..20 {
                    let pos = pos + next_offset(&mut rand, 128, 0);
                    VeinGenerator::new_ore(block::DIRT, 32)
                        .generate(world, pos, &mut rand);
                }
                for _ in 0..10 {
                    let pos = pos + next_offset(&mut rand, 128, 0);
                    VeinGenerator::new_ore(block::GRAVEL, 32)
                        .generate(world, pos, &mut rand);
                }
                for _ in 0..20 {
                    let pos = pos + next_offset(&mut rand, 128, 0);
                    VeinGenerator::new_ore(block::COAL_ORE, 16)
                        .generate(world, pos, &mut rand);
                }
                for _ in 0..20 {
                    let pos = pos + next_offset(&mut rand, 64, 0);
                    VeinGenerator::new_ore(block::IRON_ORE, 8)
                        .generate(world, pos, &mut rand);
                }
                for _ in 0..2 {
                    let pos = pos + next_offset(&mut rand, 32, 0);
                    VeinGenerator::new_ore(block::GOLD_ORE, 8)
                        .generate(world, pos, &mut rand);
                }
                for _ in 0..8 {
                    let pos = pos + next_offset(&mut rand, 16, 0);
                    VeinGenerator::new_ore(block::REDSTONE_ORE, 7)
                        .generate(world, pos, &mut rand);
                }
                for _ in 0..1 {
                    let pos = pos + next_offset(&mut rand, 16, 0);
                    VeinGenerator::new_ore(block::DIAMOND_ORE, 7)
                        .generate(world, pos, &mut rand);
                }
                for _ in 0..1 {
                    let pos = pos
                        + IVec3 {
                            x: rand.next_int_bounded(16),
                            y: rand.next_int_bounded(16) + rand.next_int_bounded(16),
                            z: rand.next_int_bounded(16),
                        };
                    VeinGenerator::new_ore(block::LAPIS_ORE, 6)
                        .generate(world, pos, &mut rand);
                }
                let feature_noise = self
                    .feature_noise
                    .gen_2d_point(pos.xz().as_dvec2() * 0.5);
                let base_tree_count = ((feature_noise / 8.0 + rand.next_double() * 4.0
                    + 4.0) / 3.0) as i32;
                let mut tree_count = 0;
                if rand.next_int_bounded(10) == 0 {
                    tree_count += 1;
                }
                match biome {
                    Biome::Taiga | Biome::RainForest | Biome::Forest => {
                        tree_count += base_tree_count + 5;
                    }
                    Biome::SeasonalForest => tree_count += base_tree_count + 2,
                    Biome::Desert | Biome::Tundra | Biome::Plains => tree_count -= 20,
                    _ => {}
                }
                if tree_count > 0 {
                    for _ in 0..tree_count {
                        let mut pos = pos
                            + IVec3 {
                                x: rand.next_int_bounded(16) + 8,
                                y: 0,
                                z: rand.next_int_bounded(16) + 8,
                            };
                        pos.y = world.get_height(pos).unwrap() as i32;
                        let mut gen = match biome {
                            Biome::Taiga => {
                                if rand.next_int_bounded(3) == 0 {
                                    TreeGenerator::new_spruce1()
                                } else {
                                    TreeGenerator::new_spruce2()
                                }
                            }
                            Biome::Forest => {
                                if rand.next_int_bounded(5) == 0 {
                                    TreeGenerator::new_birch()
                                } else if rand.next_int_bounded(3) == 0 {
                                    TreeGenerator::new_big_natural()
                                } else {
                                    TreeGenerator::new_oak()
                                }
                            }
                            Biome::RainForest => {
                                if rand.next_int_bounded(3) == 0 {
                                    TreeGenerator::new_big_natural()
                                } else {
                                    TreeGenerator::new_oak()
                                }
                            }
                            _ => {
                                if rand.next_int_bounded(10) == 0 {
                                    TreeGenerator::new_big_natural()
                                } else {
                                    TreeGenerator::new_oak()
                                }
                            }
                        };
                        gen.generate(world, pos, &mut rand);
                    }
                }
                let dandelion_count = match biome {
                    Biome::Forest => 2,
                    Biome::Taiga => 2,
                    Biome::SeasonalForest => 4,
                    Biome::Plains => 3,
                    _ => 0,
                };
                for _ in 0..dandelion_count {
                    let pos = pos + next_offset(&mut rand, 128, 8);
                    PlantGenerator::new_flower(block::DANDELION)
                        .generate(world, pos, &mut rand);
                }
                let tall_grass_count = match biome {
                    Biome::Forest => 2,
                    Biome::RainForest => 10,
                    Biome::SeasonalForest => 2,
                    Biome::Taiga => 1,
                    Biome::Plains => 10,
                    _ => 0,
                };
                for _ in 0..tall_grass_count {
                    let mut metadata = 1;
                    if biome == Biome::RainForest && rand.next_int_bounded(3) != 0 {
                        metadata = 2;
                    }
                    let pos = pos + next_offset(&mut rand, 128, 8);
                    PlantGenerator::new_tall_grass(metadata)
                        .generate(world, pos, &mut rand);
                }
                if biome == Biome::Desert {
                    for _ in 0..2 {
                        let pos = pos + next_offset(&mut rand, 128, 8);
                        PlantGenerator::new_dead_bush().generate(world, pos, &mut rand);
                    }
                }
                if rand.next_int_bounded(2) == 0 {
                    let pos = pos + next_offset(&mut rand, 128, 8);
                    PlantGenerator::new_flower(block::POPPY)
                        .generate(world, pos, &mut rand);
                }
                if rand.next_int_bounded(4) == 0 {
                    let pos = pos + next_offset(&mut rand, 128, 8);
                    PlantGenerator::new_flower(block::BROWN_MUSHROOM)
                        .generate(world, pos, &mut rand);
                }
                if rand.next_int_bounded(8) == 0 {
                    let pos = pos + next_offset(&mut rand, 128, 8);
                    PlantGenerator::new_flower(block::RED_MUSHROOM)
                        .generate(world, pos, &mut rand);
                }
                for _ in 0..10 {
                    let pos = pos + next_offset(&mut rand, 128, 8);
                    SugarCanesGenerator::new().generate(world, pos, &mut rand);
                }
                if rand.next_int_bounded(32) == 0 {
                    let pos = pos + next_offset(&mut rand, 128, 8);
                    PumpkinGenerator::new().generate(world, pos, &mut rand);
                }
                if biome == Biome::Desert {
                    for _ in 0..10 {
                        let pos = pos + next_offset(&mut rand, 128, 8);
                        CactusGenerator::new().generate(world, pos, &mut rand);
                    }
                }
                for _ in 0..50 {
                    let pos = pos
                        + IVec3 {
                            x: rand.next_int_bounded(16) + 8,
                            y: {
                                let v = rand.next_int_bounded(120);
                                rand.next_int_bounded(v + 8)
                            },
                            z: rand.next_int_bounded(16) + 8,
                        };
                    LiquidGenerator::new(block::WATER_MOVING)
                        .generate(world, pos, &mut rand);
                }
                for _ in 0..20 {
                    let pos = pos
                        + IVec3 {
                            x: rand.next_int_bounded(16) + 8,
                            y: {
                                let v = rand.next_int_bounded(112);
                                let v = rand.next_int_bounded(v + 8);
                                rand.next_int_bounded(v + 8)
                            },
                            z: rand.next_int_bounded(16) + 8,
                        };
                    LiquidGenerator::new(block::LAVA_MOVING)
                        .generate(world, pos, &mut rand);
                }
                let offset = DVec2::new((pos.x + 8) as f64, (pos.y + 8) as f64);
                let temperature = &mut state.temperature;
                let biome = &mut state.biome;
                self.temperature_noise
                    .gen_weird_2d(
                        temperature,
                        offset,
                        TEMPERATURE_SCALE,
                        TEMPERATURE_FREQ_FACTOR,
                    );
                self.biome_noise
                    .gen_weird_2d(biome, offset, BIOME_SCALE, BIOME_FREQ_FACTOR);
                for dx in 0usize..16 {
                    for dz in 0usize..16 {
                        let snow_pos = pos
                            + IVec3 {
                                x: dx as i32,
                                y: 0,
                                z: dz as i32,
                            };
                        let temp = temperature.get(dx, 0, dz)
                            - (snow_pos.y - 64) as f64 / 64.0 * 0.3;
                        if temp < 0.5 && snow_pos.y > 0 && snow_pos.y < 128
                            && world.is_block_air(snow_pos)
                        {
                            let material = world.get_block_material(snow_pos - IVec3::Y);
                            if material.is_solid() && material != Material::Ice {
                                world.set_block(snow_pos, block::SNOW, 0);
                            }
                        }
                    }
                }
                world.tick_light(usize::MAX);
            }
        }
    }
    pub use overworld::OverworldGenerator;
    /// A trait for all chunk generators, a chunk generator is immutable, if any mutable
    /// state needs to be stored, the `State` associated type can be used.
    pub trait ChunkGenerator {
        /// Type of the cache that is only owned by a single worker.
        type State: Default;
        /// Generate only the chunk biomes, this may never be called and this is not called
        /// before [`gen_terrain`](Self::gen_terrain).
        fn gen_biomes(
            &self,
            cx: i32,
            cz: i32,
            chunk: &mut Chunk,
            state: &mut Self::State,
        );
        /// Generate the given chunk's terrain, this should also generate the biomes
        /// associated to the terrain generation. The separate method
        /// [`gen_biomes`](Self::gen_biomes) is not called before that function.
        fn gen_terrain(
            &self,
            cx: i32,
            cz: i32,
            chunk: &mut Chunk,
            state: &mut Self::State,
        );
        /// Populate a chunk that is present in a world, note that this world is internal
        /// to the generator, this chunk will then be transferred to the real world when
        /// done. Populate usually applies with an offset of 8 blocks into the chunk with
        /// a 16x16 populate area, this means that neighbor chunks affected are also
        /// guaranteed to be loaded.
        fn gen_features(
            &self,
            cx: i32,
            cz: i32,
            world: &mut World,
            state: &mut Self::State,
        );
    }
    /// A trait common to all feature generators.
    pub trait FeatureGenerator {
        /// Generate the feature at the given position in the world with given RNG.
        fn generate(
            &mut self,
            world: &mut World,
            pos: IVec3,
            rand: &mut JavaRandom,
        ) -> bool;
    }
}
